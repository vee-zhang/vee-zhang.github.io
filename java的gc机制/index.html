<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Java的GC机制 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>Java的GC机制</h1><time datetime=2021-01-12T17:49:10Z class=post-date>Tue, Jan 12, 2021</time><blockquote><p>由于我对GC的理解一直不好，总是记不住，所以本篇博客完全撸了<a href=https://blog.csdn.net/weixin_43939602/article/details/117948764>一颗苹果的博客</a>,十分感谢原作者！</p></blockquote><h2 id=什么是垃圾>什么是垃圾</h2><p>Java进程运行后，如果某个<strong>类型(方法区中的类信息，堆中的类对象)，常量，对象</strong>，如果不可用，就成了垃圾。</p><p>提炼一下，垃圾的分类：</p><ul><li>类型</li><li>常量</li><li>变量</li></ul><h2 id=谁负责具体的回收>谁负责具体的回收</h2><p>GC线程负责具体回收工作，GC线程是个守护线程。</p><h2 id=回收的时机>回收的时机</h2><p>创建对象时，需要再对应的内存区域分配内存空间，如果该区域的空间不足，就会触发该区域的GC。</p><p><code>System.gc()</code>方法可<strong>建议GC</strong>，但是不能确保一定GC。</p><h2 id=垃圾判定算法>垃圾判定算法</h2><h3 id=引用计数法>引用计数法</h3><p>给对象增加一个引用计数器，每当增加一个引用时，计数器自加1；当引用失效时，计数器自减1；当计数器为0时被判定为垃圾。</p><p><strong>问题：当出现循环引用会无法GC。</strong></p><h3 id=可达性分析法>可达性分析法</h3><p>以<code>GC Root</code>对象作为起点，向下搜索，搜索的路径佳作“引用链”。当一个对象到GC Roots没有任何引用链相连时（不可达）,说明这个对象是垃圾。</p><p><img src=%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png alt=可达性算法示意图></p><h3 id=java的四种引用类型>Java的四种引用类型</h3><h4 id=强引用>强引用</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Object</span> <span class=n>o</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>();</span>
</span></span></code></pre></td></tr></table></div></div><p>只要是<code>new</code>出来的都是强引用，只要可达，就不能被回收，就算内存不足，JVM也只会抛出OOM异常。</p><h4 id=软引用>软引用</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span> <span class=n>sr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SoftReference</span><span class=o>&lt;&gt;(</span><span class=k>new</span> <span class=n>Object</span><span class=o>());</span>
</span></span></code></pre></td></tr></table></div></div><p>即使是可达的,但是一旦该区域空间不足(OOM)，就会被GC。</p><h4 id=弱引用>弱引用</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span> <span class=n>sr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>WeakReference</span><span class=o>&lt;&gt;(</span><span class=k>new</span> <span class=n>Object</span><span class=o>());</span>
</span></span></code></pre></td></tr></table></div></div><p>即使是可达的，但是一旦该区域发生GC，也会被同时GC掉。</p><h4 id=虚引用>虚引用</h4><p>这货基本不用，随时都有可能被回收，看心情？</p><h4 id=回收优先级>回收优先级</h4><p><strong>虚引用->弱引用->软引用->强引用</strong></p><h2 id=gc的位置>GC的位置</h2><p><img src=%E5%A0%86%E6%A8%A1%E5%9E%8B.png alt></p><p>从上图中可以看到JVMM划分成了两大块三大区和三小区：</p><ol><li>年轻代GC非常频繁，回收效率也高。</li><li>老年代GC速度比年轻代慢10倍以上。</li><li>永生代GC频率非常低，在jdk1.7叫方法区，1.8叫原空间。</li></ol><h2 id=gc算法>GC算法</h2><h3 id=标记清除法>标记清除法</h3><p>先标记不可达对象，再一次性释放所有标记过的对象。</p><p>特点：</p><ul><li>标记时只要找到一个引用就可证明对象存活着；</li><li>不移动对象位置；</li><li>由于两个阶段都采用遍历+递归的形式，所以两个阶段效率都不高；</li><li>回收后存在<strong>内存碎片</strong>，造成空间浪费。</li></ul><p>内存碎片：当创建非常大的对象时，一块区域不够用，所以JVM会给该对象分配另一块相连的区域；而GC时只会回收其中一块区域，另一块区域不会被回收，就形成了碎片。</p><h3 id=复制算法新生代采用>复制算法（新生代采用）</h3><p><strong>将可用内存按容量划分为大小相等的两块</strong>，每次只使用其中的一块。当这块内存需要进行垃圾回收时，会将此区域还<strong>存活着的对象</strong>复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。</p><p>特点：</p><ul><li>效率高</li><li>没有碎片问题</li><li>从原理上看浪费了一半空间</li></ul><h3 id=标记整理算法老年代采用>标记整理算法（老年代采用）</h3><p>标记出存活的对象，然后<strong>移动</strong>到另一块区域，再清理剩余内存。</p><p>特点：</p><ul><li>如果存活对象过多，会产生较多复制操作，导致效率低；</li><li>没有碎片。</li></ul><h3 id=分代收集算法jvm的整体算法>分代收集算法（JVM的整体算法）</h3><p>就是分成若干区域，什么新生代、老年代、永生代，然后进一步细分区域，每个区域采用不同的GC算法：</p><ul><li>新生代：对象生存周期短，每次回收会释放大量对象，所以采用复制算法；</li><li>老年代：对象存活率较高，没有额外的空间进行分配担保，所以采用标记整理算法。</li></ul><h2 id=鸣谢>鸣谢：</h2><p><a href=https://blog.csdn.net/laomo_bible/article/details/83112622>老莫8</a>
<a href=https://blog.csdn.net/weixin_43939602/article/details/117948764>一颗苹果</a></p></div></main></body></html>