<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>technology on Vee's space</title><link>https://vee-zhang.github.io/categories/technology/</link><description>Recent content in technology on Vee's space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor><webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 15 Jul 2021 14:13:55 +0800</lastBuildDate><atom:link href="https://vee-zhang.github.io/categories/technology/index.xml" rel="self" type="application/rss+xml"/><item><title>搭建pub私服及上传package</title><link>https://vee-zhang.github.io/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/</link><pubDate>Thu, 15 Jul 2021 14:13:55 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/</guid><description>&lt;p>事情的起因是，在工作项目中，一开始只有我一个人研发，为了方便，我封装了一个网络访问层。但是随着团队规模的拓展，陆续加入了其他人，时间紧项目重，所以后续的伙伴没有时间来问我这个框架怎么使用，所以他们直接上手改了我的封装！但是后期架构要求加入oauth2.0机制，所以需要全局处理token的有效认证，并且自动刷新token。为了满足这一需求，我需要重新编写网络层，同时为了避免伙伴修改我的抽象，我想到了本文的主题——搭建个pub.dev私服吧！&lt;/p></description></item><item><title>FlutterJsonBeanFactory原理</title><link>https://vee-zhang.github.io/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 25 Jun 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/</guid><description>创建类 1 2 3 4 5 class StudentEntity with JsonConvert&amp;lt;StudentEntity&amp;gt; { @JSONField(name: &amp;#34;name&amp;#34;) late String name; } 使用 1 2 3 4 5 6 7 8 9 10 11 //序列化 Map&amp;lt;String, dynamic&amp;gt; json = StudentEntity(name: &amp;#34;走两步试试&amp;#34;).toJson(); //</description></item><item><title>synchornized关键字</title><link>https://vee-zhang.github.io/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Wed, 06 Jan 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>反编译指令 1 javap -v XXX.class 监视器对象Monitor 原理 当synchronized加载代码块上，JVM会执行两条指令： 加锁：MonitorEnter 解</description></item></channel></rss>