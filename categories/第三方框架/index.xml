<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>第三方框架 on Vee's space</title><link>https://vee-zhang.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/</link><description>Recent content in 第三方框架 on Vee's space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor><webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 21 Feb 2023 17:36:44 +0800</lastBuildDate><atom:link href="https://vee-zhang.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>OkHttp的SSL握手溯源</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</link><pubDate>Tue, 21 Feb 2023 17:36:44 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</guid><description>&lt;p>最近研究PKI，想实现私钥不出TEE这个需求,需要确认okhttp中SSL认证的实现，结果说看看源码吧，让我好一顿找阿，特此记录一下过程。&lt;/p></description></item><item><title>Okhttp的链接池</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</link><pubDate>Fri, 29 Oct 2021 10:43:41 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</guid><description/></item><item><title>OkHttp的缓存机制</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link><pubDate>Sat, 18 Sep 2021 18:21:35 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid><description/></item><item><title>DiskLruCache</title><link>https://vee-zhang.github.io/disklrucache/</link><pubDate>Thu, 16 Sep 2021 10:05:42 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/disklrucache/</guid><description>&lt;p>之前已经了解过，OkHttp默认添加CacheInterceptor来处理缓存，而后者是依靠&lt;code>DiskLruCache&lt;/code>来实现硬盘缓存读写，所以我先去看了一下Android内置的&lt;code>LruCache&lt;/code>原理，是依靠java的&lt;code>LinkedHashMap&lt;/code>的LRU排序算法实现的，最后我准备详细看看&lt;code>DiskLruCache&lt;/code>是怎么基于硬盘缓存实现LRU的。&lt;/p></description></item><item><title>BridgeInterceptor</title><link>https://vee-zhang.github.io/bridgeinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/bridgeinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new BridgeInterceptor(client.cookieJar())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Bridges from application code to</description></item><item><title>CacheInterceptor</title><link>https://vee-zhang.github.io/cacheinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/cacheinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new CacheInterceptor(client.internalCache())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Serves requests from the cache</description></item><item><title>CallServerInterceptor</title><link>https://vee-zhang.github.io/callserverinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/callserverinterceptor/</guid><description/></item><item><title>ConnectInterceptor与StreamAllocation</title><link>https://vee-zhang.github.io/connectinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/connectinterceptor/</guid><description>ConnectInterceptor 连接拦截器 作为第二个实际生效的拦截器，ConnectInterceptor 的代码非常简单。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description></item><item><title>RetryAndFollowUpInterceptor</title><link>https://vee-zhang.github.io/retryandfollowupinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/retryandfollowupinterceptor/</guid><description>RealCall中的传值 1 2 3 4 5 6 private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } RealCall初始化时，会创建这个RetryAndFol</description></item><item><title>StreamAllocation</title><link>https://vee-zhang.github.io/streamallocation/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/streamallocation/</guid><description>初始化调用 1 2 3 4 5 6 7 8 9 10 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在Re</description></item><item><title>OkHttp3解读</title><link>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 07 Sep 2021 09:49:28 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid><description>&lt;p>回顾并且深入一下OkHttp（v3.10.0）的原理。&lt;/p></description></item></channel></rss>