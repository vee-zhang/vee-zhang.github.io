<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>UI卡顿与布局优化 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>UI卡顿与布局优化</h1><time datetime=2021-08-04T10:39:30+0800 class=post-date>Wed, Aug 4, 2021</time><h3 id=systrace>Systrace</h3><p>Systrace 是Android平台提供的一款工具，用于记录短期内的设备活动。该工具会生成一份报告，其中汇总了Android 内核中的数据，例如 CPU 调度程序、磁盘活动和应用线程。Systrace主要用来分析绘制性能方面的问题。在发生卡顿时，通过这份报告可以知道当前整个系统所处的状态，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p><p>需要安装Python，好吧，滚！</p><h3 id=过度渲染>过度渲染</h3><h4 id=布局层级优化>布局层级优化</h4><p>开发者工具中开启<strong>页面过度绘制监控</strong>，在屏幕上用颜色冷暖色调来监控绘制次数。</p><p>使用<strong>Layout Inspector</strong>工具可以直观的检查布局层级。</p><ul><li>ConstraintLayout减少嵌套；</li><li>merge标签重用父级布局；</li><li>ViewStub懒加载不需要立即显示的视图元素。</li></ul><h4 id=背景优化>背景优化</h4><p>去除不必要的背景，比如部分Activity、fragment中存在背景图片，但是并不可见，就需要移除。</p><h4 id=减少alpha的使用>减少alpha的使用</h4><p>对于不透明的View，只需要绘制一次即可，但是如果这个View设置了<code>Alpha</code>，则至少需要两次绘制。</p><p>解决方法是减少透明View的使用，或者直接使用ARGB替代。</p><h4 id=复杂页面异步处理>复杂页面异步处理</h4><p>需要用到AsyncLayoutInflater类：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-groovy data-lang=groovy><span class=line><span class=cl><span class=n>dependencies</span> <span class=o>{</span>
</span></span><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;androidx.asynclayoutinflater:asynclayoutinflater:1.0.0&#34;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>new</span> <span class=n>AsyncLayoutInflater</span><span class=o>(</span><span class=k>this</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>.</span><span class=na>inflate</span><span class=o>(</span><span class=n>R</span><span class=o>.</span><span class=na>layout</span><span class=o>.</span><span class=na>activity_main</span><span class=o>,</span> <span class=kc>null</span><span class=o>,</span> <span class=k>new</span> <span class=n>AsyncLayoutInflater</span><span class=o>.</span><span class=na>OnInflateFinishedListener</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onInflateFinished</span><span class=o>(</span><span class=nd>@NonNull</span> <span class=n>View</span> <span class=n>view</span><span class=o>,</span> <span class=kt>int</span> <span class=n>resid</span><span class=o>,</span> <span class=nd>@Nullable</span> <span class=n>ViewGroup</span> <span class=n>parent</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>setContentView</span><span class=o>(</span><span class=n>view</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//......
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>});</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=gc优化>GC优化</h4><p>由于Java的回收机制是stop the world，所以一旦发生GC就会挂起所有的线程，包括主线程，这就造成了UI的卡顿。为避免这种情况，需要尽可能少的发生GC，那么就要禁止在循环或者递归中创建无用的临时变量。</p><h3 id=大招>大招</h3><p>系统在渲染页面前做了三件事：</p><ol><li>读取layout.xml</li><li>递归解析xml</li><li>层层反射生成对象</li></ol><p>解决方式：</p><p>利用编译时注解处理器，通过java文件生成器（JavaPoet）在编译时生成布局的ViewGroup类，注入到Activity中。</p><p>缺点：不能使用merge标签，因为只有在运行时才知道父级使用什么布局。</p><h3 id=自定义view优化>自定义View优化</h3><ol><li>Draw方法中尽量不要创建对象。</li></ol></div></main></body></html>