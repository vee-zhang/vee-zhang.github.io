<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Handler的原理 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/handler%E9%AB%98%E7%BA%A7/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>Handler的原理</h1><time datetime=2021-03-04T10:40:11Z class=post-date>Thu, Mar 4, 2021</time><h2 id=handler的原理>Handler的原理</h2><p>内存共享方案，并且通过加锁避免线程之间的相互干扰。</p><blockquote><p>为何不用wait/notify</p></blockquote><p>答案：</p><p>通过阅读<code>main()</code>函数，会发现主线程完全就是基于loop来运行的，所以的Android完全就是在handler+loop+message上面玩的。那么Handler机制最核心的用途是：<strong>维持程序的运行！</strong>，而消息机制反而是次要用途。</p><h2 id=messagequeue的数据结构>MessageQueue的数据结构</h2><p>由单链表实现的优先级队列。</p><p>优先级队列，根据时间优先级的插入排序算法的单链表。</p><h2 id=threadlocal>ThreadLocal</h2><p>ThreadLocal是线程上下文的存储便变量，</p><p>[] 需要看一下ThreadLocal源码</p><h2 id=面试题>面试题</h2><ol><li>一个线程有几个Handler?
无数个。</li><li>一个线程有几个Looper?如何保证？
1个，ThreadLocal.</li><li>Handler内存泄露的原因？
匿名创建时，持有外部Activity的强引用，导致Activity不能GC。</li><li>在子线程new Handler();
需要自己调用Looper.prepary()和Looper.loop()。</li><li>子线程中维护的Looper当无消息的时候如何处理？
需要自己<code>Looper.quit()</code>，否则线程一直运行。</li><li>生产者消费者模型中的阻塞机制
使用epoll机制，当msg没到时间时，会epoll睡眠一段时间；当没有msg时，睡眠默认时间（很长）。当调用到enqueueMessage时，会调用nativeWake来唤醒。</li><li>消息队列无消息如何处理？
epoll机制睡眠，当<code>enqueueMessage()</code>时通过<code>nativeWake()</code>唤醒。整个过程是阻塞进行的。在子线程中，需要自己调用quit退出。</li><li>多个Handler向MessageQueue中添加数据，但是他们处于不同的线程中，怎么确保数据安全？
<code>sysnchronized</code>锁了this，锁的是当前的<code>MessageQueue</code>对象，他的所有的函数和代码块都会受限。</li><li>主线程是否允许quit？
主线程不允许，一旦调用就会抛异常。Zygote会fork自身，给每一个应用创建JVM，然后启动AcitivityThread，在后者执行的main方法中会调用<code>Looper.preparyMainLooper()</code>和<code>Looper.loop()</code>，应用的所有的代码都是在这个loop方法中运行的。</li><li>夸线程通信的原理？
通过共享内存实现。</li><li>为什么线程间不会干扰？
通过锁。</li><li>为什么不用wait/notify?
因为Java的wait/notify底层调用c++实现，Android自己实现了一个基于linux的epoll机制，效率更高？</li></ol><h2 id=todo>TODO</h2><ol><li>ThreadLocal原理进一步了解</li></ol></div></main></body></html>