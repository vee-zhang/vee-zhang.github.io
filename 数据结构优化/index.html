<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>数据结构优化 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>数据结构优化</h1><time datetime=2021-08-02T16:06:41+0800 class=post-date>Mon, Aug 2, 2021</time><h3 id=arraylist性能优化>ArrayList性能优化</h3><p>ArrayList由数组构成，在数据结构中叫做“顺序表”或者“线性表”。ArrayList的性能消耗主要在<strong>扩容</strong>和<strong>元素位移</strong>上。</p><h4 id=增删操作带来的性能损耗>增删操作带来的性能损耗</h4><p>性能优化的点，就在<code>add(T t)</code>方法。</p><p>add方法在调用时，使用<code>System.arrayCopy()</code>方法，其内部是<strong>遍历数组，更改下标，达到后移的效果</strong>，这种位移十分消耗性能。</p><p>所以<strong>ArrayList的<code>add</code>和<code>remove</code>方法非常消耗性能</strong>。</p><p>解决办法一：</p><p>尽量不要调用<code>add(int index,T t)</code>从中间插入，而是从最后add，那么就只有数组扩容，不需要位移。</p><p>解决方案二：</p><p>用LinkedList替换提高增删效率。在查询之前，转换为ArrayList。</p><p>解决方案三：</p><p>用Hashmap来替换，hashmap的特点就是增删快，查询也快。</p><h4 id=初始化时提高效率>初始化时提高效率</h4><p>因为ArrayList每次扩容固定10个，所以在创建ArrayList时可以设置默认长度为10，以提高第一add操作时的性能消耗。</p><h3 id=hashmap性能优化>HashMap性能优化</h3><h4 id=实现>实现</h4><ul><li>JDK1.7：数组+链表</li><li>JDK1.8：数组+链表+红黑树</li></ul><h4 id=怎么解决哈希碰撞>怎么解决哈希碰撞</h4><p>使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。</p><h4 id=大数据量查询优化>大数据量查询优化</h4><p>当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。</p><p>解决方法：重写key的<code>hashCode</code>降低hash冲突概率。</p><h4 id=扩容带来的性能消耗>扩容带来的性能消耗</h4><p><strong>如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存</strong>。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。</p><p>解决方案一：</p><p>预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。</p><h4 id=为什么要再put时初始化哈希表>为什么要再Put时初始化哈希表</h4><p>避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。</p><h4 id=为什么一定保证是2的次幂>为什么一定保证是2的次幂</h4><h4 id=spacearrayintobject原理>SpaceArray&lt;int,Object>原理</h4><p>双数组模型，二分查找。</p></div></main></body></html>