<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>ClassLoader学习.md &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/classloader%E5%AD%A6%E4%B9%A0/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>ClassLoader学习.md</h1><time datetime=2021-07-08T17:49:10Z class=post-date>Thu, Jul 8, 2021</time><h2 id=用途>用途</h2><p>读取.class文件的字节码并加载成内存形式的类对象。</p><h2 id=边解释边执行>边解释边执行</h2><p>JVM并不是一次性加载全部的类，而是需要用到才会去加载。比如加载了类，但是不会去加载类里面定义的对象类型的字段的类，因为暂时用不到。</p><h2 id=java内置的classloader>Java内置的ClassLoader</h2><ul><li><code>BootstrapClassLoader</code>
负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.xxx.* 都在里面，比如 java.util.<em>、java.io.</em>、java.nio.<em>、java.lang.</em> 等等。这个 ClassLoader 比较特殊，它是由 C 代码实现的，我们将它称之为「根加载器」。</li><li><code>ExtensionClassLoader</code>
负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，有很多 jar 包。</li><li><code>AppClassLoader</code>
这才是直接面向我们用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。</li><li><code>URLClassLoader</code>
专门用来加载位于网络上静态文件服务器提供的 jar 包和 class文件。</li></ul><h2 id=classloader的选择>ClassLoader的选择</h2><p>当我们定义一个ClassLoader，其内部都包含了一个ClassLoader，当遇到未知的类，JVM会选择调用者自己的ClassLoader去加载。</p><p>那么最初的调用者一定是持有<code>main()</code>方法的类，他持有的是<code>AppClassLoader</code>。</p><h2 id=双亲委派>双亲委派</h2><p>AppClassLoader只负责加载Classpath下面的类秒如果遇到没有加载过的系统类，他会将系统类库的加载工作交给<code>BootstrapClassLoader</code>和<code>ExtensionClassLoader</code>来做，这就叫<strong>双亲委派</strong>。</p><p>每个ClassLoader中都有一个<code>parent</code>属性指向父级，然后会优先让父级去加载，若父级加载失败，才轮到自己去加载：</p><p>AppClassLoader -> ExtensionClassLoader -> BootstrapClassLoader</p><blockquote><p>ExtensionClassLoader的parent的值为null，只要是parent=null的，说明父加载器就是BootstrapClassLoader。</p></blockquote><h2 id=使用classloader>使用ClassLoader</h2><h3 id=classforname>Class.forName</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Class</span><span class=o>.</span><span class=na>forName</span><span class=o>(</span><span class=s>&#34;com.mysql.cj.jdbc.Driver&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>forName</span><span class=o>(</span><span class=n>String</span> <span class=n>name</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>initialize</span><span class=o>,</span> <span class=n>ClassLoader</span> <span class=n>cl</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这个方法默认使用“调用者”的ClassLoader来加载目标类，并且可以选择其他的ClassLoader。</p><h3 id=classloaderloadclass>ClassLoader.loadClass</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ClassLoader</span><span class=o>.</span><span class=na>getSystemClassLoader</span><span class=o>().</span><span class=na>loadClass</span><span class=o>(</span><span class=s>&#34;[I&#34;</span><span class=o>);</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=使用>使用</h2><p>使用时一般都会结合反射。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>clazz1</span> <span class=o>=</span> <span class=n>App</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getClassLoader</span><span class=o>().</span><span class=na>loadClass</span><span class=o>(</span><span class=s>&#34;Student&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>clazz2</span> <span class=o>=</span> <span class=n>Student</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getClassLoader</span><span class=o>().</span><span class=na>loadClass</span><span class=o>(</span><span class=s>&#34;Student&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>clazz3</span> <span class=o>=</span> <span class=n>ClassLoader</span><span class=o>.</span><span class=na>getSystemClassLoader</span><span class=o>().</span><span class=na>loadClass</span><span class=o>(</span><span class=s>&#34;Student&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>clazz4</span> <span class=o>=</span> <span class=n>Class</span><span class=o>.</span><span class=na>forName</span><span class=o>(</span><span class=s>&#34;Student&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Object</span> <span class=n>obj1</span> <span class=o>=</span> <span class=n>clazz1</span><span class=o>.</span><span class=na>getConstructor</span><span class=o>().</span><span class=na>newInstance</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>clazz1</span><span class=o>.</span><span class=na>getMethods</span><span class=o>()[</span><span class=mi>0</span><span class=o>].</span><span class=na>invoke</span><span class=o>(</span><span class=n>obj1</span><span class=o>,</span> <span class=s>&#34;obj1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Object</span> <span class=n>obj2</span> <span class=o>=</span> <span class=n>clazz2</span><span class=o>.</span><span class=na>getConstructor</span><span class=o>().</span><span class=na>newInstance</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>clazz1</span><span class=o>.</span><span class=na>getMethods</span><span class=o>()[</span><span class=mi>0</span><span class=o>].</span><span class=na>invoke</span><span class=o>(</span><span class=n>obj2</span><span class=o>,</span> <span class=s>&#34;obj2&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Object</span> <span class=n>obj3</span> <span class=o>=</span> <span class=n>clazz3</span><span class=o>.</span><span class=na>getConstructor</span><span class=o>().</span><span class=na>newInstance</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>clazz1</span><span class=o>.</span><span class=na>getMethods</span><span class=o>()[</span><span class=mi>0</span><span class=o>].</span><span class=na>invoke</span><span class=o>(</span><span class=n>obj3</span><span class=o>,</span> <span class=s>&#34;obj3&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Object</span> <span class=n>obj4</span> <span class=o>=</span> <span class=n>clazz4</span><span class=o>.</span><span class=na>getConstructor</span><span class=o>().</span><span class=na>newInstance</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>clazz1</span><span class=o>.</span><span class=na>getMethods</span><span class=o>()[</span><span class=mi>0</span><span class=o>].</span><span class=na>invoke</span><span class=o>(</span><span class=n>obj4</span><span class=o>,</span> <span class=s>&#34;obj4&#34;</span><span class=o>);</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=自定义类加载器>自定义类加载器</h2><p>ClassLoader 里面有三个重要的方法 loadClass()、findClass() 和 defineClass()。</p><ul><li><code>ClassLoader</code> 不重写 用来加载目标类的入口。首先会查找当前自己和双亲是否已经加载目标类，没有的话就让双亲加载，弱失败，再调用<code>findClass()</code>。</li><li><code>findClass()</code> 需重写 去读取字节码，然后调用<code>defineClass()</code>。</li><li><code>defineClass()</code> 不重写 用来从字节码加载类对象。</li></ul></div></main></body></html>