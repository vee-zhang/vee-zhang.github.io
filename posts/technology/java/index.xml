<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Vee&#39;s space</title>
        <link>https://vee-zhang.github.io/posts/technology/java/</link>
        <description>所有文章 | Vee&#39;s space</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor>
            <webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://vee-zhang.github.io/posts/technology/java/" rel="self" type="application/rss+xml" /><item>
    <title>JNI学习</title>
    <link>https://vee-zhang.github.io/jni%E5%AD%A6%E4%B9%A0/</link>
    <pubDate>Sun, 15 Jan 2023 10:45:57 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/jni%E5%AD%A6%E4%B9%A0/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>Java中的范型</title>
    <link>https://vee-zhang.github.io/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/</link>
    <pubDate>Sat, 19 Mar 2022 15:33:02 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>LruCache</title>
    <link>https://vee-zhang.github.io/lrucache/</link>
    <pubDate>Wed, 15 Sep 2021 14:18:13 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/lrucache/</guid>
    <description><![CDATA[<p>LRU这个算法就是把最近一次使用时间离现在时间最远的数据删除掉，而实现LruCache将会频繁的执行插入、删除等操作，我们就会想到使用LinkedList，但是我们又要基于Key-Value来保存数据，这个时候我们就会想起HashMap，但是HashMap不能像linkedList那样保留数据的插入顺序，如果要使用HashMap的话可以使用它的一个子类LinkedHashMap。</p>]]></description>
</item><item>
    <title>ClassLoader学习.md</title>
    <link>https://vee-zhang.github.io/classloader%E5%AD%A6%E4%B9%A0/</link>
    <pubDate>Thu, 08 Jul 2021 17:49:10 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/classloader%E5%AD%A6%E4%B9%A0/</guid>
    <description><![CDATA[用途 读取.class文件的字节码并加载成内存形式的类对象。 边解释边执行 JVM并不是一次性加载全部的类，而是需要用到才会去加载。比如加载了类，]]></description>
</item><item>
    <title>Java IO</title>
    <link>https://vee-zhang.github.io/javaio/</link>
    <pubDate>Tue, 06 Jul 2021 16:57:01 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/javaio/</guid>
    <description><![CDATA[字节流 标准用法： 1 2 3 4 5 6 7 8 9 10 11 12 DataOutputStream out = new DataOutputStream(//负责数据类型 new BufferedOutputStream]]></description>
</item><item>
    <title>JVM内存结构</title>
    <link>https://vee-zhang.github.io/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link>
    <pubDate>Tue, 06 Jul 2021 16:57:01 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
    <description><![CDATA[JDK、JVM、Jre之间的关系 JVM 只负责把.class文件翻译成操作系统可识别的语句。 Jre 提供Java程序的运行环境 JDK 提供工具 JVM的三大区域]]></description>
</item><item>
    <title>从ReentrantLock看AQS原理</title>
    <link>https://vee-zhang.github.io/aqs%E5%8E%9F%E7%90%86/</link>
    <pubDate>Thu, 13 May 2021 15:33:07 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/aqs%E5%8E%9F%E7%90%86/</guid>
    <description><![CDATA[ReentrantLock的使用 1 2 3 4 5 6 ReentrantLock lock = new ReentrantLock(); try { lock.lock(); } finally { lock.unlock(); } AQS原理概述 1 private volatile int state; 维护了一个int state作为状态机，CLH队]]></description>
</item><item>
    <title>Java线程安全</title>
    <link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link>
    <pubDate>Fri, 19 Mar 2021 15:09:10 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid>
    <description><![CDATA[并发三大特性 原子性 操作要么成功，要么失败，中途不可被中断。 可见性 共享变量的变更立即可见。 有序性 程序执行依照代码的先后顺序来执行。 JMM模型 J]]></description>
</item><item>
    <title>Java线程</title>
    <link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B/</link>
    <pubDate>Fri, 19 Mar 2021 09:44:50 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B/</guid>
    <description><![CDATA[状态 new 新建 Runnable 可运行 Blocaked 阻塞 Waiting 等待 Timed waiting 计时等待 Terminated 终止 核心方法 void start()启动 void run()调用内部Runnable的run()。 public static void sleep(long mil]]></description>
</item><item>
    <title>Java线程池</title>
    <link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
    <pubDate>Thu, 18 Mar 2021 15:33:07 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
    <description><![CDATA[阻塞队列 BlockingQueue 生产者&amp;消费者模型 队列的意义： 生产者与消费者解耦 平衡生产与消费速度 可应用于消息中心 默认实现： 队列 界限 特点 ArrayBlockingQueue 有 一个由数组结构]]></description>
</item></channel>
</rss>
