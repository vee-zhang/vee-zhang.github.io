<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vee's space</title><link>https://vee-zhang.github.io/posts/technology/java/</link><description>Recent content on Vee's space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor><webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://vee-zhang.github.io/posts/technology/java/index.xml" rel="self" type="application/rss+xml"/><item><title>JNI学习</title><link>https://vee-zhang.github.io/jni%E5%AD%A6%E4%B9%A0/</link><pubDate>Sun, 15 Jan 2023 10:45:57 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/jni%E5%AD%A6%E4%B9%A0/</guid><description/></item><item><title>Java中的范型</title><link>https://vee-zhang.github.io/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/</link><pubDate>Sat, 19 Mar 2022 15:33:02 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/</guid><description/></item><item><title>LruCache</title><link>https://vee-zhang.github.io/lrucache/</link><pubDate>Wed, 15 Sep 2021 14:18:13 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/lrucache/</guid><description>&lt;p>LRU这个算法就是把最近一次使用时间离现在时间最远的数据删除掉，而实现LruCache将会频繁的执行插入、删除等操作，我们就会想到使用LinkedList，但是我们又要基于Key-Value来保存数据，这个时候我们就会想起HashMap，但是HashMap不能像linkedList那样保留数据的插入顺序，如果要使用HashMap的话可以使用它的一个子类LinkedHashMap。&lt;/p></description></item><item><title>ClassLoader学习.md</title><link>https://vee-zhang.github.io/classloader%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 08 Jul 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/classloader%E5%AD%A6%E4%B9%A0/</guid><description>用途 读取.class文件的字节码并加载成内存形式的类对象。 边解释边执行 JVM并不是一次性加载全部的类，而是需要用到才会去加载。比如加载了类，</description></item><item><title>Java IO</title><link>https://vee-zhang.github.io/javaio/</link><pubDate>Tue, 06 Jul 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/javaio/</guid><description>字节流 标准用法： 1 2 3 4 5 6 7 8 9 10 11 12 DataOutputStream out = new DataOutputStream(//负责数据类型 new BufferedOutputStream</description></item><item><title>JVM内存结构</title><link>https://vee-zhang.github.io/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 06 Jul 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid><description>JDK、JVM、Jre之间的关系 JVM 只负责把.class文件翻译成操作系统可识别的语句。 Jre 提供Java程序的运行环境 JDK 提供工具 JVM的三大区域</description></item><item><title>从ReentrantLock看AQS原理</title><link>https://vee-zhang.github.io/aqs%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 13 May 2021 15:33:07 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/aqs%E5%8E%9F%E7%90%86/</guid><description>ReentrantLock的使用 1 2 3 4 5 6 ReentrantLock lock = new ReentrantLock(); try { lock.lock(); } finally { lock.unlock(); } AQS原理概述 1 private volatile int state; 维护了一个int state作为状态机，CLH队</description></item><item><title>Java线程安全</title><link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link><pubDate>Fri, 19 Mar 2021 15:09:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid><description>并发三大特性 原子性 操作要么成功，要么失败，中途不可被中断。 可见性 共享变量的变更立即可见。 有序性 程序执行依照代码的先后顺序来执行。 JMM模型 J</description></item><item><title>Java线程</title><link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B/</link><pubDate>Fri, 19 Mar 2021 09:44:50 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B/</guid><description>状态 new 新建 Runnable 可运行 Blocaked 阻塞 Waiting 等待 Timed waiting 计时等待 Terminated 终止 核心方法 void start()启动 void run()调用内部Runnable的run()。 public static void sleep(long mil</description></item><item><title>Java线程池</title><link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Thu, 18 Mar 2021 15:33:07 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>阻塞队列 BlockingQueue 生产者&amp;amp;消费者模型 队列的意义： 生产者与消费者解耦 平衡生产与消费速度 可应用于消息中心 默认实现： 队列 界限 特点 ArrayBlockingQueue 有 一个由数组结构</description></item><item><title>HashMap速记</title><link>https://vee-zhang.github.io/hashmap%E9%80%9F%E8%AE%B0/</link><pubDate>Tue, 12 Jan 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/hashmap%E9%80%9F%E8%AE%B0/</guid><description>版本差异 版本 特点 JDK1.7 数组+单向链 JDK1.8 数组+单向链+红黑树 jdk1.7中，数组是HashMap的主体，而链表是为了解决哈希冲突而存在的。当链表过长</description></item><item><title>Java的GC机制</title><link>https://vee-zhang.github.io/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/</link><pubDate>Tue, 12 Jan 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/</guid><description>由于我对GC的理解一直不好，总是记不住，所以本篇博客完全撸了一颗苹果的博客,十分感谢原作者！ 什么是垃圾 Java进程运行后，如果某个类型(方法</description></item><item><title>CAS原理和问题</title><link>https://vee-zhang.github.io/cas/</link><pubDate>Thu, 07 Jan 2021 16:30:36 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/cas/</guid><description>死锁 死锁是指多个的线程在执行过程中，由于竞争资源或者由于批次通信而造成的一种阻塞现象。若无外力作用，他们都将无法推进下去。 悲观锁与乐观锁 悲观</description></item><item><title>synchornized关键字</title><link>https://vee-zhang.github.io/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Wed, 06 Jan 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>反编译指令 1 javap -v XXX.class 监视器对象Monitor 原理 当synchronized加载代码块上，JVM会执行两条指令： 加锁：MonitorEnter 解</description></item><item><title>序列化</title><link>https://vee-zhang.github.io/%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>序列化：Object =&amp;gt; String 反序列化：String =&amp;gt; Object 核心原理 序列化是把对象转成字符串的过程，那么转换之后的字符串，就保存在文件中，所以Java</description></item></channel></rss>