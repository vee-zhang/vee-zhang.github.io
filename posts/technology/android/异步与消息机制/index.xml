<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Vee&#39;s space</title>
        <link>https://vee-zhang.github.io/posts/technology/android/%E5%BC%82%E6%AD%A5%E4%B8%8E%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</link>
        <description>所有文章 | Vee&#39;s space</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor>
            <webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 24 Mar 2021 16:24:04 &#43;0000</lastBuildDate><atom:link href="https://vee-zhang.github.io/posts/technology/android/%E5%BC%82%E6%AD%A5%E4%B8%8E%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" rel="self" type="application/rss+xml" /><item>
    <title>Android内存泄露专题</title>
    <link>https://vee-zhang.github.io/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/</link>
    <pubDate>Wed, 24 Mar 2021 16:24:04 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/</guid>
    <description><![CDATA[原因 短生命周期对象持有长生命周期对象的强引用，造成短生命周期对象在不需要使用时不能被回收。 静态变量导致 1 2 3 4 5 6 7 8 9 10 11 12 13 public class MainActivity extends AppCompatActivity {]]></description>
</item><item>
    <title>HandlerThread解读</title>
    <link>https://vee-zhang.github.io/handlerthread%E8%A7%A3%E8%AF%BB/</link>
    <pubDate>Thu, 18 Mar 2021 14:22:41 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/handlerthread%E8%A7%A3%E8%AF%BB/</guid>
    <description><![CDATA[用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 步骤1：创建HandlerThread实例对象 // 传入参数 = 线程名字，作用 = 标记该]]></description>
</item><item>
    <title>AsyncTask解读</title>
    <link>https://vee-zhang.github.io/asynctask%E8%A7%A3%E8%AF%BB/</link>
    <pubDate>Wed, 17 Mar 2021 16:59:41 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/asynctask%E8%A7%A3%E8%AF%BB/</guid>
    <description><![CDATA[使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public class MainActivity extends]]></description>
</item><item>
    <title>ThreadLocal解读</title>
    <link>https://vee-zhang.github.io/threadlocal%E8%A7%A3%E8%AF%BB/</link>
    <pubDate>Wed, 17 Mar 2021 10:59:56 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/threadlocal%E8%A7%A3%E8%AF%BB/</guid>
    <description><![CDATA[从Set方法入手 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 从这里可]]></description>
</item><item>
    <title>Android中Message的一辈子</title>
    <link>https://vee-zhang.github.io/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/</link>
    <pubDate>Tue, 09 Mar 2021 20:51:17 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/</guid>
    <description><![CDATA[初始化 1 2 3 Looper.prepare(); Handler mHandler = new Handler(Looper.myLooper()); Looper.loop(); Looper.prepare()源码： 1 2 3 4 5 6 private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&#34;Only one Looper may be created per thread&#34;); } sThreadLocal.set(new Looper(quitAllowed)); } Looper的]]></description>
</item><item>
    <title>MessageQueue解读</title>
    <link>https://vee-zhang.github.io/messagequeue%E8%A7%A3%E8%AF%BB/</link>
    <pubDate>Thu, 04 Mar 2021 20:01:35 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/messagequeue%E8%A7%A3%E8%AF%BB/</guid>
    <description><![CDATA[回顾 handler发送消息： 1 2 3 4 5 6 7 8 9 10 private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);//最后调用的是]]></description>
</item><item>
    <title>Handler的原理</title>
    <link>https://vee-zhang.github.io/handler%E9%AB%98%E7%BA%A7/</link>
    <pubDate>Thu, 04 Mar 2021 10:40:11 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/handler%E9%AB%98%E7%BA%A7/</guid>
    <description><![CDATA[Handler的原理 内存共享方案，并且通过加锁避免线程之间的相互干扰。 为何不用wait/notify 答案： 通过阅读main()函数，会发现主]]></description>
</item><item>
    <title>Handler解读</title>
    <link>https://vee-zhang.github.io/handler%E8%A7%A3%E8%AF%BB/</link>
    <pubDate>Thu, 04 Mar 2021 10:40:11 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/handler%E8%A7%A3%E8%AF%BB/</guid>
    <description><![CDATA[构造方法 1 2 3 4 5 6 public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 构造方法中可以看到，handler持有Looper的MessageQueu]]></description>
</item><item>
    <title>Message解读</title>
    <link>https://vee-zhang.github.io/message%E8%A7%A3%E8%AF%BB/</link>
    <pubDate>Wed, 03 Mar 2021 15:03:03 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/message%E8%A7%A3%E8%AF%BB/</guid>
    <description><![CDATA[创建 我们都知道创建Message的时候有两种方式： 构造方法创建（不推荐）。 Message.obtain();（推荐）. 为了防止OOM，我们一]]></description>
</item><item>
    <title>Looper解读</title>
    <link>https://vee-zhang.github.io/looper%E8%A7%A3%E8%AF%BB/</link>
    <pubDate>Tue, 02 Mar 2021 17:30:46 &#43;0000</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/looper%E8%A7%A3%E8%AF%BB/</guid>
    <description><![CDATA[类图 prepare 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { // 如果线程已经有了Looper就会报错 if (sThreadLocal.get() != null) { throw new RuntimeException(&#34;Only one Looper may be created per thread&#34;); }]]></description>
</item></channel>
</rss>
