<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vee's space</title><link>https://vee-zhang.github.io/posts/technology/android/</link><description>Recent content on Vee's space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor><webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://vee-zhang.github.io/posts/technology/android/index.xml" rel="self" type="application/rss+xml"/><item><title>OkHttp的SSL握手溯源</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</link><pubDate>Tue, 21 Feb 2023 17:36:44 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</guid><description>&lt;p>最近研究PKI，想实现私钥不出TEE这个需求,需要确认okhttp中SSL认证的实现，结果说看看源码吧，让我好一顿找阿，特此记录一下过程。&lt;/p></description></item><item><title>广播</title><link>https://vee-zhang.github.io/%E5%B9%BF%E6%92%AD/</link><pubDate>Mon, 28 Mar 2022 23:23:10 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%B9%BF%E6%92%AD/</guid><description/></item><item><title>IntentService</title><link>https://vee-zhang.github.io/intentservice/</link><pubDate>Mon, 28 Mar 2022 22:47:09 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/intentservice/</guid><description>&lt;p>面试题：场景需要在子线程中依次执行多个子任务，要保证任务时序，所有子任务执行完毕该线程自动退出，怎么实现？&lt;/p></description></item><item><title>Service的使用</title><link>https://vee-zhang.github.io/service%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 28 Mar 2022 21:49:50 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/service%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description/></item><item><title>启动流程</title><link>https://vee-zhang.github.io/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Thu, 10 Mar 2022 18:51:54 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description/></item><item><title>Android系统启动流程</title><link>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Wed, 09 Mar 2022 17:32:28 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>按下电源键，首先从加载并运行BootLoader； BootLoader拉起linux内核； linux内核启动后会加载init.rc文件，并启</description></item><item><title>Okhttp的链接池</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</link><pubDate>Fri, 29 Oct 2021 10:43:41 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</guid><description/></item><item><title>OkHttp的缓存机制</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link><pubDate>Sat, 18 Sep 2021 18:21:35 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid><description/></item><item><title>DiskLruCache</title><link>https://vee-zhang.github.io/disklrucache/</link><pubDate>Thu, 16 Sep 2021 10:05:42 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/disklrucache/</guid><description>&lt;p>之前已经了解过，OkHttp默认添加CacheInterceptor来处理缓存，而后者是依靠&lt;code>DiskLruCache&lt;/code>来实现硬盘缓存读写，所以我先去看了一下Android内置的&lt;code>LruCache&lt;/code>原理，是依靠java的&lt;code>LinkedHashMap&lt;/code>的LRU排序算法实现的，最后我准备详细看看&lt;code>DiskLruCache&lt;/code>是怎么基于硬盘缓存实现LRU的。&lt;/p></description></item><item><title>BridgeInterceptor</title><link>https://vee-zhang.github.io/bridgeinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/bridgeinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new BridgeInterceptor(client.cookieJar())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Bridges from application code to</description></item><item><title>CacheInterceptor</title><link>https://vee-zhang.github.io/cacheinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/cacheinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new CacheInterceptor(client.internalCache())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Serves requests from the cache</description></item><item><title>CallServerInterceptor</title><link>https://vee-zhang.github.io/callserverinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/callserverinterceptor/</guid><description/></item><item><title>ConnectInterceptor与StreamAllocation</title><link>https://vee-zhang.github.io/connectinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/connectinterceptor/</guid><description>ConnectInterceptor 连接拦截器 作为第二个实际生效的拦截器，ConnectInterceptor 的代码非常简单。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description></item><item><title>RetryAndFollowUpInterceptor</title><link>https://vee-zhang.github.io/retryandfollowupinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/retryandfollowupinterceptor/</guid><description>RealCall中的传值 1 2 3 4 5 6 private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } RealCall初始化时，会创建这个RetryAndFol</description></item><item><title>StreamAllocation</title><link>https://vee-zhang.github.io/streamallocation/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/streamallocation/</guid><description>初始化调用 1 2 3 4 5 6 7 8 9 10 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在Re</description></item><item><title>OkHttp3解读</title><link>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 07 Sep 2021 09:49:28 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid><description>&lt;p>回顾并且深入一下OkHttp（v3.10.0）的原理。&lt;/p></description></item><item><title>Android屏幕适配</title><link>https://vee-zhang.github.io/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</link><pubDate>Tue, 10 Aug 2021 14:33:15 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</guid><description/></item><item><title>Android布局原理与xml解析</title><link>https://vee-zhang.github.io/android%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86%E4%B8%8Exml%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 12 Jul 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86%E4%B8%8Exml%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title>Android应用启动流程</title><link>https://vee-zhang.github.io/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 21 Jun 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>流程 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； sys</description></item><item><title>Apk打包和安装流程</title><link>https://vee-zhang.github.io/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 21 Jun 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</guid><description>.apk文件的组成 apk文件其实就是个压缩包，里面包含： classes.dex编译后的代码文件，安卓的可执行文件 resource.arsc 编译后的资源文件（raw）</description></item><item><title>Apk反编译流程</title><link>https://vee-zhang.github.io/%E5%8F%8D%E7%BC%96%E8%AF%91/</link><pubDate>Mon, 21 Jun 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%8F%8D%E7%BC%96%E8%AF%91/</guid><description>.apk文件的组成 apk文件其实就是个压缩包，里面包含： classes.dex文件 resource 打包流程 aapt编译打包资源文件，生成R.java。 编译</description></item><item><title>SharedPreferences解读</title><link>https://vee-zhang.github.io/sharedpreferences%E8%A7%A3%E8%AF%BB/</link><pubDate>Fri, 30 Apr 2021 14:22:41 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/sharedpreferences%E8%A7%A3%E8%AF%BB/</guid><description>SharedPreferences解读 SharedPreferences是我们平时常用的简单储存工具。优点就是用起来方便，而且线程安全，甚至</description></item><item><title>Parcelable解读</title><link>https://vee-zhang.github.io/parcelable%E8%A7%A3%E8%AF%BB/</link><pubDate>Fri, 12 Mar 2021 14:43:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/parcelable%E8%A7%A3%E8%AF%BB/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Data implements Parcelable</description></item><item><title>Binder解析</title><link>https://vee-zhang.github.io/binder%E8%A7%A3%E6%9E%90/</link><pubDate>Fri, 12 Mar 2021 11:06:25 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/binder%E8%A7%A3%E6%9E%90/</guid><description>Binder是什么 进程间通讯机制 系统驱动 Binder.java跨进程能力 为何要多进程 申请更多内存 安全性隔离 Binder的优势 机制 性能 特点 安全</description></item></channel></rss>