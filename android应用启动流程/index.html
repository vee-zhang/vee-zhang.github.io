<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Android应用启动流程 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>Android应用启动流程</h1><time datetime=2021-06-21T17:49:10Z class=post-date>Mon, Jun 21, 2021</time><h2 id=流程>流程</h2><p><img src=%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png alt></p><ol><li>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</li><li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li><li>Zygote进程fork出新的子进程，即App进程；</li><li>App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li><li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；</li><li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li><li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</li><li>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。</li></ol><h2 id=zygotefork自己不断增生>zygote（fork自己，不断增生）</h2><p><code>zygote</code>意思是受精卵，有分裂增生的意思。</p><p>它在Android中是一个独立的<strong>进程</strong>.</p><p>在linux中，所有的进程都是从<code>init进程</code>中fork出来的。当系统启动后会自动从init进程fork出一个<code>zygote</code>进程，当需要启动App时，会从这个初始<code>zygote</code>再fork出新的进程。</p><p>zygote被fork出来要做的就是通过binder向<code>sytem_server</code>发送<code>attachApplication</code>请求。</p><p>所以这货就两个作用：</p><ol><li>fork自己；</li><li>通知<code>sytem_server</code>附加Application。</li></ol><h2 id=system_server>system_server</h2><p>system_server也是一个独立的进程，而且也是从<code>zygote</code>中fork出来的。</p><p>当他收到应用的附加请求后，会通过binder通知应用进程去<code>scheduleLaunchActivity</code>。这里能够了解到，具体启动哪个activity是由app进程进程决定的。</p><p>系统里面很多重要的服务都是在这里启动的，比如ActivityManagerService、PackageManagerService、WindowManagerService等。</p><h2 id=activitymanagerserviceams>ActivityManagerService(AMS)</h2><p>服务端对象，<strong>负责管理系统中所有Activity的生命周期</strong>。</p><h2 id=instrumentation>Instrumentation</h2><p>每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。这个类就是完成对Application和Activity初始化和生命周期的工具类。</p><p>ActivityThread，依赖于UI线程。App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。</p><h2 id=applicationthread>ApplicationThread</h2></div></main></body></html>