<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vee's space</title><link>https://vee-zhang.github.io/</link><description>Recent content on Vee's space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor><webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 05 May 2023 14:13:05 +0800</lastBuildDate><atom:link href="https://vee-zhang.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Android的Log系统原理</title><link>https://vee-zhang.github.io/android%E7%9A%84log%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 05 May 2023 14:13:05 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E7%9A%84log%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</guid><description/></item><item><title>学习Makefile</title><link>https://vee-zhang.github.io/%E5%AD%A6%E4%B9%A0makefile/</link><pubDate>Mon, 10 Apr 2023 09:26:26 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%AD%A6%E4%B9%A0makefile/</guid><description/></item><item><title>关于编译器</title><link>https://vee-zhang.github.io/%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8/</link><pubDate>Sat, 08 Apr 2023 09:21:09 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8/</guid><description/></item><item><title>检查性能</title><link>https://vee-zhang.github.io/%E6%A3%80%E6%9F%A5%E6%80%A7%E8%83%BD/</link><pubDate>Mon, 20 Mar 2023 15:50:05 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%A3%80%E6%9F%A5%E6%80%A7%E8%83%BD/</guid><description>&lt;p>由于负责系统稳定性和性能监控的同事离职了，所以领导希望我来与剩下的同事一起负责这个事，那没法了，学吧～&lt;/p></description></item><item><title>TCP协议</title><link>https://vee-zhang.github.io/tcp%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 06 Mar 2023 13:29:40 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/tcp%E5%8D%8F%E8%AE%AE/</guid><description/></item><item><title>使用tcpdump抓包</title><link>https://vee-zhang.github.io/%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85/</link><pubDate>Fri, 03 Mar 2023 11:22:17 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85/</guid><description>&lt;p>最近搞PKI，遇到问题经常不明所以，后来找同事帮忙抓包才定位到原因，瞬间感觉学习抓包的重要。&lt;/p></description></item><item><title>OkHttp的SSL握手溯源</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</link><pubDate>Tue, 21 Feb 2023 17:36:44 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</guid><description>&lt;p>最近研究PKI，想实现私钥不出TEE这个需求,需要确认okhttp中SSL认证的实现，结果说看看源码吧，让我好一顿找阿，特此记录一下过程。&lt;/p></description></item><item><title>第三课：自定义模块</title><link>https://vee-zhang.github.io/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</link><pubDate>Tue, 07 Feb 2023 14:01:27 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</guid><description>&lt;p>这是我跟随秋少的系列课程Android系统开发入门做的笔记，感谢原博主秋少！
&lt;a href="http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/">课程连接&lt;/a>&lt;/p></description></item><item><title>第五课：使用java定义系统服务</title><link>https://vee-zhang.github.io/%E7%AC%AC%E4%BA%94%E8%AF%BE%E4%BD%BF%E7%94%A8java%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</link><pubDate>Tue, 07 Feb 2023 14:01:27 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%AC%AC%E4%BA%94%E8%AF%BE%E4%BD%BF%E7%94%A8java%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</guid><description>&lt;p>这是我跟随秋少的系列课程Android系统开发入门做的笔记，感谢原博主秋少！
&lt;a href="http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/">课程连接&lt;/a>&lt;/p></description></item><item><title>第一课：添加product</title><link>https://vee-zhang.github.io/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/</link><pubDate>Tue, 07 Feb 2023 14:01:27 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/</guid><description>&lt;p>这是我跟随秋少的系列课程Android系统开发入门做的笔记，感谢原博主秋少！
&lt;a href="http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/">课程连接&lt;/a>&lt;/p></description></item><item><title>第一课：添加系统属性</title><link>https://vee-zhang.github.io/%E7%AC%AC%E4%BA%8C%E8%AF%BE%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/</link><pubDate>Tue, 07 Feb 2023 14:01:27 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%AC%AC%E4%BA%8C%E8%AF%BE%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/</guid><description>&lt;p>这是我跟随秋少的系列课程Android系统开发入门做的笔记，感谢原博主秋少！
&lt;a href="http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/">课程连接&lt;/a>&lt;/p></description></item><item><title>JNI学习</title><link>https://vee-zhang.github.io/jni%E5%AD%A6%E4%B9%A0/</link><pubDate>Sun, 15 Jan 2023 10:45:57 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/jni%E5%AD%A6%E4%B9%A0/</guid><description/></item><item><title>C语言的输入</title><link>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5/</link><pubDate>Fri, 16 Dec 2022 14:45:39 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5/</guid><description/></item><item><title>C语言的Char</title><link>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Thu, 15 Dec 2022 17:29:25 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description/></item><item><title>C语言的符号位</title><link>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AC%A6%E5%8F%B7%E4%BD%8D/</link><pubDate>Thu, 15 Dec 2022 16:58:47 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AC%A6%E5%8F%B7%E4%BD%8D/</guid><description/></item><item><title>进制数的表示</title><link>https://vee-zhang.github.io/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/</link><pubDate>Thu, 15 Dec 2022 16:37:13 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/</guid><description/></item><item><title>1-1编程基础-ASCII与GBK</title><link>https://vee-zhang.github.io/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/</link><pubDate>Thu, 15 Dec 2022 15:39:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/</guid><description/></item><item><title>SELinux和SEAndroid</title><link>https://vee-zhang.github.io/selinux%E5%92%8Cseandroid/</link><pubDate>Mon, 12 Dec 2022 10:18:18 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/selinux%E5%92%8Cseandroid/</guid><description/></item><item><title>Android.mk与ndk-build</title><link>https://vee-zhang.github.io/ndk%E7%BC%96%E8%AF%91/</link><pubDate>Fri, 28 Oct 2022 14:05:44 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/ndk%E7%BC%96%E8%AF%91/</guid><description/></item><item><title>C语言简明教程</title><link>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 17 Oct 2022 15:49:18 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</guid><description/></item><item><title>ubuntu22.04上不能使用adb</title><link>https://vee-zhang.github.io/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/</link><pubDate>Mon, 10 Oct 2022 17:24:07 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/</guid><description>今天重新安装了ubuntu20.04LTS，安装了IDEA后发现不能用adb连接车机，报错： 1 no permissions (missing udev rules? user is in the plugdev group) 在这里找到了解决办法，感</description></item><item><title>手把手教你自定义HAL层</title><link>https://vee-zhang.github.io/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/</link><pubDate>Wed, 03 Aug 2022 17:30:15 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/</guid><description>&lt;p>最近工作要求，涉及到了HAL层开发，让我这个刚刚从上层转底层的小白无所适从，根本不知道怎么入手，从网上搜集了大堆的文章，照着做没有一个能成，前前后后一个月了，今天终于成功了，特此记录一下，希望能帮到其他像我一样高转低的同行吧。&lt;/p></description></item><item><title>编译技巧</title><link>https://vee-zhang.github.io/%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 25 Jul 2022 10:55:58 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7/</guid><description/></item><item><title>理解HAL</title><link>https://vee-zhang.github.io/%E7%90%86%E8%A7%A3hal/</link><pubDate>Mon, 18 Jul 2022 11:53:55 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%90%86%E8%A7%A3hal/</guid><description/></item><item><title>预处理器</title><link>https://vee-zhang.github.io/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>Mon, 18 Jul 2022 11:17:18 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</guid><description/></item><item><title>理解Android</title><link>https://vee-zhang.github.io/%E7%90%86%E8%A7%A3android.bp/</link><pubDate>Fri, 15 Jul 2022 13:32:52 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%90%86%E8%A7%A3android.bp/</guid><description/></item><item><title>Ubuntu无法进入桌面</title><link>https://vee-zhang.github.io/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/</link><pubDate>Wed, 13 Jul 2022 14:47:30 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/</guid><description>&lt;p>今天又弄了一下fcitx5,并且配置了go环境变量，然后重启了一下电脑，到了登录页面，输入密码，竟然又退到登录页面，无论如何也进不去桌面。&lt;/p></description></item><item><title>Ubuntu20.04安装fcitx5</title><link>https://vee-zhang.github.io/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/</link><pubDate>Tue, 12 Jul 2022 15:57:22 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/</guid><description/></item><item><title>vscode+gradle+kotlin</title><link>https://vee-zhang.github.io/vscode%E7%BC%96%E5%86%99kotlin/</link><pubDate>Thu, 07 Jul 2022 23:47:59 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/vscode%E7%BC%96%E5%86%99kotlin/</guid><description>&lt;p>最近事多，整天瞎忙，都是沟通、开会、填表格和填坑，今天想休息休息，打算有空再写写后端服务，把自己的网盘和图床先弄好。思来想去，自己一个人的项目，时间少，所以尽量还是要方便维护，那么就不要用JAVA了，罗里吧嗦的，可惜Dart这边没什么好的框架，要不然一个语言全站了，最终还是选择了kotlin，但是又不想用idea，于是我瞄向了vscode&amp;hellip;&lt;/p></description></item><item><title>adb</title><link>https://vee-zhang.github.io/adb/</link><pubDate>Thu, 07 Jul 2022 11:04:41 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/adb/</guid><description/></item><item><title>Logcat</title><link>https://vee-zhang.github.io/logcat/</link><pubDate>Wed, 06 Jul 2022 22:55:20 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/logcat/</guid><description>&lt;p>今天是我过得非常不爽的一天，因为今天说了『我不会』『我不懂』『我看不明白』，从哥2017年自学安卓到现在，从一点不会到基本不百度，我还没说过这些话。今天真是太刺激了，从上层转底层真的这么费劲吗，还是说年纪大了学不动了？都不是，是我一开始学系统底层还没找到要领，同时又事物缠身，分身无术。仔细想想还是先从常用工具入手，别他妈让我抓个log都这么费劲。&lt;/p></description></item><item><title>Ubuntu22.04安装配置repo</title><link>https://vee-zhang.github.io/ubuntu22.04%E5%AE%89%E8%A3%85repo/</link><pubDate>Wed, 29 Jun 2022 20:01:30 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/ubuntu22.04%E5%AE%89%E8%A3%85repo/</guid><description/></item><item><title>Android9刷写vendor中的apk</title><link>https://vee-zhang.github.io/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/</link><pubDate>Fri, 17 Jun 2022 20:44:32 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/</guid><description/></item><item><title>HTTPS</title><link>https://vee-zhang.github.io/https%E5%8D%8F%E8%AE%AE/</link><pubDate>Thu, 16 Jun 2022 10:58:50 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/https%E5%8D%8F%E8%AE%AE/</guid><description/></item><item><title>类图</title><link>https://vee-zhang.github.io/%E7%B1%BB%E5%9B%BE/</link><pubDate>Wed, 08 Jun 2022 09:20:05 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%B1%BB%E5%9B%BE/</guid><description/></item><item><title>属性动画</title><link>https://vee-zhang.github.io/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/</link><pubDate>Sun, 22 May 2022 00:47:26 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/</guid><description>&lt;p>前段时间面试滴滴的时候，跟面试官聊了一下属性动画，上来就问：你看过源码吗？我说没看过，然后他表示属性动画并不是真正的改变view的属性，原因是一个例子：在constraintlayout中，通过相互约束定义纵向的一列view，然后通过属性动画，让第一个view平移，你认为下面的view是否会跟着动？他的结论是从系统设计上，谷歌就不可能允许跟着动的情况，因为我们指定动画的目标就是第一个view，所以平移操作也应该局限在第一个view中，而不应该影响其他的view。我当时觉得他太牛逼了，能从源码想到设计思想，后面我还靠他这个结论去忽悠过其他人，而其他人也觉得我很牛逼，哈哈哈。今天心血来潮，自己写个demo测一下，通过属性动画去改view的x位置，结果下面的view真的没有跟着动，可是接下来的表现却让我瞠目结舌。&lt;/p></description></item><item><title>登录安全</title><link>https://vee-zhang.github.io/%E7%99%BB%E5%BD%95%E5%AE%89%E5%85%A8/</link><pubDate>Tue, 17 May 2022 17:16:10 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%99%BB%E5%BD%95%E5%AE%89%E5%85%A8/</guid><description>&lt;p>最近打算自己开发独立App，那么首先考虑的就是账号密码的网络传输安全，也就是所谓的登录安全。&lt;/p></description></item><item><title>客户端网络安全设计</title><link>https://vee-zhang.github.io/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/</link><pubDate>Tue, 17 May 2022 15:13:41 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/</guid><description/></item><item><title>链表</title><link>https://vee-zhang.github.io/%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 14 May 2022 20:54:34 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E9%93%BE%E8%A1%A8/</guid><description/></item><item><title>数组</title><link>https://vee-zhang.github.io/%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 14 May 2022 20:24:34 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%95%B0%E7%BB%84/</guid><description/></item><item><title>选择排序法</title><link>https://vee-zhang.github.io/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/</link><pubDate>Fri, 13 May 2022 17:29:21 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/</guid><description>&lt;p>同样基于交换的思想，选择排序法的效率要比冒泡排序高很多。&lt;/p></description></item><item><title>冒泡法</title><link>https://vee-zhang.github.io/%E5%86%92%E6%B3%A1%E6%B3%95/</link><pubDate>Fri, 13 May 2022 14:27:39 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%86%92%E6%B3%A1%E6%B3%95/</guid><description>&lt;p>冒泡法可以用来找队列中的最大值，也可以通过多次冒泡对集合进行排序。&lt;/p></description></item><item><title>时间复杂度与空间复杂度</title><link>https://vee-zhang.github.io/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link><pubDate>Thu, 12 May 2022 22:50:22 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid><description/></item><item><title>大数据量取top</title><link>https://vee-zhang.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/</link><pubDate>Thu, 12 May 2022 22:28:56 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/</guid><description>&lt;p>一个无限大的文件，里面包函大量的数据，需求是从中取出top50。&lt;/p></description></item><item><title>Flutter异常监控</title><link>https://vee-zhang.github.io/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/</link><pubDate>Wed, 20 Apr 2022 14:06:58 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/</guid><description/></item><item><title>性能优化总览</title><link>https://vee-zhang.github.io/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/</link><pubDate>Tue, 19 Apr 2022 16:56:16 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/</guid><description/></item><item><title>广播</title><link>https://vee-zhang.github.io/%E5%B9%BF%E6%92%AD/</link><pubDate>Mon, 28 Mar 2022 23:23:10 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%B9%BF%E6%92%AD/</guid><description/></item><item><title>IntentService</title><link>https://vee-zhang.github.io/intentservice/</link><pubDate>Mon, 28 Mar 2022 22:47:09 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/intentservice/</guid><description>&lt;p>面试题：场景需要在子线程中依次执行多个子任务，要保证任务时序，所有子任务执行完毕该线程自动退出，怎么实现？&lt;/p></description></item><item><title>Service的使用</title><link>https://vee-zhang.github.io/service%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 28 Mar 2022 21:49:50 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/service%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description/></item><item><title>单向链找倒数第N个节点</title><link>https://vee-zhang.github.io/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link><pubDate>Thu, 24 Mar 2022 20:26:52 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid><description>&lt;p>假设有个单向链，我们并不知道长度，要求找到倒数的第N个节点。&lt;/p></description></item><item><title>Java中的范型</title><link>https://vee-zhang.github.io/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/</link><pubDate>Sat, 19 Mar 2022 15:33:02 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/</guid><description/></item><item><title>Android事件分发机制</title><link>https://vee-zhang.github.io/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</link><pubDate>Fri, 11 Mar 2022 16:20:55 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</guid><description/></item><item><title>启动流程</title><link>https://vee-zhang.github.io/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Thu, 10 Mar 2022 18:51:54 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description/></item><item><title>Android系统启动流程</title><link>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Wed, 09 Mar 2022 17:32:28 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>按下电源键，首先从加载并运行BootLoader； BootLoader拉起linux内核； linux内核启动后会加载init.rc文件，并启</description></item><item><title>单例</title><link>https://vee-zhang.github.io/%E5%8D%95%E4%BE%8B/</link><pubDate>Thu, 24 Feb 2022 19:09:31 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%8D%95%E4%BE%8B/</guid><description/></item><item><title>Hugo的图片处理</title><link>https://vee-zhang.github.io/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/</link><pubDate>Mon, 17 Jan 2022 17:13:10 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/</guid><description>&lt;p>用了Hugo这一段时间，一直搞不明白图片怎么存放比较好，也一直弄不清楚&lt;strong>Leaf Bundle&lt;/strong>和&lt;strong>Branch Bundle&lt;/strong>有什么区别，今天有点时间，终于搞清楚了，并且图片也成功在Github-pages上显示出来了，特此记录一下吧！&lt;/p></description></item><item><title>树莓派安装docker-compose</title><link>https://vee-zhang.github.io/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85docker-compose/</link><pubDate>Mon, 17 Jan 2022 17:13:10 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85docker-compose/</guid><description>&lt;p>过年这几天鼓捣一下树莓派，结果各种麻烦，尤其是安装docker-compose，明明docker安装很顺畅，为啥这货就这么麻烦呢？&lt;/p></description></item><item><title>树莓派挂载移动硬盘</title><link>https://vee-zhang.github.io/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/</link><pubDate>Mon, 17 Jan 2022 17:13:10 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/</guid><description>&lt;p>过年这几天鼓捣一下树莓派，结果各种麻烦。。。尤其是在挂载exFat格式的移动硬盘的时候，明明临时挂载是没有问题的，但是一旦做了开机自动挂载的话，就连系统都启动不了了。经过不懈的百度，终于解决了问题，特此记录一下。&lt;/p></description></item><item><title>WebView性能优化</title><link>https://vee-zhang.github.io/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 06 Jan 2022 09:29:17 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>Okhttp的链接池</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</link><pubDate>Fri, 29 Oct 2021 10:43:41 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</guid><description/></item><item><title>OkHttp的缓存机制</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link><pubDate>Sat, 18 Sep 2021 18:21:35 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid><description/></item><item><title>DiskLruCache</title><link>https://vee-zhang.github.io/disklrucache/</link><pubDate>Thu, 16 Sep 2021 10:05:42 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/disklrucache/</guid><description>&lt;p>之前已经了解过，OkHttp默认添加CacheInterceptor来处理缓存，而后者是依靠&lt;code>DiskLruCache&lt;/code>来实现硬盘缓存读写，所以我先去看了一下Android内置的&lt;code>LruCache&lt;/code>原理，是依靠java的&lt;code>LinkedHashMap&lt;/code>的LRU排序算法实现的，最后我准备详细看看&lt;code>DiskLruCache&lt;/code>是怎么基于硬盘缓存实现LRU的。&lt;/p></description></item><item><title>LruCache</title><link>https://vee-zhang.github.io/lrucache/</link><pubDate>Wed, 15 Sep 2021 14:18:13 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/lrucache/</guid><description>&lt;p>LRU这个算法就是把最近一次使用时间离现在时间最远的数据删除掉，而实现LruCache将会频繁的执行插入、删除等操作，我们就会想到使用LinkedList，但是我们又要基于Key-Value来保存数据，这个时候我们就会想起HashMap，但是HashMap不能像linkedList那样保留数据的插入顺序，如果要使用HashMap的话可以使用它的一个子类LinkedHashMap。&lt;/p></description></item><item><title>BridgeInterceptor</title><link>https://vee-zhang.github.io/bridgeinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/bridgeinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new BridgeInterceptor(client.cookieJar())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Bridges from application code to</description></item><item><title>CacheInterceptor</title><link>https://vee-zhang.github.io/cacheinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/cacheinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new CacheInterceptor(client.internalCache())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Serves requests from the cache</description></item><item><title>CallServerInterceptor</title><link>https://vee-zhang.github.io/callserverinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/callserverinterceptor/</guid><description/></item><item><title>ConnectInterceptor与StreamAllocation</title><link>https://vee-zhang.github.io/connectinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/connectinterceptor/</guid><description>ConnectInterceptor 连接拦截器 作为第二个实际生效的拦截器，ConnectInterceptor 的代码非常简单。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description></item><item><title>Quarkus读取配置</title><link>https://vee-zhang.github.io/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>quarkus可以从.properties文件中读取配置。&lt;/p></description></item><item><title>RetryAndFollowUpInterceptor</title><link>https://vee-zhang.github.io/retryandfollowupinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/retryandfollowupinterceptor/</guid><description>RealCall中的传值 1 2 3 4 5 6 private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } RealCall初始化时，会创建这个RetryAndFol</description></item><item><title>StreamAllocation</title><link>https://vee-zhang.github.io/streamallocation/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/streamallocation/</guid><description>初始化调用 1 2 3 4 5 6 7 8 9 10 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在Re</description></item><item><title>OkHttp3解读</title><link>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 07 Sep 2021 09:49:28 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid><description>&lt;p>回顾并且深入一下OkHttp（v3.10.0）的原理。&lt;/p></description></item><item><title>HTTP协议</title><link>https://vee-zhang.github.io/http%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 31 Aug 2021 16:55:19 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/http%E5%8D%8F%E8%AE%AE/</guid><description/></item><item><title>七层协议</title><link>https://vee-zhang.github.io/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 23 Aug 2021 22:03:46 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</guid><description/></item><item><title>Android屏幕适配</title><link>https://vee-zhang.github.io/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</link><pubDate>Tue, 10 Aug 2021 14:33:15 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</guid><description/></item><item><title>AMS</title><link>https://vee-zhang.github.io/ams/</link><pubDate>Mon, 09 Aug 2021 15:48:25 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/ams/</guid><description/></item><item><title>Android虚拟机</title><link>https://vee-zhang.github.io/android%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>Mon, 09 Aug 2021 13:51:36 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description/></item><item><title>Crash监控</title><link>https://vee-zhang.github.io/crash%E7%9B%91%E6%8E%A7/</link><pubDate>Mon, 09 Aug 2021 10:17:20 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/crash%E7%9B%91%E6%8E%A7/</guid><description>&lt;p>Crash（应用崩溃）是由于代码异常而导致 App 非正常退出，导致应用程序无法继续使用，所有工作都停止的现象。发生 Crash 后需要重新启动应用（有些情况会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 Crash 发生，特别是在 Android 系统中，系统碎片化严重、各 ROM 之间的差异，甚至系统Bug，都可能会导致Crash的发生。在 Android 应用中发生的 Crash 有两种类型，Java 层的 Crash 和 Native 层 Crash。这两种Crash 的监控和获取堆栈信息有所不同。&lt;/p></description></item><item><title>APK瘦身</title><link>https://vee-zhang.github.io/apk%E7%98%A6%E8%BA%AB/</link><pubDate>Mon, 09 Aug 2021 09:15:00 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/apk%E7%98%A6%E8%BA%AB/</guid><description/></item><item><title>网络优化</title><link>https://vee-zhang.github.io/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/</link><pubDate>Fri, 06 Aug 2021 14:51:15 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>电量优化</title><link>https://vee-zhang.github.io/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/</link><pubDate>Fri, 06 Aug 2021 09:46:55 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>ANR问题解决</title><link>https://vee-zhang.github.io/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link><pubDate>Wed, 04 Aug 2021 13:39:14 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid><description/></item><item><title>UI卡顿与布局优化</title><link>https://vee-zhang.github.io/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</link><pubDate>Wed, 04 Aug 2021 10:39:30 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>Android启动优化</title><link>https://vee-zhang.github.io/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</link><pubDate>Tue, 03 Aug 2021 10:27:09 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>OOM与内存优化</title><link>https://vee-zhang.github.io/oom%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link><pubDate>Tue, 03 Aug 2021 10:16:07 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/oom%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>数据结构优化</title><link>https://vee-zhang.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 02 Aug 2021 16:06:41 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/</guid><description/></item><item><title>Android系统启动流程</title><link>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Wed, 28 Jul 2021 16:15:50 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description/></item><item><title>Android应用启动过程</title><link>https://vee-zhang.github.io/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Tue, 27 Jul 2021 14:46:26 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid><description/></item><item><title>Android系统架构</title><link>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link><pubDate>Tue, 27 Jul 2021 13:51:13 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid><description/></item><item><title>Android页面绘制流程</title><link>https://vee-zhang.github.io/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 26 Jul 2021 16:06:05 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</guid><description>Window Activity、Window、DecorView三者一一对应。 Window的分类 普通window，z轴范围1~99； 子window，z轴</description></item><item><title>Flutter 模块、包和插件(待续...)</title><link>https://vee-zhang.github.io/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link><pubDate>Fri, 23 Jul 2021 16:23:52 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid><description/></item><item><title>Flutter的生命周期函数</title><link>https://vee-zhang.github.io/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</link><pubDate>Fri, 23 Jul 2021 14:32:39 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</guid><description/></item><item><title>Travis持续发布Hugo博客</title><link>https://vee-zhang.github.io/travis%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83hugo%E5%8D%9A%E5%AE%A2/</link><pubDate>Thu, 22 Jul 2021 17:01:25 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/travis%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83hugo%E5%8D%9A%E5%AE%A2/</guid><description/></item><item><title>Dart-Future和Stream</title><link>https://vee-zhang.github.io/dart-future%E5%92%8Cstream/</link><pubDate>Wed, 21 Jul 2021 17:52:47 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/dart-future%E5%92%8Cstream/</guid><description/></item><item><title>Dart-任务队列</title><link>https://vee-zhang.github.io/dart-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</link><pubDate>Wed, 21 Jul 2021 17:23:36 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/dart-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</guid><description/></item><item><title>搭建pub私服及上传package</title><link>https://vee-zhang.github.io/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/</link><pubDate>Thu, 15 Jul 2021 14:13:55 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/</guid><description>&lt;p>事情的起因是，在工作项目中，一开始只有我一个人研发，为了方便，我封装了一个网络访问层。但是随着团队规模的拓展，陆续加入了其他人，时间紧项目重，所以后续的伙伴没有时间来问我这个框架怎么使用，所以他们直接上手改了我的封装！但是后期架构要求加入oauth2.0机制，所以需要全局处理token的有效认证，并且自动刷新token。为了满足这一需求，我需要重新编写网络层，同时为了避免伙伴修改我的抽象，我想到了本文的主题——搭建个pub.dev私服吧！&lt;/p></description></item><item><title>About</title><link>https://vee-zhang.github.io/about/</link><pubDate>Thu, 15 Jul 2021 09:40:45 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/about/</guid><description>关于我</description></item><item><title>linux目录结构</title><link>https://vee-zhang.github.io/linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 15 Jul 2021 09:40:45 +0800</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid><description>/bin： bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以</description></item><item><title>Android布局原理与xml解析</title><link>https://vee-zhang.github.io/android%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86%E4%B8%8Exml%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 12 Jul 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86%E4%B8%8Exml%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title>Android自定义ViewGroup</title><link>https://vee-zhang.github.io/android%E8%87%AA%E5%AE%9A%E4%B9%89viewgroup/</link><pubDate>Mon, 12 Jul 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E8%87%AA%E5%AE%9A%E4%B9%89viewgroup/</guid><description>自定义ViewGroup与自定义View不同，一般不需要重写onDraw，而是需要重写onLayout。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</description></item><item><title>ClassLoader学习.md</title><link>https://vee-zhang.github.io/classloader%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 08 Jul 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/classloader%E5%AD%A6%E4%B9%A0/</guid><description>用途 读取.class文件的字节码并加载成内存形式的类对象。 边解释边执行 JVM并不是一次性加载全部的类，而是需要用到才会去加载。比如加载了类，</description></item><item><title>Java IO</title><link>https://vee-zhang.github.io/javaio/</link><pubDate>Tue, 06 Jul 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/javaio/</guid><description>字节流 标准用法： 1 2 3 4 5 6 7 8 9 10 11 12 DataOutputStream out = new DataOutputStream(//负责数据类型 new BufferedOutputStream</description></item><item><title>JVM内存结构</title><link>https://vee-zhang.github.io/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 06 Jul 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid><description>JDK、JVM、Jre之间的关系 JVM 只负责把.class文件翻译成操作系统可识别的语句。 Jre 提供Java程序的运行环境 JDK 提供工具 JVM的三大区域</description></item><item><title>FlutterJsonBeanFactory原理</title><link>https://vee-zhang.github.io/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 25 Jun 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/</guid><description>创建类 1 2 3 4 5 class StudentEntity with JsonConvert&amp;lt;StudentEntity&amp;gt; { @JSONField(name: &amp;#34;name&amp;#34;) late String name; } 使用 1 2 3 4 5 6 7 8 9 10 11 //序列化 Map&amp;lt;String, dynamic&amp;gt; json = StudentEntity(name: &amp;#34;走两步试试&amp;#34;).toJson(); //</description></item><item><title>vscode快捷键记忆</title><link>https://vee-zhang.github.io/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BF%86/</link><pubDate>Thu, 24 Jun 2021 08:55:28 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BF%86/</guid><description>打开命令面板 ctrl+shift+P 跳转设置页面 ctrl+,</description></item><item><title>Android应用启动流程</title><link>https://vee-zhang.github.io/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 21 Jun 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>流程 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； sys</description></item><item><title>Apk打包和安装流程</title><link>https://vee-zhang.github.io/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 21 Jun 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</guid><description>.apk文件的组成 apk文件其实就是个压缩包，里面包含： classes.dex编译后的代码文件，安卓的可执行文件 resource.arsc 编译后的资源文件（raw）</description></item><item><title>Apk反编译流程</title><link>https://vee-zhang.github.io/%E5%8F%8D%E7%BC%96%E8%AF%91/</link><pubDate>Mon, 21 Jun 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%8F%8D%E7%BC%96%E8%AF%91/</guid><description>.apk文件的组成 apk文件其实就是个压缩包，里面包含： classes.dex文件 resource 打包流程 aapt编译打包资源文件，生成R.java。 编译</description></item><item><title>从ReentrantLock看AQS原理</title><link>https://vee-zhang.github.io/aqs%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 13 May 2021 15:33:07 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/aqs%E5%8E%9F%E7%90%86/</guid><description>ReentrantLock的使用 1 2 3 4 5 6 ReentrantLock lock = new ReentrantLock(); try { lock.lock(); } finally { lock.unlock(); } AQS原理概述 1 private volatile int state; 维护了一个int state作为状态机，CLH队</description></item><item><title>对SpringGateway+Security+OAuth2.0的认识</title><link>https://vee-zhang.github.io/recyclerview%E8%A7%A3%E8%AF%BB/</link><pubDate>Mon, 10 May 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/recyclerview%E8%A7%A3%E8%AF%BB/</guid><description>RV是什么 1 2 3 public class RecyclerView extends ViewGroup implements ScrollingView{ ... } 就是个ViewGroup，并且遵循了ScrollingView接口，所以支持滑动。 那么，既然是VG，那么我</description></item><item><title>SharedPreferences解读</title><link>https://vee-zhang.github.io/sharedpreferences%E8%A7%A3%E8%AF%BB/</link><pubDate>Fri, 30 Apr 2021 14:22:41 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/sharedpreferences%E8%A7%A3%E8%AF%BB/</guid><description>SharedPreferences解读 SharedPreferences是我们平时常用的简单储存工具。优点就是用起来方便，而且线程安全，甚至</description></item><item><title>Android内存泄露专题</title><link>https://vee-zhang.github.io/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/</link><pubDate>Wed, 24 Mar 2021 16:24:04 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/</guid><description>原因 短生命周期对象持有长生命周期对象的强引用，造成短生命周期对象在不需要使用时不能被回收。 静态变量导致 1 2 3 4 5 6 7 8 9 10 11 12 13 public class MainActivity extends AppCompatActivity {</description></item><item><title>研读自贸港政策</title><link>https://vee-zhang.github.io/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/</link><pubDate>Wed, 24 Mar 2021 16:24:04 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/</guid><description>中共中央 国务院印发海南自由贸易港建设总体方案 中共中央 国务院印发《海南自由贸易港建设总体方案》 新华社北京6月1日电 中共中央、国务院印发了《海南</description></item><item><title>View的前前后后</title><link>https://vee-zhang.github.io/view%E7%9A%84%E5%89%8D%E5%89%8D%E5%90%8E%E5%90%8E/</link><pubDate>Wed, 24 Mar 2021 16:16:23 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/view%E7%9A%84%E5%89%8D%E5%89%8D%E5%90%8E%E5%90%8E/</guid><description>setContentView 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Override public void setContentView(View v) { ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v); mAppCompatWindowCallback.getWrapped().onContentChanged(); } @Override public void setContentView(int resId) { ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mAppCompatWindowCallback.getWrapped().onContentChanged(); } @Override public void setContentView(View v, ViewGroup.LayoutParams lp) { ensureSubDecor(); ViewGroup contentParent =</description></item><item><title>View的工作原理</title><link>https://vee-zhang.github.io/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 22 Mar 2021 10:37:36 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid><description>三大流程 measure 用来测量View的宽高； layout 用来确定View在父容器中的放置位置； draw 负责绘制。 在ActivityThread中，当Activity创</description></item><item><title>View事件体系</title><link>https://vee-zhang.github.io/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</link><pubDate>Mon, 22 Mar 2021 08:55:28 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</guid><description>位置参数 主要位置参数 View的位置主要由它的四个顶点(相对父容器)来决定： getLeft() getTop() getRight() getBottom() 用于移动的参数 x/y View左上角相对父容器的坐标； translationX/translationY View</description></item><item><title>Java线程安全</title><link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link><pubDate>Fri, 19 Mar 2021 15:09:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid><description>并发三大特性 原子性 操作要么成功，要么失败，中途不可被中断。 可见性 共享变量的变更立即可见。 有序性 程序执行依照代码的先后顺序来执行。 JMM模型 J</description></item><item><title>Java线程</title><link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B/</link><pubDate>Fri, 19 Mar 2021 09:44:50 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B/</guid><description>状态 new 新建 Runnable 可运行 Blocaked 阻塞 Waiting 等待 Timed waiting 计时等待 Terminated 终止 核心方法 void start()启动 void run()调用内部Runnable的run()。 public static void sleep(long mil</description></item><item><title>Java线程池</title><link>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Thu, 18 Mar 2021 15:33:07 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>阻塞队列 BlockingQueue 生产者&amp;amp;消费者模型 队列的意义： 生产者与消费者解耦 平衡生产与消费速度 可应用于消息中心 默认实现： 队列 界限 特点 ArrayBlockingQueue 有 一个由数组结构</description></item><item><title>HandlerThread解读</title><link>https://vee-zhang.github.io/handlerthread%E8%A7%A3%E8%AF%BB/</link><pubDate>Thu, 18 Mar 2021 14:22:41 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/handlerthread%E8%A7%A3%E8%AF%BB/</guid><description>用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 步骤1：创建HandlerThread实例对象 // 传入参数 = 线程名字，作用 = 标记该</description></item><item><title>AsyncTask解读</title><link>https://vee-zhang.github.io/asynctask%E8%A7%A3%E8%AF%BB/</link><pubDate>Wed, 17 Mar 2021 16:59:41 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/asynctask%E8%A7%A3%E8%AF%BB/</guid><description>使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public class MainActivity extends</description></item><item><title>ThreadLocal解读</title><link>https://vee-zhang.github.io/threadlocal%E8%A7%A3%E8%AF%BB/</link><pubDate>Wed, 17 Mar 2021 10:59:56 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/threadlocal%E8%A7%A3%E8%AF%BB/</guid><description>从Set方法入手 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 从这里可</description></item><item><title>Parcelable解读</title><link>https://vee-zhang.github.io/parcelable%E8%A7%A3%E8%AF%BB/</link><pubDate>Fri, 12 Mar 2021 14:43:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/parcelable%E8%A7%A3%E8%AF%BB/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Data implements Parcelable</description></item><item><title>Binder解析</title><link>https://vee-zhang.github.io/binder%E8%A7%A3%E6%9E%90/</link><pubDate>Fri, 12 Mar 2021 11:06:25 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/binder%E8%A7%A3%E6%9E%90/</guid><description>Binder是什么 进程间通讯机制 系统驱动 Binder.java跨进程能力 为何要多进程 申请更多内存 安全性隔离 Binder的优势 机制 性能 特点 安全</description></item><item><title>Android中Message的一辈子</title><link>https://vee-zhang.github.io/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/</link><pubDate>Tue, 09 Mar 2021 20:51:17 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/</guid><description>初始化 1 2 3 Looper.prepare(); Handler mHandler = new Handler(Looper.myLooper()); Looper.loop(); Looper.prepare()源码： 1 2 3 4 5 6 private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&amp;#34;Only one Looper may be created per thread&amp;#34;); } sThreadLocal.set(new Looper(quitAllowed)); } Looper的</description></item><item><title>MessageQueue解读</title><link>https://vee-zhang.github.io/messagequeue%E8%A7%A3%E8%AF%BB/</link><pubDate>Thu, 04 Mar 2021 20:01:35 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/messagequeue%E8%A7%A3%E8%AF%BB/</guid><description>回顾 handler发送消息： 1 2 3 4 5 6 7 8 9 10 private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);//最后调用的是</description></item><item><title>Handler的原理</title><link>https://vee-zhang.github.io/handler%E9%AB%98%E7%BA%A7/</link><pubDate>Thu, 04 Mar 2021 10:40:11 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/handler%E9%AB%98%E7%BA%A7/</guid><description>Handler的原理 内存共享方案，并且通过加锁避免线程之间的相互干扰。 为何不用wait/notify 答案： 通过阅读main()函数，会发现主</description></item><item><title>Handler解读</title><link>https://vee-zhang.github.io/handler%E8%A7%A3%E8%AF%BB/</link><pubDate>Thu, 04 Mar 2021 10:40:11 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/handler%E8%A7%A3%E8%AF%BB/</guid><description>构造方法 1 2 3 4 5 6 public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 构造方法中可以看到，handler持有Looper的MessageQueu</description></item><item><title>Message解读</title><link>https://vee-zhang.github.io/message%E8%A7%A3%E8%AF%BB/</link><pubDate>Wed, 03 Mar 2021 15:03:03 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/message%E8%A7%A3%E8%AF%BB/</guid><description>创建 我们都知道创建Message的时候有两种方式： 构造方法创建（不推荐）。 Message.obtain();（推荐）. 为了防止OOM，我们一</description></item><item><title>Looper解读</title><link>https://vee-zhang.github.io/looper%E8%A7%A3%E8%AF%BB/</link><pubDate>Tue, 02 Mar 2021 17:30:46 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/looper%E8%A7%A3%E8%AF%BB/</guid><description>类图 prepare 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { // 如果线程已经有了Looper就会报错 if (sThreadLocal.get() != null) { throw new RuntimeException(&amp;#34;Only one Looper may be created per thread&amp;#34;); }</description></item><item><title>Fragment在Activity中的生命周期</title><link>https://vee-zhang.github.io/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 26 Feb 2021 11:17:35 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>记忆方式 Fragment的onAttach,onCreate,onCreateView,onViewCreated在附加到Activity时</description></item><item><title>GraphQL-Java(二)DataFetching</title><link>https://vee-zhang.github.io/graphql-java%E4%BA%8Cdatafetcher/</link><pubDate>Sat, 23 Jan 2021 22:28:28 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/graphql-java%E4%BA%8Cdatafetcher/</guid><description>GraphQL如何获取数据 每个field都有一个graphql.schema.DataFetcher与之对应。 一些File会使用特定的dat</description></item><item><title>GraphQL-Java(零)从SpringBoot服务端开始</title><link>https://vee-zhang.github.io/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 23 Jan 2021 16:38:19 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/</guid><description>引入依赖 1 2 3 4 5 6 7 dependencies { implementation &amp;#39;com.graphql-java:graphql-java:14.1&amp;#39; // NEW implementation &amp;#39;com.graphql-java:graphql-java-spring-boot-starter-webmvc:1.0&amp;#39; // NEW implementation &amp;#39;com.google.guava:guava:26.0-jre&amp;#39; // NEW implementation &amp;#39;org.springframework.boot:spring-boot-starter-web&amp;#39; testImplementation &amp;#39;org.springframework.boot:spring-boot-starter-test&amp;#39; } 定义Schema 在src/main/resources中创建schema.gra</description></item><item><title>GraphQl-Java(三)Execution</title><link>https://vee-zhang.github.io/graphql-java%E4%B8%89execution/</link><pubDate>Tue, 19 Jan 2021 10:13:53 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/graphql-java%E4%B8%89execution/</guid><description>Queries 如果想要在schema里跑个查询，需要用对应的参数创建一个新的GraphQL object，然后执行execute()。该方法会返回一个Ex</description></item><item><title>GraphQl-Java(一)Schema</title><link>https://vee-zhang.github.io/graphql-java%E4%B8%80schema/</link><pubDate>Tue, 19 Jan 2021 10:13:53 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/graphql-java%E4%B8%80schema/</guid><description>引入依赖 版本列表 Gradle 1 2 3 4 5 6 7 repositories { mavenCentral() } dependencies { compile &amp;#39;com.graphql-java:graphql-java:15.0&amp;#39; } Maven 1 2 3 4 5 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.graphql-java&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;graphql-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;15.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Schema——大纲 创建一个Schema有两种方式： 推荐SDL(sp</description></item><item><title>HashMap速记</title><link>https://vee-zhang.github.io/hashmap%E9%80%9F%E8%AE%B0/</link><pubDate>Tue, 12 Jan 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/hashmap%E9%80%9F%E8%AE%B0/</guid><description>版本差异 版本 特点 JDK1.7 数组+单向链 JDK1.8 数组+单向链+红黑树 jdk1.7中，数组是HashMap的主体，而链表是为了解决哈希冲突而存在的。当链表过长</description></item><item><title>Java的GC机制</title><link>https://vee-zhang.github.io/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/</link><pubDate>Tue, 12 Jan 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/</guid><description>由于我对GC的理解一直不好，总是记不住，所以本篇博客完全撸了一颗苹果的博客,十分感谢原作者！ 什么是垃圾 Java进程运行后，如果某个类型(方法</description></item><item><title>Java趣味题</title><link>https://vee-zhang.github.io/java%E8%B6%A3%E5%91%B3%E9%A2%98/</link><pubDate>Tue, 12 Jan 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/java%E8%B6%A3%E5%91%B3%E9%A2%98/</guid><description>java是引用传递还是值传递？ 结论，Java就是值传递，只不过在传递引用类型的时候，会把对象的引用地址当作值来传递。 首先声明一个引用类型： 1</description></item><item><title>对SpringGateway+Security+OAuth2.0的认识</title><link>https://vee-zhang.github.io/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/</link><pubDate>Tue, 12 Jan 2021 17:49:10 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/</guid><description>趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。 OAuth2.0 四种授权模式 模式 refresh_token 用途 authorization_code true 允许用户通过第三方应</description></item><item><title>CAS原理和问题</title><link>https://vee-zhang.github.io/cas/</link><pubDate>Thu, 07 Jan 2021 16:30:36 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/cas/</guid><description>死锁 死锁是指多个的线程在执行过程中，由于竞争资源或者由于批次通信而造成的一种阻塞现象。若无外力作用，他们都将无法推进下去。 悲观锁与乐观锁 悲观</description></item><item><title>synchornized关键字</title><link>https://vee-zhang.github.io/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Wed, 06 Jan 2021 16:57:01 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>反编译指令 1 javap -v XXX.class 监视器对象Monitor 原理 当synchronized加载代码块上，JVM会执行两条指令： 加锁：MonitorEnter 解</description></item><item><title>序列化</title><link>https://vee-zhang.github.io/%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>vee.night@qq.com (Vee Zhang)</author><guid>https://vee-zhang.github.io/%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>序列化：Object =&amp;gt; String 反序列化：String =&amp;gt; Object 核心原理 序列化是把对象转成字符串的过程，那么转换之后的字符串，就保存在文件中，所以Java</description></item></channel></rss>