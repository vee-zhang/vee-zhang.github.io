<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Java线程池 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>Java线程池</h1><time datetime=2021-03-18T15:33:07Z class=post-date>Thu, Mar 18, 2021</time><h2 id=阻塞队列-blockingqueue>阻塞队列 BlockingQueue</h2><p>生产者&消费者模型</p><p>队列的意义：</p><ul><li>生产者与消费者解耦</li><li>平衡生产与消费速度</li></ul><blockquote><p>可应用于消息中心</p></blockquote><p>默认实现：</p><table><thead><tr><th>队列</th><th>界限</th><th>特点</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>有</td><td>一个由数组结构组成的有界</td></tr><tr><td>LinkedBlockingQueue</td><td>有</td><td>链表结构</td></tr><tr><td>PriorityBlockingQueue</td><td>无</td><td>支持优先级排序，可以传入比较器</td></tr><tr><td>DelayQueue</td><td>无</td><td>支持优先级，支持元素的延迟获取</td></tr><tr><td>SynchronousQueue</td><td></td><td>不储存元素，用来解耦</td></tr><tr><td>LinkedTransferQueue</td><td>无</td><td>链表结构</td></tr><tr><td>LinkedBlockingQueue</td><td></td><td>双向链表</td></tr></tbody></table><p>有界&无界</p><ul><li>有界：长度有限，满了会阻塞；</li><li>无界：可以随意放东西，不会阻塞；</li></ul><h3 id=核心方法>核心方法</h3><p>　1.放入数据</p><ul><li>offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）；　　　　　　</li><li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。</li><li>put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</li><li>poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;</li><li>poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</li><li>take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入;</li><li>drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ul><h4 id=下面几个方法要记住>下面几个方法要记住</h4><table><thead><tr><th>方法</th><th>阻塞</th><th>作用</th></tr></thead><tbody><tr><td>offer</td><td>no</td><td>添加元素成功返回true，如果队列已满返回false，重载方法可以设置等待时间。</td></tr><tr><td>put</td><td>yes</td><td>添加元素，如果空间已满，会阻塞线程直到添加成功</td></tr><tr><td>poll</td><td>no</td><td>取走队列首位元素，可以设定等待时间，失败返回false</td></tr><tr><td>take</td><td>yes</td><td>取走队列首位元素，如果没有就会阻塞线程直到有了为止</td></tr><tr><td>drainTo</td><td></td><td>一次性获取多个或全部元素</td></tr></tbody></table><h2 id=java默认线程池>Java默认线程池</h2><ul><li><code>Executors.newCachedThreadPool()</code>，创建一个可缓存的无界线程池，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程。当线程空闲超过60秒自动回收，当任务超过线程池的线程数，可无限创建新线程；</li><li><code>Executors.newFixedThreadPool(int nThreads)</code>，创建一个指定大小的线程池，可控制线程的最大并发数，超出的线程会在<code>LinkedBlockingQueue</code>阻塞队列中等待；</li><li><code>Executors.newScheduledThreadPool</code>，创建一个定长的线程池，可以指定线程池核定线程数，<strong>支持定时及周期性任务</strong>的执行；</li><li><code>Executors.newSingleThreadExecutor</code>，创建一个单线程的线程池。</li><li><code>Executors.newWorkStealingPool（java8引入）</code>，创建一个更加高效的线程池，不同于以上四种线程池，这个线程池拓展于<code>ForkJoinPool</code>，适合用于非常耗时或自任务众多的场景。</li></ul><p>前四种是我们一般用到的线程池，都是拓展自ThreadPoolExecutor类。</p><h2 id=自定义线程池与threadpoolexecutor>自定义线程池与ThreadPoolExecutor</h2><p>我们也可以通过使用<code>ThreadPoolExecutor</code>类实现自定义线程池。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ThreadPoolExecutor</span><span class=o>(</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>corePoolSize</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>maximumPoolSize</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>keepAliveTime</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TimeUnit</span> <span class=n>unit</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BlockingQueue</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;</span> <span class=n>workQueue</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ThreadFactory</span> <span class=n>threadFactory</span>
</span></span><span class=line><span class=cl><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>参数解析：</p><ol><li>corePoolSize
线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果通过<code>allowCoreThreadTimeOut(boolean value)</code>方法设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime后，核心线程就会被终止。</li><li>maximumPoolSize
线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。</li><li>keepAliveTime
非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPool-Executor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程。</li><li>unit
用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit. MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）以及TimeUnit.MINUTES（分钟）等。</li><li>workQueue
线程池中的阻塞队列，用来容纳超出core线程数的runnable。</li><li>threadFactory
线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r)，一般使用默认的，也可以自定义用来设置thread-name。</li><li>Rejected-ExecutionHandler handler
当线程池无法执行新任务时，比如线程全忙并且队列已满，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecution-Exception。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值。</li></ol><p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p><ol><li>如果当前线程数小于core，那就创建线程直接执行；</li><li>如果core满了，就会把task放入BlockingQueue中排队；</li><li>如果BlockingQueue也满了，就新建线程直接执行；</li><li>如果当前线程数量超过maxPoolSizie，就拒绝。</li></ol><p>默认实现的拒绝策略：</p><ul><li>AbortPolicy 直接抛出异常（抛异常）；</li><li>DiscardPolicy 把新的任务直接扔掉（后进先出）。</li><li>DiscardOldestPolicy 直接丢弃最旧的还没执行的任务（先进先出）；</li><li>CallerRunsPolicy 让调用者所在线程去执行任务，比如调用者是主线程，就会切回主线程（扯皮）；</li></ul><h3 id=参数配置>参数配置</h3><p>AsyncTask支持并发时的配置：</p><p>通过以下代码获取CPU核心数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Runtime</span><span class=o>.</span><span class=na>getRuntime</span><span class=o>().</span><span class=na>availableProcessors</span><span class=o>()</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=配置原则>配置原则：</h4><ul><li>CPU密集型：大规模运算，没有阻塞，为减少cpu轮转次数，尽量减少线程数量，公式：<code>CPU核心数+1</code>;</li><li>IO密集型：阻塞多，尽量多给线程提高速度，公式：<code>CPU核心数*2</code>；</li><li>混合型：如果密集计算耗时与IO耗时差不多，就拆分成两个线程池来玩。</li></ul><p>AsyncTask的配置：</p><ul><li>核心线程数等于CPU核心数+1；</li><li>线程池的最大线程数为CPU核心数的2倍+1；</li><li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒；</li><li>任务队列的容量为128。</li></ul><blockquote><p>为什么要加1？因为在硬盘上有虚拟内存，为了在发生“页缺失”现象时，不让CPU核心闲置，所以要加1。</p></blockquote><h3 id=线程池的关闭>线程池的关闭</h3><ul><li>shutDown 关闭线程池，然后尝试中断当前<strong>没有执行任务的线程</strong>；</li><li>shutDownNow 尝试中断所有的线程。</li></ul><h2 id=原理>原理</h2><h3 id=execute任务调度>execute任务调度：</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//当前线程数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>final</span> <span class=n>AtomicInteger</span> <span class=n>ctl</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicInteger</span><span class=o>(</span><span class=n>ctlOf</span><span class=o>(</span><span class=n>RUNNING</span><span class=o>,</span> <span class=mi>0</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>execute</span><span class=o>(</span><span class=n>Runnable</span> <span class=n>command</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//当前运行的任务数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//如果小于核心数，就addWork
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>workerCountOf</span><span class=o>(</span><span class=n>c</span><span class=o>)</span> <span class=o>&lt;</span> <span class=n>corePoolSize</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果当前活跃线程数小于设置的核心线程数，直接执行任务
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>addWorker</span><span class=o>(</span><span class=n>command</span><span class=o>,</span> <span class=kc>true</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span> <span class=o>=</span> <span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//如果大于核心数，并且线程池还在运行，就添加到队列中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>isRunning</span><span class=o>(</span><span class=n>c</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>workQueue</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>command</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>recheck</span> <span class=o>=</span> <span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果线程池已经停止运行，就移除任务
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(!</span> <span class=n>isRunning</span><span class=o>(</span><span class=n>recheck</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>remove</span><span class=o>(</span><span class=n>command</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>//移除成功就执行拒绝策略
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>reject</span><span class=o>(</span><span class=n>command</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>workerCountOf</span><span class=o>(</span><span class=n>recheck</span><span class=o>)</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>//线程池不在运行状态，或者移除失败，并且当前没有任务，就开启一个空任务
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>addWorker</span><span class=o>(</span><span class=kc>null</span><span class=o>,</span> <span class=kc>false</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果添加任务失败，就执行拒绝策略
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=k>if</span> <span class=o>(!</span><span class=n>addWorker</span><span class=o>(</span><span class=n>command</span><span class=o>,</span> <span class=kc>false</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=n>reject</span><span class=o>(</span><span class=n>command</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>execute</code>方法主要用来调度任务，据当前原子计数器<code>c</code>的状态和任务数，</p><ul><li>如果当前任务数小于核心线程数，就直接<code>addWorker</code>；</li><li>如果大于核心线程数，就把任务添加到阻塞队列；</li><li>如果队列已满，尝试<code>addworker</code>;</li><li>如果队列满，addWorker失败，则执行拒绝策略。</li></ul><h3 id=addworker线程调度>addWorker线程调度</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//我才是真正的线程池子
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>final</span> <span class=n>HashSet</span><span class=o>&lt;</span><span class=n>Worker</span><span class=o>&gt;</span> <span class=n>workers</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashSet</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>addWorker</span><span class=o>(</span><span class=n>Runnable</span> <span class=n>firstTask</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>core</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//使用cas失败自旋来保证线程竞争问题
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>retry</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>runStateOf</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Check if queue empty only if necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>rs</span> <span class=o>&gt;=</span> <span class=n>SHUTDOWN</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=o>!</span> <span class=o>(</span><span class=n>rs</span> <span class=o>==</span> <span class=n>SHUTDOWN</span> <span class=o>&amp;&amp;</span> <span class=n>firstTask</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>workQueue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
</span></span><span class=line><span class=cl>            <span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=n>workerCountOf</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>wc</span> <span class=o>&gt;=</span> <span class=n>CAPACITY</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                <span class=n>wc</span> <span class=o>&gt;=</span> <span class=o>(</span><span class=n>core</span> <span class=o>?</span> <span class=n>corePoolSize</span> <span class=o>:</span> <span class=n>maximumPoolSize</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>//CAS操作
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndIncrementWorkerCount</span><span class=o>(</span><span class=n>c</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span> <span class=n>retry</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span> <span class=o>=</span> <span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>  <span class=c1>// Re-read ctl
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>runStateOf</span><span class=o>(</span><span class=n>c</span><span class=o>)</span> <span class=o>!=</span> <span class=n>rs</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span> <span class=n>retry</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=n>workerStarted</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=n>workerAdded</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Worker</span> <span class=n>w</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//Worker是对runnable和Thread的装箱，构造方法会调用ThreadFactory生成一个Thread
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>w</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Worker</span><span class=o>(</span><span class=n>firstTask</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>w</span><span class=o>.</span><span class=na>thread</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>final</span> <span class=n>ReentrantLock</span> <span class=n>mainLock</span> <span class=o>=</span> <span class=k>this</span><span class=o>.</span><span class=na>mainLock</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>mainLock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span><span class=c1>//上锁，
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>runStateOf</span><span class=o>(</span><span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>rs</span> <span class=o>&lt;</span> <span class=n>SHUTDOWN</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                    <span class=o>(</span><span class=n>rs</span> <span class=o>==</span> <span class=n>SHUTDOWN</span> <span class=o>&amp;&amp;</span> <span class=n>firstTask</span> <span class=o>==</span> <span class=kc>null</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=na>isAlive</span><span class=o>())</span> <span class=c1>// precheck that t is startable
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalThreadStateException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=c1>//添加进线程栈
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>workers</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>workers</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>&gt;</span> <span class=n>largestPoolSize</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>largestPoolSize</span> <span class=o>=</span> <span class=n>s</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>workerAdded</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>mainLock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>workerAdded</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//core线程直接运行
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>t</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=n>workerStarted</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(!</span> <span class=n>workerStarted</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>addWorkerFailed</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>workerStarted</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>addWorker</code>主要用来调度线程。首先创建work，然后把work添加进线程池<code>workers</code>，并通过主锁<code>mainLock</code>保证线程池<code>workers</code>的安全。最后启动<code>worker</code>的线程。</p><h3 id=work>work</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//ThreadPoolExecutor的匿名内部类，满足AQS实现不可重入的锁，满足Runnable，内部包含Thread
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>Worker</span>
</span></span><span class=line><span class=cl>        <span class=kd>extends</span> <span class=n>AbstractQueuedSynchronizer</span>
</span></span><span class=line><span class=cl>        <span class=kd>implements</span> <span class=n>Runnable</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//可以序列化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>serialVersionUID</span> <span class=o>=</span> <span class=mi>6138294804551838833L</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>final</span> <span class=n>Thread</span> <span class=n>thread</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//任务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Runnable</span> <span class=n>firstTask</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>volatile</span> <span class=kt>long</span> <span class=n>completedTasks</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//构造方法，调用时从ThreadFactory创建新的线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Worker</span><span class=o>(</span><span class=n>Runnable</span> <span class=n>firstTask</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>setState</span><span class=o>(-</span><span class=mi>1</span><span class=o>);</span> 
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>firstTask</span> <span class=o>=</span> <span class=n>firstTask</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//注意这里，给线程传入的是当前Worker
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=o>.</span><span class=na>thread</span> <span class=o>=</span> <span class=n>getThreadFactory</span><span class=o>().</span><span class=na>newThread</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//线程运行时会执行这个
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>runWorker</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//尝试Acquire
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryAcquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>unused</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetState</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//尝试释放
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryRelease</span><span class=o>(</span><span class=kt>int</span> <span class=n>unused</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>setState</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>lock</span><span class=o>()</span>        <span class=o>{</span> <span class=n>acquire</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>tryLock</span><span class=o>()</span>  <span class=o>{</span> <span class=k>return</span> <span class=n>tryAcquire</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>unlock</span><span class=o>()</span>      <span class=o>{</span> <span class=n>release</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isLocked</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=n>isHeldExclusively</span><span class=o>();</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//尝试中断
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>interruptIfStarted</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>getState</span><span class=o>()</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>t</span> <span class=o>=</span> <span class=n>thread</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>t</span><span class=o>.</span><span class=na>isInterrupted</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>t</span><span class=o>.</span><span class=na>interrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>SecurityException</span> <span class=n>ignore</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>work</code>是ThreadPoolExecutor的内部类，是一个满足AQS的<code>Runnable</code>，在构造方法中通过factory创建一个线程并传入他自身，那么当<code>addWork</code>时会启动这个线程，而线程会执行他自己的<code>run</code>方法，run方法又调用了外层类ThreadPoolExecutor的<code>runWorker</code>方法。</p><p><code>work</code>还提供了AQS操作和中断线程的方法，由此可见，<code>work</code>是Thread的<strong>装饰者</strong>。</p><h3 id=runworker复用线程>runWorker：复用线程</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=kt>void</span> <span class=nf>runWorker</span><span class=o>(</span><span class=n>Worker</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//拿到线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Thread</span> <span class=n>wt</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//拿到work构造方法传入的runnable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Runnable</span> <span class=n>task</span> <span class=o>=</span> <span class=n>w</span><span class=o>.</span><span class=na>firstTask</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>w</span><span class=o>.</span><span class=na>firstTask</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>w</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span> <span class=c1>// allow interrupts
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>boolean</span> <span class=n>completedAbruptly</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//循环执行任务
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//如果firstTask有值,就直接执行这个任务
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//如果没有具体的任务,就执行getTask()方法从队列中获取任务，当然这个操作是阻塞的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=o>(</span><span class=n>task</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>(</span><span class=n>task</span> <span class=o>=</span> <span class=n>getTask</span><span class=o>())</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>w</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>//检查线程池是否shutDown了，确保线程中断
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>((</span><span class=n>runStateAtLeast</span><span class=o>(</span><span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>(),</span> <span class=n>STOP</span><span class=o>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                    <span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>interrupted</span><span class=o>()</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>runStateAtLeast</span><span class=o>(</span><span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>(),</span> <span class=n>STOP</span><span class=o>)))</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=o>!</span><span class=n>wt</span><span class=o>.</span><span class=na>isInterrupted</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=n>wt</span><span class=o>.</span><span class=na>interrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>beforeExecute</span><span class=o>(</span><span class=n>wt</span><span class=o>,</span> <span class=n>task</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>Throwable</span> <span class=n>thrown</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//执行任务
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>task</span><span class=o>.</span><span class=na>run</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>RuntimeException</span> <span class=n>x</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>thrown</span> <span class=o>=</span> <span class=n>x</span><span class=o>;</span> <span class=k>throw</span> <span class=n>x</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Error</span> <span class=n>x</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>thrown</span> <span class=o>=</span> <span class=n>x</span><span class=o>;</span> <span class=k>throw</span> <span class=n>x</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Throwable</span> <span class=n>x</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>thrown</span> <span class=o>=</span> <span class=n>x</span><span class=o>;</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>Error</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>afterExecute</span><span class=o>(</span><span class=n>task</span><span class=o>,</span> <span class=n>thrown</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>task</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=n>w</span><span class=o>.</span><span class=na>completedTasks</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>                <span class=n>w</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>completedAbruptly</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>processWorkerExit</span><span class=o>(</span><span class=n>w</span><span class=o>,</span> <span class=n>completedAbruptly</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>runWorker</code>方法主要是对线程的控制，会循环调用<code>getTask</code>方法从任务队列中取出任务交给线程执行，达到线程复用的目的。当线程池shutDown时会中断线程。</p><h3 id=gettask阻塞队列取值>getTask阻塞队列取值</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=n>Runnable</span> <span class=nf>getTask</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=n>timedOut</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span> <span class=c1>// Did the last poll() time out?
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//死循环
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>ctl</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>runStateOf</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Check if queue empty only if necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>rs</span> <span class=o>&gt;=</span> <span class=n>SHUTDOWN</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>rs</span> <span class=o>&gt;=</span> <span class=n>STOP</span> <span class=o>||</span> <span class=n>workQueue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>decrementWorkerCount</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//当前任务数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=n>workerCountOf</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果当前任务数大于core，或者core线程也允许超时回收
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>boolean</span> <span class=n>timed</span> <span class=o>=</span> <span class=n>allowCoreThreadTimeOut</span> <span class=o>||</span> <span class=n>wc</span> <span class=o>&gt;</span> <span class=n>corePoolSize</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>((</span><span class=n>wc</span> <span class=o>&gt;</span> <span class=n>maximumPoolSize</span> <span class=o>||</span> <span class=o>(</span><span class=n>timed</span> <span class=o>&amp;&amp;</span> <span class=n>timedOut</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>wc</span> <span class=o>&gt;</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>workQueue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndDecrementWorkerCount</span><span class=o>(</span><span class=n>c</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//如果当前任务数大于core就等着拿，超时就返回null；否则就阻塞等，一直等到有了为止
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>Runnable</span> <span class=n>r</span> <span class=o>=</span> <span class=n>timed</span> <span class=o>?</span>
</span></span><span class=line><span class=cl>                <span class=n>workQueue</span><span class=o>.</span><span class=na>poll</span><span class=o>(</span><span class=n>keepAliveTime</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>NANOSECONDS</span><span class=o>)</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>                <span class=n>workQueue</span><span class=o>.</span><span class=na>take</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>r</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>r</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>timedOut</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>retry</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>timedOut</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>getTask</code>主要用于从任务队列中取值，如果当前任务数大于核心线程数就直接拿，否则会阻塞等。</p><h3 id=总结线程池的原理>总结线程池的原理</h3><p>线程池我们从<code>execute</code>方法入手，<code>execute</code>方法主要用来调度任务，据当前原子计数器<code>c</code>的状态和任务数，</p><ul><li>如果当前任务数小于核心线程数，就直接<code>addWorker</code>；</li><li>如果大于核心线程数，就把任务添加到阻塞队列；</li><li>如果队列已满，还是<code>addworker</code>;</li><li>如果队列满，addWorker失败，则执行拒绝策略。</li></ul><p><code>addWorker</code>主要用来调度线程。首先创建<code>worker</code>，然后把work添加进线程池<code>workers</code>，并通过主锁<code>mainLock</code>保证线程池<code>workers</code>的安全。最后启动<code>worker</code>的线程。</p><p><strong><code>work</code>是runnable的装饰者</strong>,除了具备runnable功能特性之外还提供AQS操作和中断线程的功能。它内部持有一个线程，由于他自己是runnable，所以线程会执行他自己，并再它自己的<code>run</code>方法内调用线程池的<code>runWorker</code>方法。</p><p><code>runWorker</code>通过循环调用<code>getTask()</code>方法取出阻塞队列中的runnable来执行，当线程池shutdown的时候会尽量中断线程。</p><p>而<code>getTask()</code>方法会从阻塞队列中取出首位任务。如果队列中有任务会poll等待取出，等待的时间为线程池参数<code>keepAliveTime</code>，否则就会调用take一直阻塞等待任务。</p><h2 id=retry标记>retry标记</h2><p>上面的<code>addWork</code>方法中出现了<code>retry:</code>标记，这个标记主要是用于在多重循环中标记需要中断的循环层，也可以用其他字母+：的方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//声明中断标记
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>aaa:</span>
</span></span><span class=line><span class=cl><span class=c1>//第一层循环f1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//第二层循环f2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>200</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=err>（</span><span class=n>j</span> <span class=o>==</span> <span class=mi>100</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>//将使f1跳过并继续
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>continue</span> <span class=n>aaa</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div></div></main></body></html>