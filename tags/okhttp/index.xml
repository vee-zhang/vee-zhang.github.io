<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>okhttp - 标签 - Vee's space</title><link>https://vee-zhang.github.io/tags/okhttp/</link><description>okhttp - 标签 - Vee's space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor><webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 21 Feb 2023 17:36:44 +0800</lastBuildDate><atom:link href="https://vee-zhang.github.io/tags/okhttp/" rel="self" type="application/rss+xml"/><item><title>OkHttp的SSL握手溯源</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</link><pubDate>Tue, 21 Feb 2023 17:36:44 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/</guid><description>&lt;p>最近研究PKI，想实现私钥不出TEE这个需求,需要确认okhttp中SSL认证的实现，结果说看看源码吧，让我好一顿找阿，特此记录一下过程。&lt;/p></description></item><item><title>Okhttp的链接池</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</link><pubDate>Fri, 29 Oct 2021 10:43:41 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</guid><description></description></item><item><title>OkHttp的缓存机制</title><link>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link><pubDate>Sat, 18 Sep 2021 18:21:35 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid><description></description></item><item><title>DiskLruCache</title><link>https://vee-zhang.github.io/disklrucache/</link><pubDate>Thu, 16 Sep 2021 10:05:42 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/disklrucache/</guid><description><![CDATA[<p>之前已经了解过，OkHttp默认添加CacheInterceptor来处理缓存，而后者是依靠<code>DiskLruCache</code>来实现硬盘缓存读写，所以我先去看了一下Android内置的<code>LruCache</code>原理，是依靠java的<code>LinkedHashMap</code>的LRU排序算法实现的，最后我准备详细看看<code>DiskLruCache</code>是怎么基于硬盘缓存实现LRU的。</p>]]></description></item><item><title>BridgeInterceptor</title><link>https://vee-zhang.github.io/bridgeinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/bridgeinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new BridgeInterceptor(client.cookieJar())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用这个类的注释如下： Bridges from application code to</description></item><item><title>CacheInterceptor</title><link>https://vee-zhang.github.io/cacheinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/cacheinterceptor/</guid><description>RealCall中的传值 1 2 3 ... interceptors.add(new CacheInterceptor(client.internalCache())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用这个类的注释如下： Serves requests from the cache</description></item><item><title>CallServerInterceptor</title><link>https://vee-zhang.github.io/callserverinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/callserverinterceptor/</guid><description></description></item><item><title>ConnectInterceptor与StreamAllocation</title><link>https://vee-zhang.github.io/connectinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/connectinterceptor/</guid><description>ConnectInterceptor 连接拦截器作为第二个实际生效的拦截器，ConnectInterceptor 的代码非常简单。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description></item><item><title>RetryAndFollowUpInterceptor</title><link>https://vee-zhang.github.io/retryandfollowupinterceptor/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/retryandfollowupinterceptor/</guid><description>RealCall中的传值 1 2 3 4 5 6 private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } RealCall初始化时，会创建这个RetryAndFol</description></item><item><title>StreamAllocation</title><link>https://vee-zhang.github.io/streamallocation/</link><pubDate>Tue, 07 Sep 2021 17:45:01 +0800</pubDate><author><name>Vee Zhang</name></author><guid>https://vee-zhang.github.io/streamallocation/</guid><description>初始化调用 1 2 3 4 5 6 7 8 9 10 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在Re</description></item></channel></rss>