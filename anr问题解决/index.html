<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>ANR问题解决 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>ANR问题解决</h1><time datetime=2021-08-04T13:39:14+0800 class=post-date>Wed, Aug 4, 2021</time><h3 id=anr的概念>ANR的概念</h3><p>是指应用程序未响应。</p><p>由 <code>ActivityManager</code> 和 <code>WindowManager</code> 两个系统服务进行监视的。</p><h3 id=anr产生场景>ANR产生场景</h3><ol><li>主线程耗时操作</li><li>SP</li><li>序列化</li><li>并发造成死锁，block了主线程</li><li>系统资源耗尽</li></ol><h3 id=行为>行为</h3><ul><li>前台产生ANR弹框询问用户是否等待；</li><li>后台产生的ANR直接崩溃。</li></ul><h3 id=时限>时限</h3><table><thead><tr><th>场景</th><th>时常</th></tr></thead><tbody><tr><td>前台服务</td><td>20S</td></tr><tr><td>后台服务</td><td>200S</td></tr><tr><td>前台广播</td><td>10S</td></tr><tr><td>后台广播</td><td>60S</td></tr><tr><td>ContentProvider</td><td>10S</td></tr><tr><td>输入事件</td><td>5S</td></tr></tbody></table><h3 id=anr的错误日志>ANR的错误日志</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>2021-08-04 14:07:55.885 4563-4574/com.vee.myapplication I/e.myapplicatio: Thread<span class=o>[</span>7,tid<span class=o>=</span>4574,WaitingInMainSignalCatcherLoop,Thread*<span class=o>=</span>0x7250d39c00,peer<span class=o>=</span>0x167402a0,<span class=s2>&#34;Signal Catcher&#34;</span><span class=o>]</span>: reacting to signal <span class=m>3</span>
</span></span><span class=line><span class=cl>2021-08-04 14:07:56.015 4563-4574/com.vee.myapplication I/e.myapplicatio: Wrote stack traces to tombstoned
</span></span><span class=line><span class=cl>2021-08-04 14:08:07.027 4563-4563/com.vee.myapplication I/Choreographer: Skipped <span class=m>1202</span> frames!  The application may be doing too much work on its main thread.
</span></span></code></pre></td></tr></table></div></div><h4 id=最重要的一句话>最重要的一句话</h4><p><strong>The application may be doing too much work on its main thread.</strong></p><h3 id=trace文件><del>trace文件</del></h3><p>位置： <code>data/anr/traces_*.txt</code></p><p>找到firstPid，即发生ANR的进程id。</p><p>trace包含ANR的时间点和CPU使用率、主线程状态、其他线程状态等重要信息。</p><p>但是5.0之后会被selinux挡住，获取不到。</p><h3 id=墓碑文件>墓碑文件</h3><p>看log中间的一条 <code>Wrote stack traces to tombstoned</code> ，意思已经把对战追踪写入了墓碑文件。<strong>墓碑文件没有读写权限</strong>。</p><h3 id=线上监控>线上监控</h3><p>线上监控的难点就在于，前台发生的ANR没有崩溃</p><h4 id=fileobserver><del>FileObserver</del></h4><p>此方案基本不能用了。</p><p>原理是监控 <code>/data/anr</code> 文件夹的变化，然后判断pid。</p><h4 id=blockcanary><del>BlockCanary</del></h4><p>由于Android是基于消息驱动的，在Loop.loop()方法中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JAVA data-lang=JAVA><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>loop</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=o>(;;){</span>
</span></span><span class=line><span class=cl>    <span class=n>Message</span> <span class=n>msg</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=o>(</span><span class=n>logging</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>){</span>
</span></span><span class=line><span class=cl>      <span class=n>logging</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=s>&#34;&gt;&gt;&gt;&gt;Dispatching to&#34;</span><span class=o>+</span><span class=n>msg</span><span class=o>.</span><span class=na>target</span><span class=o>+</span><span class=n>msg</span><span class=o>.</span><span class=na>what</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>msg</span><span class=o>.</span><span class=na>target</span><span class=o>.</span><span class=na>dispatchMessage</span><span class=o>(</span><span class=n>msg</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>根据 <code>queue.next()</code> 与 <code>msg.target.dispatchMessage(msg)</code> 的时间差来判断是否发生ANR，做法是自定义一个looging传进去：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Looper</span><span class=o>.</span><span class=na>getMainLooper</span><span class=o>.</span><span class=na>setMessageLogging</span><span class=o>(</span><span class=n>myLogging</span><span class=o>);</span>
</span></span></code></pre></td></tr></table></div></div><p>通过重写 <code>print</code> 方法加入我们自己的逻辑。</p><p>问题：logging有可能被改成null，反而造成NPE问题。</p><h4 id=safelooper><del>SafeLooper</del></h4><p>反射hook主线程的looper，接管功能，插入时间差判断，但反射导致大量性能损耗。</p><h4 id=仿watchdog><del>仿WatchDog</del></h4><p>启动一个守护线程，先向主线程发送一个消息，再通过 <code>handler.postDelay()</code> 休眠，而delay时间就是ANR的阈值，delay到期后判断主线程是否确实收到消息。</p><h4 id=微信的解决方案>微信的解决方案</h4><p><a href=https://cloud.tencent.com/developer/article/1848945>腾讯Matrix for Android对ANR监控的原理</a></p><blockquote><p>看完这篇文章，让我深深的认识到了什么是差距，什么是价值。</p></blockquote></div></main></body></html>