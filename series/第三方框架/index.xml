<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>第三方框架 - 系列 - Vee&#39;s space</title>
        <link>https://vee-zhang.github.io/series/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/</link>
        <description>第三方框架 - 系列 - Vee&#39;s space</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vee.night@qq.com (Vee Zhang)</managingEditor>
            <webMaster>vee.night@qq.com (Vee Zhang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 29 Oct 2021 10:43:41 &#43;0800</lastBuildDate><atom:link href="https://vee-zhang.github.io/series/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/" rel="self" type="application/rss+xml" /><item>
    <title>Okhttp的链接池</title>
    <link>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</link>
    <pubDate>Fri, 29 Oct 2021 10:43:41 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>OkHttp的缓存机制</title>
    <link>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
    <pubDate>Sat, 18 Sep 2021 18:21:35 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>DiskLruCache</title>
    <link>https://vee-zhang.github.io/disklrucache/</link>
    <pubDate>Thu, 16 Sep 2021 10:05:42 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/disklrucache/</guid>
    <description><![CDATA[<p>之前已经了解过，OkHttp默认添加CacheInterceptor来处理缓存，而后者是依靠<code>DiskLruCache</code>来实现硬盘缓存读写，所以我先去看了一下Android内置的<code>LruCache</code>原理，是依靠java的<code>LinkedHashMap</code>的LRU排序算法实现的，最后我准备详细看看<code>DiskLruCache</code>是怎么基于硬盘缓存实现LRU的。</p>]]></description>
</item><item>
    <title>BridgeInterceptor</title>
    <link>https://vee-zhang.github.io/bridgeinterceptor/</link>
    <pubDate>Tue, 07 Sep 2021 17:45:01 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/bridgeinterceptor/</guid>
    <description><![CDATA[RealCall中的传值 1 2 3 ... interceptors.add(new BridgeInterceptor(client.cookieJar())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Bridges from application code to]]></description>
</item><item>
    <title>CacheInterceptor</title>
    <link>https://vee-zhang.github.io/cacheinterceptor/</link>
    <pubDate>Tue, 07 Sep 2021 17:45:01 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/cacheinterceptor/</guid>
    <description><![CDATA[RealCall中的传值 1 2 3 ... interceptors.add(new CacheInterceptor(client.internalCache())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 作用 这个类的注释如下： Serves requests from the cache]]></description>
</item><item>
    <title>CallServerInterceptor</title>
    <link>https://vee-zhang.github.io/callserverinterceptor/</link>
    <pubDate>Tue, 07 Sep 2021 17:45:01 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/callserverinterceptor/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>ConnectInterceptor与StreamAllocation</title>
    <link>https://vee-zhang.github.io/connectinterceptor/</link>
    <pubDate>Tue, 07 Sep 2021 17:45:01 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/connectinterceptor/</guid>
    <description><![CDATA[ConnectInterceptor 连接拦截器 作为第二个实际生效的拦截器，ConnectInterceptor 的代码非常简单。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24]]></description>
</item><item>
    <title>RetryAndFollowUpInterceptor</title>
    <link>https://vee-zhang.github.io/retryandfollowupinterceptor/</link>
    <pubDate>Tue, 07 Sep 2021 17:45:01 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/retryandfollowupinterceptor/</guid>
    <description><![CDATA[RealCall中的传值 1 2 3 4 5 6 private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } RealCall初始化时，会创建这个RetryAndFol]]></description>
</item><item>
    <title>StreamAllocation</title>
    <link>https://vee-zhang.github.io/streamallocation/</link>
    <pubDate>Tue, 07 Sep 2021 17:45:01 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/streamallocation/</guid>
    <description><![CDATA[初始化调用 1 2 3 4 5 6 7 8 9 10 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在Re]]></description>
</item><item>
    <title>OkHttp3解读</title>
    <link>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link>
    <pubDate>Tue, 07 Sep 2021 09:49:28 &#43;0800</pubDate><author>
        <name>Vee Zhang</name>
    </author><guid>https://vee-zhang.github.io/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid>
    <description><![CDATA[<p>回顾并且深入一下OkHttp（v3.10.0）的原理。</p>]]></description>
</item></channel>
</rss>
