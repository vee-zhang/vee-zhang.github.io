<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>JVM内存结构 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>JVM内存结构</h1><time datetime=2021-07-06T16:57:01Z class=post-date>Tue, Jul 6, 2021</time><h2 id=jdkjvmjre之间的关系>JDK、JVM、Jre之间的关系</h2><ul><li>JVM 只负责把.class文件翻译成操作系统可识别的语句。</li><li>Jre 提供Java程序的运行环境</li><li>JDK 提供工具</li></ul><h2 id=jvm的三大区域>JVM的三大区域</h2><ul><li>Java类加载器ClassLoader</li><li>运行时数据区（JVM内存）</li><li>执行引擎</li></ul><p><strong>注意： JVM是边解释边执行的</strong>。</p><h2 id=运行时数据区>运行时数据区</h2><p>定义：Jre在执行Java程序的过程中会把他所管理的内存划分成若干个不同的数据区域。包括：
- 程序计数器
- 虚拟机栈
- 本地方法栈 用来保存native方法的信息
- Java堆
- 方法区（运行时常量池）
- 直接内存（也叫堆外内存，用于nio）</p><h3 id=线程私有>线程私有</h3><ul><li>虚拟机栈（A函数调用B函数，B函数会先入栈，此时B函数位于栈顶，被执行。执行完B出栈，使A回到栈顶，A继续执）</li><li>本地方法栈</li><li>程序计数器</li></ul><h3 id=线程共享>线程共享</h3><ul><li>方法区</li><li>堆</li></ul><h2 id=程序计数器>程序计数器</h2><p>程序计数器是一个很小的内存区域，指向当前线程正在执行的指令对应的字节码<strong>地址（指针）</strong>。</p><p>为什么需要程序计数器？</p><p>CPU时间片轮转回来的时候，通过程序计数器才直到程序执行到了哪里，以及从哪继续执行。</p><p>JVM的内存区域中，程序计数器是<strong>唯一不会OOM的储存区</strong>。</p><h2 id=虚拟机栈>虚拟机栈</h2><p>栈：FILA，后进先出。</p><p>虚拟机栈用来存储当前线程运行方法所需的数据、指令、返回地址等。</p><h3 id=栈帧>栈帧</h3><ul><li>局部变量表:用来存储局部变量（结构体和引用）</li><li>操作数栈:存放函数的执行。</li><li>动态连接: 用于多态</li><li>完成出口（返回地址）:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当以上函数进入虚拟机栈时，就成为了一个栈帧，他内部做了两件事：</p><ol><li>首先函数中有个创建变量i的操作，入栈到操作数栈；</li><li>将操作数栈的栈顶操作生成的数据（i）存入局部变量表下标为[1]的位置（局部变量表下标[0]位置是this，代表实例自己）。</li></ol><p><strong>Java的解释执行是基于操作数栈，所以移植性和兼容性好，而C语言是基于寄存器（硬件）运算，所以速度快。</strong></p><h3 id=虚拟机栈的大小--xss>虚拟机栈的大小 -Xss</h3><h2 id=本地方法栈>本地方法栈</h2><p>用来保存native方法的信息。比如hashCode()方法等加了native关键字的方法。</p><p>本地方法栈中存放的其实是C函数的链接，由于不是java方法，所以程序计数器不会计数。</p><h2 id=方法区>方法区</h2><p>用来存放：</p><ul><li>类信息</li><li>常量</li><li>静态变量</li><li>即时编译后的代码</li></ul><h2 id=java堆>Java堆</h2><p>用来存放：</p><ul><li>对象</li><li>数组</li></ul><p>参数：</p><ul><li>Xmx 堆区内存可被分配的最大上限</li><li>Xms 堆内存初始内存分配的大小</li></ul><h2 id=问题为何要分成方法区和堆>问题，为何要分成方法区和堆</h2><p>堆位于新生代和老年代，回收频繁；而方法区位于永生代（1.8叫元空间，使用的是物理内存，提升了容量），回收不频繁。这是一种<strong>动静分离</strong>的思想，有利于回收的高效。</p><h2 id=怎么可视化查看内存>怎么可视化查看内存</h2><ul><li>AS的profile</li><li>JDK9的HSDB</li></ul><h2 id=内存溢出>内存溢出</h2><p>常见的内存溢出有以下三种：</p><ul><li>java.lang.OutOfMemoryError: Java heap space &mdash;&mdash;>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</li><li>java.lang.OutOfMemoryError: PermGen space &mdash;&mdash;>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</li><li>java.lang.StackOverflowError &mdash;&mdash;> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</li></ul><h2 id=遗留问题>遗留问题</h2><p>1.JVM 有哪些内存区域？（JVM 的内存布局是什么？）
2.StackOverFlow与OOM的区别？分别发生在什么时候，JVM栈中存储的是什么？堆中存储是什么？</p><blockquote><p>今天状态不好，学的云里雾里，时间不够快下班了，也懒得总结了，留到后面再说吧。</p></blockquote></div></main></body></html>