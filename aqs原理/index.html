<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>从ReentrantLock看AQS原理 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/aqs%E5%8E%9F%E7%90%86/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>从ReentrantLock看AQS原理</h1><time datetime=2021-05-13T15:33:07Z class=post-date>Thu, May 13, 2021</time><h2 id=reentrantlock的使用>ReentrantLock的使用</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ReentrantLock</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ReentrantLock</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=aqs原理概述>AQS原理概述</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>volatile</span> <span class=kt>int</span> <span class=n>state</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><p>维护了一个<code>int state</code>作为状态机，CLH队列<code>Node</code>暂存阻塞的线程，通过判断状态以及CAS变更状态机，遵循<strong>FIFO</strong>方式从队列中拿出线程运行。</p><h2 id=java中内置的实现>java中内置的实现：</h2><ul><li>ReentrantLock(可重入锁)</li><li>Semaphore（信号量）</li><li>CountDownLatch（计数锁，这个是老朋友了）</li><li>ReentrantReadWriteLock可重入读写锁</li><li>SynchronousQueue</li><li>FutureTask</li><li>ThreadPoolExecutor中的work</li></ul><h2 id=aqs锁分类>AQS锁分类</h2><ul><li>独占锁：也叫排他锁，即<strong>锁只能由一个线程获取</strong>，若一个线程获取了锁，则<strong>其他想要获取锁的线程只能等待，直到锁被释放</strong>。eg:写锁；</li><li>共享锁：<strong>锁可以由多个线程同时获取，锁被获取一次，则锁的计数器+1</strong>。eg:读锁；</li></ul><h2 id=核心方法>核心方法</h2><h3 id=抽象方法>抽象方法：</h3><ul><li><code>tryAcquire</code> 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态。</li><li><code>tryRelease</code> 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态；</li><li><code>tryAcquireShared</code> 共享式获取同步状态，返回>=0的值，表示获取成功，反之获取失败</li><li><code>tryReleaseShared</code> 共享式释放同步状态</li><li><code>isHeldExclusively</code> 当前同步器是否再独占模式下被线程占用，一般该方法表示是否被当前线程所独占</li></ul><blockquote><p>记忆方法：只记<code>Acquire</code>和<code>release</code>，前面加shared就是共享，没有就是独占。</p></blockquote><h3 id=模板方法>模板方法：</h3><ul><li><code>acquire</code> 独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的<code>tryAcquire(int arg)</code>方法。</li><li><code>acquireInterruptibly</code> 与上面方法作用相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回</li><li><code>tryAcquireNanos(int arg,Long nanos)</code> 在上个方法基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false，如果获取到了返回true</li><li><code>acquireShared(int arg)</code> 共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同意时刻可以有多个线程获取到同步状态</li><li><code>acquireSharedInterruptibly(int arg)</code> 与上个方法相同，但是会响应中断</li><li><code>tryAcquireSharedNanos</code> 在上个方法基础上怎加了超时机制</li><li><code>release（int arg)</code> 独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒</li><li><code>releaseShared(int arg)</code> 共享式释放同步状态</li></ul><h2 id=同步队列clh>同步队列CLH</h2><p>同步队列是一个遵循FIFO（first in first out）原则的双向链表。双向链包含前驱节点和后继节点。通常用于自旋同步场景。</p><p>入队时需要创建一个新的节点拼接到队尾，而出队时只需要把队首置空就行了。</p><h3 id=aqs中的同步队列>AQS中的同步队列</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>abstract</span> <span class=kd>class</span> <span class=nc>AbstractQueuedSynchronizer</span>
</span></span><span class=line><span class=cl>    <span class=kd>extends</span> <span class=n>AbstractOwnableSynchronizer</span>
</span></span><span class=line><span class=cl>    <span class=kd>implements</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//队首引用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=kd>transient</span> <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//队尾引用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=kd>transient</span> <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>Node</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 表示线程取消申请锁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CANCELLED</span> <span class=o>=</span>  <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=c1>// 表示线程正在申请锁，等待被分配
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SIGNAL</span>    <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 表示线程在等待某些条件达成，再进入下一阶段
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CONDITION</span> <span class=o>=</span> <span class=o>-</span><span class=mi>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 表示把对当前节点进行的操作，继续往队列传播下去
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>PROPAGATE</span> <span class=o>=</span> <span class=o>-</span><span class=mi>3</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 表示当前线程的状态，有五种
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>volatile</span> <span class=kt>int</span> <span class=n>waitStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 双向链之一：前驱节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 双向链之一：后继节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 节点代表的线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>volatile</span> <span class=n>Thread</span> <span class=n>thread</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 条件队列——单向链，链接下一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>nextWaiter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=/images/CLH1.jpg alt></p><p>AQS通过这个同步队列来维护当前获取锁失败处于阻塞状态的线程。</p><p>在这个队列中，每一个node对应一个线程，当一个线程获取锁失败，会被加入到队尾。只有链首是处于运行状态的线程，其他都在阻塞中。当队首的线程释放锁时，会唤醒下一个node，而下一个node中的线程会尝试获取锁。如果成功，则将上一个node移除，使自己至于链首。</p><h3 id=node的五种状态>Node的五种状态</h3><ul><li>0：新结点入队时的默认状态；</li><li>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将当前结点的状态更新为SIGNAL。</li><li>CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li>PROPAGATE(-3)：共享模式下，前驱结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li></ul><h3 id=node的双向链结构>Node的双向链结构</h3><p>以Node的结构来看，prev 和 next 属性将可以支持AQS可以将请求锁的线程构成双向队列，而入队列出队列，以及先入先出的特性，需要方法来支持。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>transient</span> <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>transient</span> <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Node</span> <span class=nf>enq</span><span class=o>(</span><span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>            <span class=c1>// 进入到这里，说明没有head节点，CAS操作创建一个head节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetHead</span><span class=o>(</span><span class=k>new</span> <span class=n>Node</span><span class=o>()))</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 如果这里失败，说明发生了并发，会再次循环并走到下面的else
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>tail</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 把Node加入到尾部，保证加入到为止，并发会重走
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetTail</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>t</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>AQS中，以head为CLH队列头部，以tail为CLH队列尾部，当加入节点时，通过CAS和自旋保证节点正确入队（加入队尾）。</p><h2 id=reentrantlock原理>ReentrantLock原理</h2><h3 id=构造方法>构造方法</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//无参构造方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>ReentrantLock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sync</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NonfairSync</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//有参构造方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>ReentrantLock</span><span class=o>(</span><span class=kt>boolean</span> <span class=n>fair</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sync</span> <span class=o>=</span> <span class=n>fair</span> <span class=o>?</span> <span class=k>new</span> <span class=n>FairSync</span><span class=o>()</span> <span class=o>:</span> <span class=k>new</span> <span class=n>NonfairSync</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>构造方法中只是初始化了一个<code>Sync</code>，这就是个AQS：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>abstract</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Sync</span> <span class=kd>extends</span> <span class=n>AbstractQueuedSynchronizer</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>serialVersionUID</span> <span class=o>=</span> <span class=o>-</span><span class=mi>5179523762034025860L</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><p>那么构造方法的作用就是初始化<code>Sync</code>这个AQS，但是根据参数，有两种实现方式：</p><ul><li>FairSync公平锁：也叫独占锁，多个线程按照申请锁的顺序去获得锁，后申请锁的线程需要排队，等它之前的线程获得锁并释放后，它才能获得锁；</li><li>NonfairSync非公平锁：线程获得锁的顺序于申请锁的顺序无关，申请锁的线程可以直接尝试获得锁，谁抢到就是谁的。</li></ul><h3 id=lock>lock()</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//注意这里传递了1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kt>void</span> <span class=nf>lock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sync</span><span class=o>.</span><span class=na>acquire</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>注意，lock时固定传了整数<code>1</code>。</strong></p><p>加锁，就是调用了AQS的<code>acquire(int arg)</code>方法。内部实现是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl> <span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>acquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(!</span><span class=n>tryAcquire</span><span class=o>(</span><span class=n>arg</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=n>acquireQueued</span><span class=o>(</span><span class=n>addWaiter</span><span class=o>(</span><span class=n>Node</span><span class=o>.</span><span class=na>EXCLUSIVE</span><span class=o>),</span> <span class=n>arg</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>//中断当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>selfInterrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><code>tryAcquire(arg)</code>尝试获取锁；</li><li>如果拿不到，则<code>addWaiter(Node.EXCLUSIVE)</code>创建一个等待节点；</li><li>然后<code>acquireQueued(waiter)</code>添加进等待队列；</li><li>最后中断。</li></ol><h4 id=tryaxquireint-arg尝试获取锁>tryAxquire(int arg)尝试获取锁</h4><p>这个方法的作用是<strong>尝试获取锁，返回Boolean表示是否成功获取锁</strong>，这是个抽象方法，他在公平锁和非公平锁的实现有差别。</p><blockquote><p>当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。</p></blockquote><h5 id=公平锁>公平锁</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>FairSync</span> <span class=kd>extends</span> <span class=n>Sync</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>serialVersionUID</span> <span class=o>=</span> <span class=o>-</span><span class=mi>3000897897090466540L</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//尝试获取锁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nd>@ReservedStackAccess</span>
</span></span><span class=line><span class=cl>        <span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>tryAcquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>acquires</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//拿到当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>final</span> <span class=n>Thread</span> <span class=n>current</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=c1>//拿到AQS的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//如果AQS是初始化状态
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(!</span><span class=n>hasQueuedPredecessors</span><span class=o>()</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>compareAndSetState</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>acquires</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=c1>//如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=n>current</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>current</span> <span class=o>==</span> <span class=n>getExclusiveOwnerThread</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//如果当前线程就是独占线程
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kt>int</span> <span class=n>nextc</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>acquires</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>nextc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>throw</span> <span class=k>new</span> <span class=n>Error</span><span class=o>(</span><span class=s>&#34;Maximum lock count exceeded&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=c1>//就重置AQS状态计数
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>setState</span><span class=o>(</span><span class=n>nextc</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//查询是否有线程正在等待
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>hasQueuedPredecessors</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=n>h</span><span class=o>,</span> <span class=n>s</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>((</span><span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//如果head不为空，
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>((</span><span class=n>s</span> <span class=o>=</span> <span class=n>h</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>s</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//如果head的next不为空，或者head处于等待状态
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>s</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> 
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=o>(</span><span class=n>Node</span> <span class=n>p</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span> <span class=n>p</span> <span class=o>!=</span> <span class=n>h</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>prev</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//从队尾遍历到队首
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//找到最早开始等待的node
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=n>s</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>s</span><span class=o>.</span><span class=na>thread</span> <span class=o>!=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=c1>//最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在<code>tryAcquire</code>方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。</p><p>然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。</p><p>如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了<strong>可重入锁</strong>的特点。</p><p>那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。</p><p><code>hasQueuedPredecessors</code>方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。</p><p>总结一下可重入锁的原理：</p><ol><li>通过CAS改变state并且判断state状态，避免锁竞争；</li><li>已经持有锁的线程可免除CAS再次获取锁。</li></ol><p>再总结一下公平锁的原理：<strong>判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。</strong></p><h5 id=非公平锁>非公平锁</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>NonfairSync</span> <span class=kd>extends</span> <span class=n>Sync</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>serialVersionUID</span> <span class=o>=</span> <span class=mi>7316153563782823691L</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>tryAcquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>acquires</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//调用父类的方法
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=n>nonfairTryAcquire</span><span class=o>(</span><span class=n>acquires</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>nonfairTryAcquire方法位于父类<code>Sync</code>中，那么这里也体现了模板方法模式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>nonfairTryAcquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>acquires</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//拿到当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>final</span> <span class=n>Thread</span> <span class=n>current</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//拿到AQS中的state
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果是初始状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetState</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>acquires</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=n>current</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>current</span> <span class=o>==</span> <span class=n>getExclusiveOwnerThread</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>nextc</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>acquires</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>nextc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=c1>// overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>throw</span> <span class=k>new</span> <span class=n>Error</span><span class=o>(</span><span class=s>&#34;Maximum lock count exceeded&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>setState</span><span class=o>(</span><span class=n>nextc</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当<strong>新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。</strong></p><h5 id=reentrantlock的公平与非公平锁都是可重入的>ReentrantLock的公平与非公平锁都是可重入的</h5><h5 id=公平与非公平锁的区别>公平与非公平锁的区别</h5><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li><li>缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><h4 id=addwaiter>addWaiter()</h4><p><img src=/images/CLH2.jpg alt></p><p>我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。</p><p><a href=https://www.jianshu.com/p/6fc0601ffe34>摘自：https://www.jianshu.com/p/6fc0601ffe34</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//空占位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=n>Node</span> <span class=n>EXCLUSIVE</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> *  把当前线程封装成node置于队尾
</span></span></span><span class=line><span class=cl><span class=cm> * @param mode固定是null
</span></span></span><span class=line><span class=cl><span class=cm> **/</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Node</span> <span class=nf>addWaiter</span><span class=o>(</span><span class=n>Node</span> <span class=n>mode</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//创建一个持有当前线程的node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>(),</span> <span class=n>mode</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>pred</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>pred</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果tail存在，就把新node置于队尾
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>pred</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//变更tail为新创建的node
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetTail</span><span class=o>(</span><span class=n>pred</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pred</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>enq</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//通过设置头尾节点，建立新的队列顺序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=n>Node</span> <span class=nf>enq</span><span class=o>(</span><span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//拿到缓存的tail
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>            <span class=c1>//如果没有缓存就初始化head和tail
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetHead</span><span class=o>(</span><span class=k>new</span> <span class=n>Node</span><span class=o>()))</span>
</span></span><span class=line><span class=cl>                <span class=n>tail</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//如果已经缓存，
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetTail</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>t</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>addWaiter</code>方法的作用是<strong>将当前线程封装成同步队列的节点，然后CAS快速入队</strong>，并返回此节点。</p><ol><li>把线程封装成Node；</li><li>新Node入队。</li></ol><p>那么CAS入队失败，就需要调用<code>enq(Node node)</code>方法自旋入队。</p><p>这里就是一个性能策略，尽量的去避免自旋消耗cpu。</p><h4 id=acquirequeued>acquireQueued</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>*   用来阻塞node持有的线程，当其他线程释放锁的时* 候，才会唤醒
</span></span></span><span class=line><span class=cl><span class=cm>* @param node 新添加到队尾的node
</span></span></span><span class=line><span class=cl><span class=cm>* @param arg 写死为1
</span></span></span><span class=line><span class=cl><span class=cm>**/</span>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>acquireQueued</span><span class=o>(</span><span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span><span class=o>,</span> <span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=n>interrupted</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//拿到当前node的上一节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>final</span> <span class=n>Node</span> <span class=n>p</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>predecessor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=c1>//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=o>==</span> <span class=n>head</span> <span class=o>&amp;&amp;</span> <span class=n>tryAcquire</span><span class=o>(</span><span class=n>arg</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//获取锁成功，就把当前node置为head
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>setHead</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=c1>//打断链条，GC回收上一节点
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// help GC
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>return</span> <span class=n>interrupted</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>shouldParkAfterFailedAcquire</span><span class=o>(</span><span class=n>p</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                <span class=c1>//阻塞线程，并检测线程是否被中断
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>interrupted</span> <span class=o>|=</span> <span class=n>parkAndCheckInterrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Throwable</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//重置各种状态，并唤醒被阻塞的线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>cancelAcquire</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>interrupted</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>//中断线程
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>selfInterrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//阻塞线程，并检测线程是否被中断
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>parkAndCheckInterrupt</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//阻塞线程，不会释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LockSupport</span><span class=o>.</span><span class=na>park</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Thread</span><span class=o>.</span><span class=na>interrupted</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>最后AQS阻塞线程的秘密终于揭开了，在<code>acquireQueued(final Node node, int arg)</code>方法中，AQS通过调用<code>LockSupport.park(this)</code>来阻塞线程。通过搜索<code>LockSupport.unpark(this)</code>方法，发现在<code>release(int arg)</code>时会让下一个节点node唤醒。</p><h3 id=unlock>unlock()</h3><p>同步队列（CLH）遵循FIFO，首节点是获取同步状态的节点，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单。如下图：</p><p><img src=/images/CLH3.jpg alt></p><p>设置首节点是通过获取锁成功的线程来完成的（获取同步状态是通过CAS来完成），只能有一个线程能够获取到锁，因此设置头节点的操作并不需要CAS来保证，只需要将首节点设置为其原首节点的后继节点并断开原首节点的next（等待GC回收）即可。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>unlock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sync</span><span class=o>.</span><span class=na>release</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>release</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//尝试释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>tryRelease</span><span class=o>(</span><span class=n>arg</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>h</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>unparkSuccessor</span><span class=o>(</span><span class=n>h</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//尝试释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nd>@ReservedStackAccess</span>
</span></span><span class=line><span class=cl><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>tryRelease</span><span class=o>(</span><span class=kt>int</span> <span class=n>releases</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//检查状态机，是否可释放
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>()</span> <span class=o>-</span> <span class=n>releases</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>()</span> <span class=o>!=</span> <span class=n>getExclusiveOwnerThread</span><span class=o>())</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果当前线程不是独占线程，则抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalMonitorStateException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//改标记位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>boolean</span> <span class=n>free</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//释放独占线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//变更状态机
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setState</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>free</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//唤醒下一个线程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kt>void</span> <span class=nf>unparkSuccessor</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ws</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>waitStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>ws</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>//重置node的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>node</span><span class=o>.</span><span class=na>compareAndSetWaitStatus</span><span class=o>(</span><span class=n>ws</span><span class=o>,</span> <span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>s</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>s</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=n>Node</span> <span class=n>p</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span> <span class=n>p</span> <span class=o>!=</span> <span class=n>node</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>prev</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>s</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//如果存在next，唤醒下个node线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>LockSupport</span><span class=o>.</span><span class=na>unpark</span><span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>thread</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其实我觉得这里就没必要细看了，细看也记不住。</p><p><code>unlock()</code>方法主要是通过AQS的<code>release(int arg)</code>实现的，内部机制无非就是重置状态机，释放独占线程，并且唤醒下一个线程。而唤醒线程的方式也必然是<code>LockSupport.unpark(s.thread)</code>。</p><h3 id=共享锁的申请>共享锁的申请</h3><p>先回顾一下独占锁的申请：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>acquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(!</span><span class=n>tryAcquire</span><span class=o>(</span><span class=n>arg</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=n>acquireQueued</span><span class=o>(</span><span class=n>addWaiter</span><span class=o>(</span><span class=n>Node</span><span class=o>.</span><span class=na>EXCLUSIVE</span><span class=o>),</span> <span class=n>arg</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>//中断当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>selfInterrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>线程申请独占锁失败会通过<code>acquireQueued</code>进入队列等待。</p><p>共享锁的申请则要简单的多：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>acquireShared</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//调用抽象方法tryAcquireShared，可以看到返回了一个计数，如果计数大于0就表示成功拿到锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>tryAcquireShared</span><span class=o>(</span><span class=n>arg</span><span class=o>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果返回小于0会调用doAcquireShared
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>doAcquireShared</span><span class=o>(</span><span class=n>arg</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=n>Node</span> <span class=n>SHARED</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>doAcquireShared</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//同样调用了addWaiter，但是传递的不是null而是一个空Node（），这样就保证Node.SHARED一直是[当前]节点的后继节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=n>addWaiter</span><span class=o>(</span><span class=n>Node</span><span class=o>.</span><span class=na>SHARED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=n>failed</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>interrupted</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//拿到上一节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>final</span> <span class=n>Node</span> <span class=n>p</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>predecessor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=o>==</span> <span class=n>head</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//如果上个节点是head
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>                <span class=c1>//再次尝试申请锁
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>tryAcquireShared</span><span class=o>(</span><span class=n>arg</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//如果拿到锁就释放head
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>setHeadAndPropagate</span><span class=o>(</span><span class=n>node</span><span class=o>,</span> <span class=n>r</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// help GC
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>interrupted</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>selfInterrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>failed</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>shouldParkAfterFailedAcquire</span><span class=o>(</span><span class=n>p</span><span class=o>,</span> <span class=n>node</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=n>parkAndCheckInterrupt</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=c1>//阻塞线程，并检测线程是否被中断
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>interrupted</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>failed</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cancelAcquire</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>先调用<code>addWaiter()</code>向队尾添加一个空的node并包装当前的thread，然后给这个空的节点增加后继节点<code>Node.SHARED</code>。再进入自旋，从当前节点向上遍历，如果当前节点的前驱节点是head，就尝试申请锁，申请成功就释放head，并把自己置于队首。其他位置的线程会判断状态是否应该被阻塞，然后再进入阻塞状态。</p><p>我们看到，<strong>共享锁全程没有判断当前线程是否独占线程</strong>，只要调用<code>tryAcquireShared()</code>方法不返回负数，就能成功申请到锁，而且同一时间可以多个线程并发拿到锁。</p><h2 id=自定义一个最简单的重入锁>自定义一个最简单的重入锁</h2><p>上面终于把源码巴拉完了，但是整个流程记不住。记不住怎么办？想办法，所以我决定自己实现一个最简单的可重入非公平锁：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 我自己实现的非公平锁
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyLock</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Sync</span> <span class=n>sync</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>MyLock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>sync</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Sync</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>lock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sync</span><span class=o>.</span><span class=na>acquire</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>unlock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sync</span><span class=o>.</span><span class=na>release</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * AQS实现类
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>class</span> <span class=nc>Sync</span> <span class=kd>extends</span> <span class=n>AbstractQueuedSynchronizer</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>         * 重写tryAcquire
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryAcquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>acquires</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//拿到当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>final</span> <span class=n>Thread</span> <span class=n>current</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=c1>//拿到AQS的状态机
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=c1>//判断状态机如果是初始状态
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//CAS由0到1
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetState</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>acquires</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//当前线程设置为独占线程
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=n>current</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>current</span> <span class=o>==</span> <span class=n>getExclusiveOwnerThread</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//如果当前线程已经是独占线程，改变AQS状态
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kt>int</span> <span class=n>nextc</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>acquires</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=n>setState</span><span class=o>(</span><span class=n>nextc</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>         * 重写tryRelease
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryRelease</span><span class=o>(</span><span class=kt>int</span> <span class=n>release</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>()</span> <span class=o>-</span> <span class=n>release</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>boolean</span> <span class=n>free</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>free</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=c1>//释放独占线程
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>//改变状态机
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>setState</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>free</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>从这里看出，利用AQS实现一个锁的流程：</p><ol><li>继承AQS；</li><li>重写<code>tryAcquire</code>，当前线程置为独占线程，<code>setState()</code>变更状态；</li><li>重写<code>tryRelease(int release)</code>，释放独占线程，<code>setState()</code>变更状态。</li></ol><p>然后激动的试了一下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>int</span> <span class=n>num</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>MyLock</span> <span class=n>myLock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MyLock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>            <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>concat</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>            <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>concat</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>t1</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;t1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;t2&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>t1</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>concat</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>myLock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>Thread</span><span class=o>.</span><span class=na>sleep</span><span class=o>(</span><span class=mi>3000</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>num</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;线程&#34;</span> <span class=o>+</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;把num改为&#34;</span> <span class=o>+</span> <span class=n>num</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// TODO Auto-generated catch block
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>myLock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>最后惴惴不安的看了下结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>6</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>9</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t1</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>11</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>12</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>13</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>14</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>15</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>16</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>17</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>18</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>19</span>
</span></span><span class=line><span class=cl><span class=err>线程</span><span class=n>t2</span><span class=err>把</span><span class=n>num</span><span class=err>改为</span><span class=mi>20</span>
</span></span></code></pre></td></tr></table></div></div><p>没问题，i did it !</p><h2 id=aqs的条件队列>AQS的条件队列</h2><h3 id=条件队列的使用vsobject监视器方法>条件队列的使用VSObject监视器方法</h3><h4 id=对象监视器锁使用>对象监视器锁使用</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>App</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一把锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Object</span> <span class=n>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>            <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//上锁
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kd>synchronized</span> <span class=o>(</span><span class=n>obj</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;开始等待&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=c1>//阻塞等待
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=n>obj</span><span class=o>.</span><span class=na>wait</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;已被唤醒&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;t1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>            <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//上锁
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kd>synchronized</span> <span class=o>(</span><span class=n>obj</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;已开始执行，3秒后将唤醒t1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=n>sleep</span><span class=o>(</span><span class=mi>3000</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                        <span class=c1>//唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=n>obj</span><span class=o>.</span><span class=na>notify</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;t2&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>t1</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>用法解析：</p><ul><li>阻塞<code>wait</code>和唤醒<code>notify</code>都必须在持有锁的前提下调用，否则会报异常；</li><li>通过<code>wait()</code>阻塞线程；</li><li>通过<code>notify()</code>唤醒线程；</li><li>阻塞<code>wait</code>之后不会再执行任何代码，所以<code>notify</code>不应该在<code>await</code>之后。</li></ul><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>t1</span><span class=err>开始等待</span>
</span></span><span class=line><span class=cl><span class=n>t2</span><span class=err>已开始执行，</span><span class=mi>3</span><span class=err>秒后将唤醒</span><span class=n>t1</span>
</span></span><span class=line><span class=cl><span class=n>t1</span><span class=err>已被唤醒</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=条件锁使用>条件锁使用</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.locks.Condition</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.locks.ReentrantLock</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>App2</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个独占锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>ReentrantLock</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ReentrantLock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 用独占锁创建Condition
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Condition</span> <span class=n>condition</span> <span class=o>=</span> <span class=n>lock</span><span class=o>.</span><span class=na>newCondition</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;开始等待&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>condition</span><span class=o>.</span><span class=na>await</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;已被唤醒&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>};</span>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;t1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;已开始执行，3秒后将唤醒t1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>sleep</span><span class=o>(</span><span class=mi>3000</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>condition</span><span class=o>.</span><span class=na>signal</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>};</span>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;t2&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>t1</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>用法解析：</p><ul><li>不论阻塞还是环境，都需要通过<code>lock.lock()</code>获取锁，否则或报监视器异常；</li><li>使用<code>await()</code>方法阻塞线程；</li><li>使用<code>signal()</code>方法唤醒线程；</li><li><code>await()</code>阻塞之后不会执行任何代码，直到被唤醒。</li></ul><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>t1</span><span class=err>开始等待</span>
</span></span><span class=line><span class=cl><span class=n>t2</span><span class=err>已开始执行，</span><span class=mi>3</span><span class=err>秒后将唤醒</span><span class=n>t1</span>
</span></span><span class=line><span class=cl><span class=n>t1</span><span class=err>已被唤醒</span>
</span></span></code></pre></td></tr></table></div></div><p>从上面的对比可以看出，条件锁与对象监视器锁的用法几乎一样：</p><table><thead><tr><th>Object</th><th>Condition</th><th>作用</th></tr></thead><tbody><tr><td><code>wait()</code></td><td><code>await()</code></td><td>阻塞线程</td></tr><tr><td><code>notify()</code></td><td><code>signal()</code></td><td>唤醒线程</td></tr><tr><td><code>notifyAll()</code></td><td><code>signalAll()</code></td><td>唤醒全部线程</td></tr></tbody></table><p>但是<code>Condition</code>在使用起来<strong>更加灵活，且在同一把锁中支持多个条件</strong>，所以应该优先使用。</p><h3 id=reentrantlock-vs-synchronized>ReentrantLock VS synchronized</h3><table><thead><tr><th>区别</th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>来源</td><td>jvm</td><td>JUC包</td></tr><tr><td>原理</td><td>对象监视器</td><td>AQS队列+CAS+valatile</td></tr><tr><td>易用</td><td>强</td><td>弱</td></tr><tr><td>释放</td><td>自动</td><td>手动unlock</td></tr><tr><td>位置</td><td>对象、方法、类、代码块</td><td>只有代码块</td></tr><tr><td>可中断</td><td>不</td><td>可</td></tr><tr><td>公平锁</td><td>不支持</td><td>支持</td></tr><tr><td>精确唤醒</td><td>不支持</td><td>支持</td></tr><tr><td>多条件</td><td>不支持</td><td>支持</td></tr><tr><td>结果</td><td>只能一直阻塞</td><td>可返回结果</td></tr><tr><td>超时</td><td>不支持</td><td>支持</td></tr></tbody></table><h3 id=条件队列原理>条件队列原理</h3><h4 id=newcondition><code>newCondition()</code></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=n>ConditionObject</span> <span class=nf>newCondition</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=n>ConditionObject</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>很简单，就是构建了一个<code>ConditionObject</code>对象，他是<code>Condition</code>的实现类。</p><h4 id=await阻塞方法><code>await()</code>阻塞方法</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>await</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//当前线程的中断检查，会重置中断状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>interrupted</span><span class=o>())</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>InterruptedException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=n>addConditionWaiter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//释放之前获取到的锁资源，因为后续会阻塞该线程，所以如果不释放的话，其他线程将会等待该线程被唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>savedState</span> <span class=o>=</span> <span class=n>fullyRelease</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>interruptMode</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//isOnSyncQueue方法会遍历CLH队列寻找当前node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=o>(!</span><span class=n>isOnSyncQueue</span><span class=o>(</span><span class=n>node</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果当前节点不在CLH队列中则阻塞住，等待unpark唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//阻塞当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LockSupport</span><span class=o>.</span><span class=na>park</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//中断检测
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>((</span><span class=n>interruptMode</span> <span class=o>=</span> <span class=n>checkInterruptWhileWaiting</span><span class=o>(</span><span class=n>node</span><span class=o>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//唤醒后，会再次调用acquireQueued来阻塞，并且会不断的tryAcquire队首，让队首尝试获取锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>acquireQueued</span><span class=o>(</span><span class=n>node</span><span class=o>,</span> <span class=n>savedState</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>interruptMode</span> <span class=o>!=</span> <span class=n>THROW_IE</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>interruptMode</span> <span class=o>=</span> <span class=n>REINTERRUPT</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>nextWaiter</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=c1>// clean up if cancelled
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>unlinkCancelledWaiters</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>interruptMode</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>reportInterruptAfterWait</span><span class=o>(</span><span class=n>interruptMode</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//把当前线程包装成一个新的node，并且设置成等待条件状态，加入条件队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=n>Node</span> <span class=nf>addConditionWaiter</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>lastWaiter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If lastWaiter is cancelled, clean out.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>t</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>!=</span> <span class=n>Node</span><span class=o>.</span><span class=na>CONDITION</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>unlinkCancelledWaiters</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>lastWaiter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//当前线程包装成一个新node，状态为：等待条件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>(),</span> <span class=n>Node</span><span class=o>.</span><span class=na>CONDITION</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>firstWaiter</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=c1>//node的nextWaiter是一条单向链，这里是把新的节点加入条件队列中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>t</span><span class=o>.</span><span class=na>nextWaiter</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lastWaiter</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//清除条件队列中已不是等待条件状态的节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kt>void</span> <span class=nf>unlinkCancelledWaiters</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>firstWaiter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>trail</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=o>(</span><span class=n>t</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=n>next</span> <span class=o>=</span> <span class=n>t</span><span class=o>.</span><span class=na>nextWaiter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>!=</span> <span class=n>Node</span><span class=o>.</span><span class=na>CONDITION</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//释放队列中所有状态不是条件的节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>t</span><span class=o>.</span><span class=na>nextWaiter</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>trail</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>firstWaiter</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>trail</span><span class=o>.</span><span class=na>nextWaiter</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>lastWaiter</span> <span class=o>=</span> <span class=n>trail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>trail</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>isOnSyncQueue</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果node是condition状态或者没有前驱节点返回false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>==</span> <span class=n>Node</span><span class=o>.</span><span class=na>CONDITION</span> <span class=o>||</span> <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果存在下一个节点，返回true，会终止自旋
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>next</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=c1>// If has successor, it must be on queue
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>findNodeFromTail</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//判断当前节点是否存在于CLH队列中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>findNodeFromTail</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=n>node</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>t</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=signal唤醒方法><code>signal()</code>唤醒方法</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>signal</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//如果当前线程不是独占线程，就会抛异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(!</span><span class=n>isHeldExclusively</span><span class=o>())</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalMonitorStateException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=n>first</span> <span class=o>=</span> <span class=n>firstWaiter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>first</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>//唤醒线程，改变状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>doSignal</span><span class=o>(</span><span class=n>first</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>doSignal</span><span class=o>(</span><span class=n>Node</span> <span class=n>first</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span> <span class=o>(</span><span class=n>firstWaiter</span> <span class=o>=</span> <span class=n>first</span><span class=o>.</span><span class=na>nextWaiter</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>lastWaiter</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//剔除当前节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>first</span><span class=o>.</span><span class=na>nextWaiter</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>while</span> <span class=o>(!</span><span class=n>transferForSignal</span><span class=o>(</span><span class=n>first</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>first</span> <span class=o>=</span> <span class=n>firstWaiter</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//把node的状态从CONDITION变为其他状态，唤醒线程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>transferForSignal</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//CAS操作重置node的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(!</span><span class=n>compareAndSetWaitStatus</span><span class=o>(</span><span class=n>node</span><span class=o>,</span> <span class=n>Node</span><span class=o>.</span><span class=na>CONDITION</span><span class=o>,</span> <span class=mi>0</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//走到这里说明该节点的状态已经被修改成了初始状态0。把其加入到CLH队列尾部，并返回前一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=n>p</span> <span class=o>=</span> <span class=n>enq</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ws</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>waitStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>ws</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=o>!</span><span class=n>compareAndSetWaitStatus</span><span class=o>(</span><span class=n>p</span><span class=o>,</span> <span class=n>ws</span><span class=o>,</span> <span class=n>Node</span><span class=o>.</span><span class=na>SIGNAL</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>//唤醒线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LockSupport</span><span class=o>.</span><span class=na>unpark</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>thread</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>isHeldExclusively</code> 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占。这里看出调用<code>signal()</code>时必须位于独占线程。</p><p>由以上代码可以看到：</p><ul><li><code>signal()</code>唤起线程时，会把线程从条件队列中剔除；</li><li><code>await()</code>方法中阻塞的线程被唤起时会调用<code>acquireQueued()</code>方法不断获取锁。</li></ul><h2 id=全文总结>全文总结</h2><h3 id=一句话总结aqs原理>一句话总结AQS原理</h3><p>AQS内部包含<code>int state</code>状态机和CLH同步队列，通过判断状态机决定线程是否能获得锁，并利用CAS原子操作改变状态，并让拿不到锁的线程加入CLH同步队列，依赖<code>LockSuport.part</code>方法阻塞线程，当锁释放时会唤醒线程，让队首节点出队，并让下一个线程自旋竞争锁。</p><p>同时AQS利用Node中的<code>nextWaiter</code>单向链作为条件队列，让其中符合条件的节点加入CLH队列获得竞争锁的机会。</p><h3 id=可重入锁的原理>可重入锁的原理</h3><p>ReentrantLock是在AQS的基础上重写了<code>tryAcquire()</code>方法，判断当前线程是否是独占线程，是的话就直接让当前线程获得锁。</p></div></main></body></html>