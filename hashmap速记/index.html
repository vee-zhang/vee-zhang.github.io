<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>HashMap速记 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/hashmap%E9%80%9F%E8%AE%B0/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>HashMap速记</h1><time datetime=2021-01-12T17:49:10Z class=post-date>Tue, Jan 12, 2021</time><h2 id=版本差异>版本差异</h2><table><thead><tr><th>版本</th><th>特点</th></tr></thead><tbody><tr><td>JDK1.7</td><td>数组+单向链</td></tr><tr><td>JDK1.8</td><td>数组+单向链+红黑树</td></tr></tbody></table><p>jdk1.7中，数组是HashMap的主体，而链表是为了解决哈希冲突而存在的。当链表过长，回严重影响性能，所以在1.8中，当链表超过8且数据总量超过64会转成红黑树：</p><ul><li>链表超过8，且数据总量超过64会转成红黑树；</li><li>如果数组长度小于64，会优先扩容，以减少搜索时间。</li></ul><h2 id=默认加载因子>默认加载因子</h2><h2 id=java中的二进制>Java中的二进制</h2><h3 id=int的容量>int的容量</h3><p>我们一般使用的int是32位整型，占用4字节。在计算机中是以二进制来储存的，共有32位。</p><p>假设我们创建一个int i = 10，10的二进制是1010，一共只有4位，在计算机中会用0把前面补齐，满足32位存储，所以实际上计算机中储存的是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>00000000 00000000 00000000 00001010
</span></span></code></pre></td></tr></table></div></div><h3 id=源码反码补码>源码，反码，补码</h3><h4 id=源码>源码</h4><p>一个正数，按照<strong>绝对值</strong>大小转换成的二进制数；一个负数按照<strong>绝对值</strong>大小转换成的二进制数，然后<strong>最高位改为1</strong>，称为原码。</p><p>比如 00000000 00000000 00000000 00000101 是 5的 原码。</p><p>10000000 00000000 00000000 00000101 是 -5的 原码。</p><h4 id=反码>反码</h4><p>正数的反码与源码相同，负数的反码为对该数的原码<strong>除符号位外</strong>各位取反。</p><p>也就是原为1，得0；原为0，得1。（1变0; 0变1）。</p><p>5的反码：00000000 00000000 00000000 00000101</p><p>-5的反码：11111111 11111111 11111111 11111010</p><h4 id=补码>补码</h4><p>正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1。</p><p>5的补码：00000000 00000000 00000000 00000101</p><p>-5的补码：11111111 11111111 11111111 11111011</p><h3 id=java中对负数的处理>Java中对负数的处理</h3><p>在二进制里，是用0和1来表示正负的，最高位为符号位，最高位为1代表负数，最高位为0代表正数。</p><p><strong>计算机以补码的形式存储数据。</strong></p><h3 id=计算方式>计算方式</h3><ul><li>正数：绝对值的二进制；</li><li>负数：绝对值转二进制，高位改为1，得到反码，再把反码+1得到补码。</li></ul><h2 id=java移位操作>Java移位操作</h2><p>平时看源码总遇到几个符号，很是阻碍我学习，所以趁这次回顾HashMap的源码的机会，顺便把移位也复习一下吧。</p><ul><li>&#171; 左移位，将操作数向左移动指定的位数，并在低位补0；</li><li>>> 有符号右移位，将操作数向右移动指定的位数，若符号为正，则在高位插入0；若符号为负，则在高位插入1；</li><li>>&#187; 无符号右移位，无论正负，都在高位插入0。</li></ul><p>我们以一个负数举例：int i = -10，分别求i左移位2、有符号右移位2和无符号右移位2后的值。</p><p>左移位：先把i=-10换算成二进制后的值为-1010，然后左移两位，低位用0补上，得到值为-101000.</p><p>有符号右移位：先把i=-10换算成二进制后的值为111111111111111111111111111 10110，然后开始右移，但由于空间不够，所以末尾的10就会被舍去，所以得到值为-10，因为符号为负，所以高位用1补上。</p><p>计算机的移位计算比乘除运算效率更高，所以Java源码中很常见移位操作。</p><h2 id=java的操作符>Java的&操作符</h2><p>作用：如果相对应位都是1，则结果为1，否则为0。</p><p>实例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>11</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>21</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>toBinaryString</span><span class=o>(</span><span class=n>i</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>toBinaryString</span><span class=o>(</span><span class=n>j</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>toBinaryString</span><span class=o>(</span><span class=n>i</span> <span class=o>&amp;</span> <span class=n>j</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1011
</span></span><span class=line><span class=cl>10101
</span></span><span class=line><span class=cl>1
</span></span></code></pre></td></tr></table></div></div><blockquote><p>大概了解一下就行，反正还是不会算。。。</p></blockquote><h2 id=源码解读>源码解读</h2><blockquote><p>一开始看的是JDK1.8的源码，好复杂，所以特意下载了JDK1.7的源码开始学习，以下都是基于1.7的。</p></blockquote><h3 id=类定义支持克隆和序列化>类定义，支持克隆和序列化</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JAVA data-lang=JAVA><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>HashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>extends</span> <span class=n>AbstractMap</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>implements</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;,</span> <span class=n>Cloneable</span><span class=o>,</span> <span class=n>Serializable</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span></code></pre></td></tr></table></div></div><p>这里要提以下，HashMap遵循<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>，所以<strong>支持克隆，支持序列化</strong>。</p><h3 id=核心静态内部类单向链>核心静态内部类——单向链</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>class</span> <span class=nc>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//自己的key
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>final</span> <span class=n>K</span> <span class=n>key</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//自己的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>V</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//下一节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//自己的哈希
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>hash</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>    * 构造方法
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span><span class=o>(</span><span class=kt>int</span> <span class=n>h</span><span class=o>,</span> <span class=n>K</span> <span class=n>k</span><span class=o>,</span> <span class=n>V</span> <span class=n>v</span><span class=o>,</span> <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=n>K</span> <span class=nf>getKey</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=n>V</span> <span class=nf>getValue</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=n>V</span> <span class=nf>setValue</span><span class=o>(</span><span class=n>V</span> <span class=n>newValue</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>源码中不重要的地方我都省略了。</p><p>从源码来看，<code>Entry&lt;key,v></code>类是一个单向链表结构。</p><blockquote><p>再一次看到这个<code>Entry</code>，不禁让我想起了前段时间研究AQS里面的<code>Node</code>。Node是一个双向链表形式的CLH队列，所以类名用Node表示，意思是队列中的一个<strong>节点</strong>；但是在HashMap中的Entry是一个单向链表，所以一个Entry只能充当入口来用。实在很佩服Java的作者，能把类名起的这么贴切！</p></blockquote><h3 id=构造方法>构造方法</h3><p>JDK1.7版本中构造方法共有4个，但是核心的只有两个，我们主要研究第一个：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//常量，实际数值为1后面30个0,是个很大的数字，用于表示初始容量的极限
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>30</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> *核心构造方法一
</span></span></span><span class=line><span class=cl><span class=cm> * @param initialCapacity 初始容量
</span></span></span><span class=line><span class=cl><span class=cm> * @param loadFactor 加载因子
</span></span></span><span class=line><span class=cl><span class=cm>**/</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=nf>HashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span> <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>){</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//初始容量不能小于0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal initial capacity: &#34;</span> <span class=o>+</span> <span class=n>initialCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//初始容量降为极限
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>initialCapacity</span> <span class=o>=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//加载因子不允许小于0，必须为数字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>loadFactor</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>Float</span><span class=o>.</span><span class=na>isNaN</span><span class=o>(</span><span class=n>loadFactor</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal load factor: &#34;</span> <span class=o>+</span> <span class=n>loadFactor</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>loadFactor</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>threshold</span> <span class=o>=</span> <span class=n>initialCapacity</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//调用钩子方法，用来hook子类，本身没什么作用，需要子类重写才有用，但是我们一般也不重写。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>构造方法最大的作用就是初始化<strong>initialCapacity初始容量</strong>和<strong>loadFactor加载因子</strong>，这两个字段有什么用，下面会介绍到。</p><h3 id=put方法>put方法</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//节点数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>transient</span> <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>table</span> <span class=o>=</span> <span class=o>(</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[])</span> <span class=n>EMPTY_TABLE</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>V</span> <span class=nf>put</span><span class=o>(</span><span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//初始化table数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>table</span> <span class=o>==</span> <span class=n>EMPTY_TABLE</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>inflateTable</span><span class=o>(</span><span class=n>threshold</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//key为null的处理方式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>putForNullKey</span><span class=o>(</span><span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//下面是key不为null的处理方式
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//计算key的哈希码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>hash</span> <span class=o>=</span> <span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//找到hash码在数组中的位置，也就是查询定位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>indexFor</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>table</span><span class=o>.</span><span class=na>length</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//遍历该位置的单向链，找到对应的key，赋值value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=o>[</span><span class=n>i</span><span class=o>];</span> <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Object</span> <span class=n>k</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span> <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>)))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>V</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span><span class=o>.</span><span class=na>recordAccess</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//如果一直找不到对应的key，就添加一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addEntry</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * key为null时的处理方式,只是没有计算哈希，而是直接从
</span></span></span><span class=line><span class=cl><span class=cm> * table[0]位置开始遍历链表
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>V</span> <span class=nf>putForNullKey</span><span class=o>(</span><span class=n>V</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span> <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>V</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span><span class=o>.</span><span class=na>recordAccess</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=n>addEntry</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=kc>null</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 根据hash找到数组中的对应位置
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>static</span> <span class=kt>int</span> <span class=nf>indexFor</span><span class=o>(</span><span class=kt>int</span> <span class=n>h</span><span class=o>,</span> <span class=kt>int</span> <span class=n>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>h</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>length</span><span class=o>-</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 添加新节点
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>addEntry</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=kt>int</span> <span class=n>bucketIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>((</span><span class=n>size</span> <span class=o>&gt;=</span> <span class=n>threshold</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=kc>null</span> <span class=o>!=</span> <span class=n>table</span><span class=o>[</span><span class=n>bucketIndex</span><span class=o>]))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果当前size大于扩容因子，则扩容两倍
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>resize</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>table</span><span class=o>.</span><span class=na>length</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>hash</span> <span class=o>=</span> <span class=o>(</span><span class=kc>null</span> <span class=o>!=</span> <span class=n>key</span><span class=o>)</span> <span class=o>?</span> <span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>)</span> <span class=o>:</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>bucketIndex</span> <span class=o>=</span> <span class=n>indexFor</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>table</span><span class=o>.</span><span class=na>length</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>createEntry</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>bucketIndex</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 创建新节点，并插入队首
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>createEntry</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=kt>int</span> <span class=n>bucketIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=o>[</span><span class=n>bucketIndex</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>table</span><span class=o>[</span><span class=n>bucketIndex</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>&lt;&gt;(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>size</span><span class=o>++;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 重新计算容量
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>resize</span><span class=o>(</span><span class=kt>int</span> <span class=n>newCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span><span class=o>[]</span> <span class=n>oldTable</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>oldCapacity</span> <span class=o>=</span> <span class=n>oldTable</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>oldCapacity</span> <span class=o>==</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>threshold</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span><span class=o>[]</span> <span class=n>newTable</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>[</span><span class=n>newCapacity</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>transfer</span><span class=o>(</span><span class=n>newTable</span><span class=o>,</span> <span class=n>initHashSeedAsNeeded</span><span class=o>(</span><span class=n>newCapacity</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=n>table</span> <span class=o>=</span> <span class=n>newTable</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>threshold</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span><span class=n>Math</span><span class=o>.</span><span class=na>min</span><span class=o>(</span><span class=n>newCapacity</span> <span class=o>*</span> <span class=n>loadFactor</span><span class=o>,</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=put方法总结>Put方法总结</h4><h5 id=先看看流程>先看看流程</h5><p>从Put方法可以看到，HashMap的核心是<strong>table数组，数组的元素是Entry这个单向链</strong>，这种结构被称之为<strong>散列表</strong>。</p><p>在存放数组时，使用<code>hash & (length-1)</code>的方式使数组均匀分布，提高查询效率。</p><blockquote><p>为何要均匀分布？因为查询时首先找到数组的对应下标，然后for循环对应的单向链。均匀分布使得链表长度尽可能小，减少了遍历次数，提高了效率。</p></blockquote><p>如果查询没有获取结果，并且当前的size大于扩容因子，HashMap会先调用<code>resize()</code>方法进行扩容<strong>翻倍</strong>，最后创建一个新节点，插入<strong>队首</strong>，</p><p><strong>HashMap允许key、value为null</strong>，当key为null时，会<strong>默认存在table[0]</strong>。</p><p>当key不为空时，在put时会依据key的哈希值找到数组中的对应位置，然后for循环遍历该位置的链表找到key，再进行储存。</p><h5 id=细说扩容>细说扩容</h5><p>HashMap中table数组初始长度是16（默认状况下），而默认加载因子的值为0.75f，所以默认情况，当table的长度超过<code>16 * 0.75 = 12</code>的时候，再继续put就会翻倍扩容成32，然后再重新计算每个元素在数组中的位置，这是非常耗费性能的。</p><p>为了解决以上问题，我们在使用HashMap的时候，应该尽可能避免扩容，所以应该在初始容量上面做文章：</p><p>比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。</p><p><a href=https://blog.csdn.net/sd_csdn_scy/article/details/55510453>摘自</a><a href=https://blog.csdn.net/sd_csdn_scy/article/details/55510453>https://blog.csdn.net/sd_csdn_scy/article/details/55510453</a></p><p>但是这样不可避免的出现了内存浪费。</p><h5 id=初始容量设置>初始容量设置</h5><ul><li>必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。</li><li>尽量在乘以0.75后大于预估元素数量。</li></ul><h3 id=get-方法>get 方法</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>V</span> <span class=nf>get</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>getForNullKey</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>entry</span> <span class=o>=</span> <span class=n>getEntry</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span> <span class=o>==</span> <span class=n>entry</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>entry</span><span class=o>.</span><span class=na>getValue</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * key为null时的处理方式
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>V</span> <span class=nf>getForNullKey</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//还是直接去赵table[0]，然后遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span> <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>getEntry</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//计算哈希值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>hash</span> <span class=o>=</span> <span class=o>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//查找哈希
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=o>[</span><span class=n>indexFor</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>table</span><span class=o>.</span><span class=na>length</span><span class=o>)];</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Object</span> <span class=n>k</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>get方法基本就没啥可说的了。</p><h2 id=序列化>序列化</h2><p>一开始看到类声明时，知道HashMap是支持序列化的，但是后来看到了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>transient</span> <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>table</span> <span class=o>=</span> <span class=o>(</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[])</span> <span class=n>EMPTY_TABLE</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><p>table是<code>transient</code>的，是不允许序列化的。而且<code>Entry</code>是不支持序列化的，所以我就开始想HashMap是怎么进行序列化的呢？</p><h3 id=writeobject>writeObject</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>writeObject</span><span class=o>(</span><span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>ObjectOutputStream</span> <span class=n>s</span><span class=o>)</span><span class=kd>throws</span> <span class=n>IOException</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 写入容量、加载因子等信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s</span><span class=o>.</span><span class=na>defaultWriteObject</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 写入table数组当前的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>table</span><span class=o>==</span><span class=n>EMPTY_TABLE</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>.</span><span class=na>writeInt</span><span class=o>(</span><span class=n>roundUpToPowerOf2</span><span class=o>(</span><span class=n>threshold</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=o>.</span><span class=na>writeInt</span><span class=o>(</span><span class=n>table</span><span class=o>.</span><span class=na>length</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 写入当前元素数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s</span><span class=o>.</span><span class=na>writeInt</span><span class=o>(</span><span class=n>size</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历写入所有元素的KV
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=o>(</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>:</span> <span class=n>entrySet0</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=o>.</span><span class=na>writeObject</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>getKey</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=o>.</span><span class=na>writeObject</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>getValue</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=readobject>readObject</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>readObject</span><span class=o>(</span><span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>ObjectInputStream</span> <span class=n>s</span><span class=o>)</span><span class=kd>throws</span> <span class=n>IOException</span><span class=o>,</span> <span class=n>ClassNotFoundException</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>.</span><span class=na>defaultReadObject</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>loadFactor</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>Float</span><span class=o>.</span><span class=na>isNaN</span><span class=o>(</span><span class=n>loadFactor</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidObjectException</span><span class=o>(</span><span class=s>&#34;Illegal load factor: &#34;</span> <span class=o>+</span><span class=n>loadFactor</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// set other fields that need values
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>table</span> <span class=o>=</span> <span class=o>(</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[])</span> <span class=n>EMPTY_TABLE</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Read in number of buckets
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s</span><span class=o>.</span><span class=na>readInt</span><span class=o>();</span> <span class=c1>// ignored.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Read number of mappings
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>mappings</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=na>readInt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>mappings</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidObjectException</span><span class=o>(</span><span class=s>&#34;Illegal mappings count: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                            <span class=n>mappings</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// capacity chosen by number of mappings and desired load (if &gt;= 0.25)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>capacity</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=n>Math</span><span class=o>.</span><span class=na>min</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=n>mappings</span> <span class=o>*</span> <span class=n>Math</span><span class=o>.</span><span class=na>min</span><span class=o>(</span><span class=mi>1</span> <span class=o>/</span> <span class=n>loadFactor</span><span class=o>,</span> <span class=mf>4.0f</span><span class=o>),</span>
</span></span><span class=line><span class=cl>                <span class=c1>// we have limits...
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>HashMap</span><span class=o>.</span><span class=na>MAXIMUM_CAPACITY</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// allocate the bucket array;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>mappings</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>inflateTable</span><span class=o>(</span><span class=n>capacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>threshold</span> <span class=o>=</span> <span class=n>capacity</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>init</span><span class=o>();</span>  <span class=c1>// Give subclass a chance to do its thing.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Read the keys and values, and put the mappings in the HashMap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>mappings</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>K</span> <span class=n>key</span> <span class=o>=</span> <span class=o>(</span><span class=n>K</span><span class=o>)</span> <span class=n>s</span><span class=o>.</span><span class=na>readObject</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>V</span> <span class=n>value</span> <span class=o>=</span> <span class=o>(</span><span class=n>V</span><span class=o>)</span> <span class=n>s</span><span class=o>.</span><span class=na>readObject</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>putForCreate</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=序列化总结>序列化总结</h3><p>HashMap的序列化和反序列化原理就是遍历读写table数组中的各个Entry元素的key和value，采用了<code>ObjectInputStream.readObject()</code>和<code>ObjectInputStream.writeObject()</code>方法。</p><h2 id=知识点速记>知识点速记</h2><ol><li>储存结构：<table><thead><tr><th>JDK版本</th><th>结构</th><th>特点</th></tr></thead><tbody><tr><td>1.7</td><td>散列表</td><td>链表太长影响查询性能</td></tr><tr><td>1.8</td><td>散列表+红黑树</td><td>链表长度超过8并且数据总量超过64转红黑树</td></tr></tbody></table></li><li>核心字段：<table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><code>transient Entry[] table</code></td><td>主要存储，散列表</td></tr><tr><td><code>transient int size</code></td><td>entry的个数</td></tr><tr><td><code>int threshold</code></td><td>阈值，等于table.length*loadFactory，table数组长度超过这个值就会扩容。</td></tr><tr><td><code>loadFactory</code></td><td>加载因子</td></tr><tr><td><code>modCount</code></td><td>修改次数</td></tr></tbody></table></li><li>初始容量：<ul><li>必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。</li><li>尽量在乘以0.75后大于预估元素数量。</li></ul></li><li>put过程：
先计算key的hash值，再根据<code>hash & (length-1)</code>找到key再table中的位置，遍历该位置上的链表找到对应的key；如果没有找到key，则<code>resize()</code>方法扩容，然后创建新的<code>entry</code>插入队首。</li><li>关于扩容：<ul><li>条件：调用put方法时，size>threshold*loadFactory；</li><li>方式：创建两倍长度的新数组，然后for嵌套while循环一个个的倒腾。</li></ul></li><li>关于序列化：
自己实现了<code>writeObject</code>和<code>readObject</code>方法，通过反射调用；优先处理那几个核心字段，最后遍历entrySet分别读写key和value。</li><li>关于EntrySet：
EntrySet是HashMap的内部类，所以可以访问HashMap的成员，提供<code>nextEntry</code>方法，遍历的还是HashMap的散列表。</li></ol></div></main></body></html>