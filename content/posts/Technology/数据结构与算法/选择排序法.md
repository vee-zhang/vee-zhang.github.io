---
title: "选择排序法"
subtitle: ""
date: 2022-05-13T17:29:21+08:00
lastmod: 2022-05-13T17:29:21+08:00
draft: false
authors: []
description: ""

tags: []
categories: []
series: []

hiddenFromHomePage: false
hiddenFromSearch: false

featuredImage: ""
featuredImagePreview: ""

toc:
  enable: true
math:
  enable: false
lightgallery: false
license: ""
---
同样基于交换的思想，选择排序法的效率要比冒泡排序高很多。
<!--more-->

### 核心思想

将数据分成两组，通过遍历找到极值，并存放到另一组末尾。

![选择排序](选择排序.gif)

### 选择查找极值

### 选择法查找极值

```java
private static int max(int[] original) {
    int[] arr = Arrays.copyOf(original, original.length);

    int i = 0;
    int pos = i + 1;
    for (; i < arr.length; i++) {
        if (arr[i] > arr[pos]) {
            pos = i;
        }
    }
    return arr[pos];
}
```

### 选择法排序

```java
private static int[] sort(int[] original) {
    // copy一份数据出来，不让原数据受影响
    int[] aar = Arrays.copyOf(original, original.length);

    int num;
    // 只遍历n-1次就够了，最后一个数不用管
    for (int i = 0; i < aar.length - 1; i++) {

        // 记录极值的位置
        int minPos = i;

        // 让出已处理过的数据，只需遍历剩下的数据
        for (int j = i + 1; j < aar.length; j++) {
            // 比较并更新位置
            if (aar[j] < aar[minPos]) {
                minPos = j;
            }
        }

        // 一轮遍历之后开始交换
        if (i != minPos) {
            num = aar[i];
            aar[i] = aar[minPos];
            aar[minPos] = num;
        }
    }
    return aar;
}
```

- 首先从左往右选择一个元素i，然后定义一个指针`minPos`，之后遍历i后面的元素查找最小值的位置记录到指针，最后用初始选定的元素i去与minPos交换。
- 外层循环遍历n-1次，剩下最后一个值不需要管；
- 一份数据分成两组整理，所以遍历次数会依次减少，提高效率；
- 元素每次不只移动一位；
- 通过记录下标，内层循环一轮之后元素才会移动；
- 时间复杂度：O(n²)