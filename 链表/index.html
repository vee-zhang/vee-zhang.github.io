<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>链表 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/%E9%93%BE%E8%A1%A8/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>链表</h1><time datetime=2022-05-14T20:54:34+0800 class=post-date>Sat, May 14, 2022</time><h3 id=常见淘汰策略>常见淘汰策略</h3><ul><li>FIFO（First In，First Out）先进先出；</li><li>FILO 先进后出；</li><li>LFU（Least Frequently Used）最少使用；</li><li>LRU（Least Recently Used）最近最少使用。</li></ul><h3 id=链表的特性>链表的特性</h3><p>不需要连续的储存空间，而是通过指针讲一堆零散的内存快串联起来。；</p><h3 id=单链表>单链表</h3><ul><li><strong>后继指针</strong>：由于数据存储不连续，所以链表中的每一个节点都需要记录下一个节点的地址，叫做后继指针；</li><li>头节点，记录了链表的基地址；</li><li>尾节点，后继指针指向空地址null。</li></ul><p>由于数组需要连续的储存空间，所以在增删操作时需要移位补漏，所以时间复杂度是O(n)，而链表因为空间本身不是连续的，所以不需要移位，所以时间复杂度是O(1)。</p><h3 id=循环链表>循环链表</h3><ul><li>一种特殊的单项链，尾节点的后继指针指向头节点。</li><li>从链尾可以轻松返回链头。</li><li>当数据具备环形特点时适合使用循环链表。</li></ul><h3 id=双向链表>双向链表</h3><p>节点中同时具备<strong>前驱</strong>和**后继双指针</p><h3 id=lru算法>LRU算法</h3><p>在一个固定长度并且有序的链表结构中存入数据，由于有序，所以最先插入的就会排在链尾。</p><p>当访问数据时，从链头开始遍历查询到对应节点，并将它移到链头；</p><p>如果没有查询到，则将新数据插入链头。</p><p>如果插入后发现链表已超出固定长度，则删除链尾。</p></div></main></body></html>