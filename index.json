[{"categories":["第三方框架"],"content":"最近研究PKI，想实现私钥不出TEE这个需求,需要确认okhttp中SSL认证的实现，结果说看看源码吧，让我好一顿找阿，特此记录一下过程。 Okhttp添加自签名证书方法: OkHttpClient.Builder builder = new OkHttpClient.Builder(); // 添加自定义的SSLSocketFactory和X509TrustManager builder.sslSocketFactory(sslInput.mSSLSocketFactory, sslInput.mX509TrustManager); // 域名验证 builder.hostnameVerifier((hostname, session) -\u003e true ); 最主要的其实就是builder.sslSocketFactory函数，由于是建造者模式，那么OkhttpClient.Builder设置了属性，最终在调用builder.build()函数时，一定会把builder的属性赋值给父类OkhttpClient，追踪builder.build()函数，最终调用OkhttpClient的构造函数，其中有一段逻辑： if (builder.sslSocketFactory != null || !isTLS) { //如果builder设置了sslSocketFactory就用builder的 this.sslSocketFactory = builder.sslSocketFactory; this.certificateChainCleaner = builder.certificateChainCleaner; } else { // 如果没有设置过builder的ssSocketFactory就用系统默认的 X509TrustManager trustManager = systemDefaultTrustManager(); this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager); this.certificateChainCleaner = CertificateChainCleaner.get(trustManager); } 我们主要关注的就是系统默认的systemDefaultSslSocketFactory(trustManager)。 继续追踪： private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) { try { // 获取到平台的SSLContext SSLContext sslContext = Platform.get().getSSLContext(); sslContext.init(null, new TrustManager[] { trustManager }, null); return sslContext.getSocketFactory(); } catch (GeneralSecurityException e) { throw assertionError(\"No System TLS\", e); // The system has no TLS. Just give up. } } 这里就看到了Okhttp的跨平台思路，简单看一下Platform.get()的逻辑： public class Platform { // 静态加载方式 private static final Platform PLATFORM = findPlatform(); public static Platform get() { return PLATFORM; } private static Platform findPlatform() { // 优先加载安卓平台 Platform android = AndroidPlatform.buildIfSupported(); if (android != null) { return android; } // 其他的都是jdk中的安全策略 ... } } 那么从这里的逻辑可以看到，各个平台的安全策略可能是不一致的。 那么OKHttp是怎么加载安卓平台的呢： public static Platform buildIfSupported() { // Attempt to find Android 2.3+ APIs. try { Class\u003c?\u003e sslParametersClass; try { sslParametersClass = Class.forName(\"com.android.org.conscrypt.SSLParametersImpl\"); } catch (ClassNotFoundException e) { // Older platform before being unbundled. sslParametersClass = Class.forName( \"org.apache.harmony.xnet.provider.jsse.SSLParametersImpl\"); } ... return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname, getAlpnSelectedProtocol, setAlpnProtocols); } catch (ClassNotFoundException ignored) { // This isn't an Android runtime. } return null; } 主要是通过hook系统中的com.android.org.conscrypt.SSLParametersImpl。可以先记住这个类，暂时跳过这里。 ","date":"2023-02-21","objectID":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/:0:0","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp的SSL握手溯源","uri":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/#"},{"categories":["第三方框架"],"content":" SSLContext我们继续来看SSLContext sslContext = Platform.get().getSSLContext()，向里面追踪： import sun.security.jca.GetInstance; public SSLContext getSSLContext() { try { return SSLContext.getInstance(\"TLS\"); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(\"No TLS provider\", e); } } public static SSLContext getInstance(String protocol) throws NoSuchAlgorithmException { GetInstance.Instance instance = GetInstance.getInstance (\"SSLContext\", SSLContextSpi.class, protocol); return new SSLContext((SSLContextSpi)instance.impl, instance.provider, protocol); } 发现GetInstance.Instance.impl是SSLContextSpi类型。 到这里GetInstance的源码无法查看，是因为我们没有下载sun.security.jca.GetInstance的源码，但是在AOSP中是可以搜索到的,文件在此。 核心方法： /** * @param type = \"SSLContext\" * @param clazz = SSLContextSpi.class * @param algorithm = \"TLS\" **/ public static Instance getInstance(String type, Class\u003c?\u003e clazz, String algorithm) throws NoSuchAlgorithmException { ProviderList list = Providers.getProviderList(); Service firstService = list.getService(type, algorithm); if (firstService == null) { throw new NoSuchAlgorithmException (algorithm + \" \" + type + \" not available\"); } NoSuchAlgorithmException failure; try { return getInstance(firstService, clazz); } catch (NoSuchAlgorithmException e) { failure = e; } for (Service s : list.getServices(type, algorithm)) { if (s == firstService) { // do not retry initial failed service continue; } try { return getInstance(s, clazz); } catch (NoSuchAlgorithmException e) { failure = e; } } throw failure; } 这里主要是用参数中的type与algorithm去做个命中匹配，具体是通过Providers的Providers.getProviderList()方法完成,而这个类同样位于sun.security.jca包中，在AOSP内是可见的： public static ProviderList getProviderList() { ProviderList list = getThreadProviderList(); if (list == null) { list = getSystemProviderList(); } return list; } private static void setSystemProviderList(ProviderList list) { providerList = list; } 可惜的是，AOSP中并没有找到调用setSystemProviderList()函数的地方，那就有可能是外部hook调用了。 ","date":"2023-02-21","objectID":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/:1:0","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp的SSL握手溯源","uri":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/#sslcontext"},{"categories":["第三方框架"],"content":" 接下来关注Service firstService = list.getService(type, algorithm); public List\u003cService\u003e getServices(String type, String algorithm) { return new ServiceList(type, algorithm); } ….. ","date":"2023-02-21","objectID":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/:1:1","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp的SSL握手溯源","uri":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/#接下来关注service-firstservice--listgetservicetype-algorithm"},{"categories":["第三方框架"],"content":" 最终是在external/conscrypt/common/src/main/java/org/conscrypt/NativeSsl.java中有具体的握手逻辑，最终是调用： NativeCrypto.SSL_do_handshake(ssl, this, fd, handshakeCallbacks, timeoutMillis); 而这个是个Native方法，具体实现是在external/conscrypt/common/src/jni/main/cpp/conscrypt/native_crypto.cc中实现。 /** * Perform SSL handshake */ static void NativeCrypto_SSL_do_handshake(JNIEnv* env, jclass, jlong ssl_address, CONSCRYPT_UNUSED jobject ssl_holder, jobject fdObject, jobject shc, jint timeout_millis) { CHECK_ERROR_QUEUE_ON_RETURN; SSL* ssl = to_SSL(env, ssl_address, true); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake fd=%p shc=%p timeout_millis=%d\", ssl, fdObject, shc, timeout_millis); if (ssl == nullptr) { return; } if (fdObject == nullptr) { conscrypt::jniutil::throwNullPointerException(env, \"fd == null\"); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake fd == null =\u003e exception\", ssl); return; } if (shc == nullptr) { conscrypt::jniutil::throwNullPointerException(env, \"sslHandshakeCallbacks == null\"); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake sslHandshakeCallbacks == null =\u003e exception\", ssl); return; } NetFd fd(env, fdObject); if (fd.isClosed()) { // SocketException thrown by NetFd.isClosed JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake fd.isClosed() =\u003e exception\", ssl); return; } int ret = SSL_set_fd(ssl, fd.get()); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake s=%d\", ssl, fd.get()); if (ret != 1) { conscrypt::jniutil::throwSSLExceptionWithSslErrors(env, ssl, SSL_ERROR_NONE, \"Error setting the file descriptor\"); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake SSL_set_fd =\u003e exception\", ssl); return; } /* * Make socket non-blocking, so SSL_connect SSL_read() and SSL_write() don't hang * forever and we can use select() to find out if the socket is ready. */ if (!conscrypt::netutil::setBlocking(fd.get(), false)) { conscrypt::jniutil::throwSSLExceptionStr(env, \"Unable to make socket non blocking\"); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake setBlocking =\u003e exception\", ssl); return; } AppData* appData = toAppData(ssl); if (appData == nullptr) { conscrypt::jniutil::throwSSLExceptionStr(env, \"Unable to retrieve application data\"); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake appData =\u003e exception\", ssl); return; } ret = 0; SslError sslError; while (appData-\u003ealiveAndKicking) { errno = 0; if (!appData-\u003esetCallbackState(env, shc, fdObject)) { // SocketException thrown by NetFd.isClosed JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake setCallbackState =\u003e exception\", ssl); return; } ret = SSL_do_handshake(ssl); appData-\u003eclearCallbackState(); // cert_verify_callback threw exception if (env-\u003eExceptionCheck()) { ERR_clear_error(); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake exception =\u003e exception\", ssl); return; } // success case if (ret == 1) { break; } // retry case if (errno == EINTR) { continue; } // error case sslError.reset(ssl, ret); JNI_TRACE( \"ssl=%p NativeCrypto_SSL_do_handshake ret=%d errno=%d sslError=%d \" \"timeout_millis=%d\", ssl, ret, errno, sslError.get(), timeout_millis); /* * If SSL_do_handshake doesn't succeed due to the socket being * either unreadable or unwritable, we use sslSelect to * wait for it to become ready. If that doesn't happen * before the specified timeout or an error occurs, we * cancel the handshake. Otherwise we try the SSL_connect * again. */ if (sslError.get() == SSL_ERROR_WANT_READ || sslError.get() == SSL_ERROR_WANT_WRITE) { appData-\u003ewaitingThreads++; int selectResult = sslSelect(env, sslError.get(), fdObject, appData, timeout_millis); if (selectResult == THROWN_EXCEPTION) { // SocketException thrown by NetFd.isClosed JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake sslSelect =\u003e exception\", ssl); return; } if (selectResult == -1) { conscrypt::jniutil::throwSSLExceptionWithSslErrors( env, ssl, SSL_ERROR_SYSCALL, \"handshake error\", conscrypt::jniutil::throwSSLHandshakeExceptionStr); JNI_TRACE(\"ssl=%p NativeCrypto_SSL_do_handshake selectResult == -1 =\u003e exception\", ssl); return; } if (selectResult == 0) { conscrypt::jniutil:","date":"2023-02-21","objectID":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/:2:0","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp的SSL握手溯源","uri":"/okhttp%E7%9A%84ssl%E6%8F%A1%E6%89%8B%E6%BA%AF%E6%BA%90/#最终"},{"categories":["AOSP"],"content":"这是我跟随秋少的系列课程Android系统开发入门做的笔记，感谢原博主秋少！ 课程连接 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:0:0","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#"},{"categories":["AOSP"],"content":" 了解Android.bpAOSP的编译工具是soong，这货用Android.bp文件来定义编译方式。 每一个模块（module）的根目录下都应该有一个Android.bp（或者已经过期的Android.mk）。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:0","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#了解androidbp"},{"categories":["AOSP"],"content":" 类型Android.bp中也可以设置一些变量有如下类型： 布尔值（true or false） 整数(int) 字符串(“string”) 字符串列表（[“string1”,“string2”]） 映射({key1:“value1”,key2:[“value2”]}) 映射可以包含任何类型的值，包括嵌套映射。列表和映射可能在最后一个值后面有终止逗号。——引自https://source.android.google.cn/docs/setup/build?hl=zh_cn 那我理解，一个模块除了模块类型之外的其他部分其实都是映射。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:1","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#类型"},{"categories":["AOSP"],"content":" 格式 cc_binary { name: \"gzip\", srcs: [ \"src/test/minigzip.c\", \"src/test/minigzip1.c\" ], shared_libs: [\"libz\"], stl: \"none\", } 上面的代码描述的就是一个模块。看起来很像json，但并不是json。 他以module type开头，后跟一组映射。 name属性: 必须，表示模块名称，在所有模块中唯一； srcs：指定模块的源文件，也可以通过『模块引用语法』:\u003cmodule-name\u003e引用其他模块的输出。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:2","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#格式"},{"categories":["AOSP"],"content":" 变量变量的声明类似于bash中的变量声明： gzip_srcs = [\"src/test/minigzip.c\"], 变量是在声明后才开始生效的。 我们来看个例子： gzip_srcs = [\"src/test/minigzip.c\"], cc_binary { name: \"gzip\", srcs: gzip_srcs,//直接使用变量 shared_libs: [\"libz\"], stl: \"none\", } 变量是不可变的。可以使用+=将变量附加到 别处。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:3","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#变量"},{"categories":["AOSP"],"content":" 注释 单行注释：// 多行注释：/* */ ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:4","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#注释"},{"categories":["AOSP"],"content":" 运算符可以使用+运算符来： 拼接字符串、字符串列表和映射 整数求和 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:5","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#运算符"},{"categories":["AOSP"],"content":" 全局模式与通配符接受文件的属性可以采用UNIX通配符*，如： *.java java/**/*.java同时匹配 java/Main.java 和 java/com/android/Main.java ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:6","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#全局模式与通配符"},{"categories":["AOSP"],"content":" 条件编译可以在Android.bp中为不同条件添加不同属性，具体的逻辑判断是在Go语言中实现的。 例如对于特定架构： cc_library { ... srcs: [\"generic.cpp\"], arch: { arm: { srcs: [\"arm.cpp\"], }, x86: { srcs: [\"x86.cpp\"], }, }, } ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:7","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#条件编译"},{"categories":["AOSP"],"content":" 格式化命令 bpfmt -w . 可以递归对当前目录和子目录中所有的Android.bp文件进行格式化，包括： 缩进4个空格 多元素列表的每个元素后面有换行符 列表和映射末尾有英文逗号 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:1:8","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#格式化命令"},{"categories":["AOSP"],"content":" 特殊模块","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:2:0","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#特殊模块"},{"categories":["AOSP"],"content":" 默认模块cc_defaults可以封装一些公共属性，提供给其他模块使用： cc_defaults { name: \"gzip_defaults\", shared_libs: [\"libz\"], stl: \"none\", } cc_binary { name: \"gzip\", defaults: [\"gzip_defaults\"], srcs: [\"src/test/minigzip.c\"], } ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:2:1","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#默认模块"},{"categories":["AOSP"],"content":" 命名空间模块Soong 可以让不同目录中的模块指定相同的名称，只要每个模块都在单独的命名空间中声明即可。可以按如下方式声明命名空间： soong_namespace { imports: [\"path/to/otherNamespace1\", \"path/to/otherNamespace2\"], } 注意：soong_namespace模块不需要name属性，他的所在路径会自动成为模块name。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:2:2","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#命名空间模块"},{"categories":["AOSP"],"content":" 预构建模块","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:2:3","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#预构建模块"},{"categories":["AOSP"],"content":" 具体定义具体定义在build/soong/androidmk/cmd/androidmk/android.go。 var moduleTypes = map[string]string{ \"BUILD_SHARED_LIBRARY\": \"cc_library_shared\", \"BUILD_STATIC_LIBRARY\": \"cc_library_static\", \"BUILD_HOST_SHARED_LIBRARY\": \"cc_library_host_shared\", \"BUILD_HOST_STATIC_LIBRARY\": \"cc_library_host_static\", \"BUILD_HEADER_LIBRARY\": \"cc_library_headers\", \"BUILD_EXECUTABLE\": \"cc_binary\", \"BUILD_HOST_EXECUTABLE\": \"cc_binary_host\", \"BUILD_NATIVE_TEST\": \"cc_test\", \"BUILD_HOST_NATIVE_TEST\": \"cc_test_host\", \"BUILD_NATIVE_BENCHMARK\": \"cc_benchmark\", \"BUILD_HOST_NATIVE_BENCHMARK\": \"cc_benchmark_host\", \"BUILD_JAVA_LIBRARY\": \"java_library\", \"BUILD_STATIC_JAVA_LIBRARY\": \"java_library_static\", \"BUILD_HOST_JAVA_LIBRARY\": \"java_library_host\", \"BUILD_HOST_DALVIK_JAVA_LIBRARY\": \"java_library_host_dalvik\", \"BUILD_PACKAGE\": \"android_app\", } module type description cc_library_shared 编译成动态库 cc_library_static 编译成静态库 cc_library_host_shared cc_library_host_static cc_library_headers cc_binary 编译成可执行文件 cc_binary_host cc_test cc_test_host cc_benchmark cc_benchmark_host java_library 构建.jar，如果指定“installable:true”将生成一个包含“classes.dex”文件的“.jar”文件，适合在设备上安装 java_library_static 同上，已过时 java_library_host java_library_host_dalvik android_app 构建apk ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/:2:4","series":["跟秋少学Android系统开发"],"tags":[],"title":"第三课：自定义模块","uri":"/%E7%AC%AC%E4%B8%89%E8%AF%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/#具体定义"},{"categories":["AOSP"],"content":"这是我跟随秋少的系列课程Android系统开发入门做的笔记，感谢原博主秋少！ 课程连接 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:0:0","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#"},{"categories":["AOSP"],"content":" product的要素 vendorsetup.sh:把product添加到lunch选项 BoardConfig.mk : 芯片硬件相关配置，分区设置等 AndroidProducts.mk : 指定 product 配置 product.mk : 一个产品的软件相关的配置，比如内置哪些软件模块，由AndroidProducts.mk 中的PRODUCT_MAKEFILES指定 device:用来给厂商放product的。 build/target目录，用来放google官方内置的product的。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:0:1","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#product的要素"},{"categories":["AOSP"],"content":" 创建device目录device的目录结构： device/company/product 新建我们的自己的目录： mkdir -p device/vee/veecar ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:0:2","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#创建device目录"},{"categories":["AOSP"],"content":" 板子配置BoardConfig.mkBoardConfig.mk包含了硬件芯片架构配置，分区大小等配置信息。 在device/vee/veecar下面，新建板子配置文件BoardConfig.mk，内容可以直接引用其他product的文件： include $(SRC_TARGET_DIR)/board/generic_x86_64/BoardConfig.mk 其中SRC_TARGET_DIR指代$(TOPDIR)build/target,可在build/core/config.mk中找到定义。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:0:3","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#板子配置boardconfigmk"},{"categories":["AOSP"],"content":" 产品配置[product].mk新建产品配置文件veecar.mk内容如下： $(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk) PRODUCT_NAME := veecar PRODUCT_DEVICE := veecar 注意： PRODUCT_NAME要保持与文件名一致，编译输出目录就是由这个变量决定的。 PRODUCT_DEVICE 跟BoardConfig.mk相关，编译系统会根据$(PRODUCT_DEVICE) 来加载对应目录下的BoardConfig.mk文件。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:0:4","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#产品配置productmk"},{"categories":["AOSP"],"content":" 编译配置AndroidProducts.mk新建AndroidProducts.mk文件： PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/veecar.mk // 从安卓10开始用来取代vendorsetup.sh的 COMMON_LUNCH_CHOICES := \\ veecar-eng 其中PRODUCT_MAKEFILES用来指定我们上一步中定义的product.mk文件，其中『veecar』对应我们的productName，eng则为build type: eng:对应到工程板。编译打包所有模块。同时ro.secure=0,ro.debuggable=1,ro.kernel.android.checkjni=1,表示adbd处于ROOT状态，所有调试开关都打开。 userDebug:对应到用户调试版，同时ro.debuggable=1,打开调试开关，但没有开放ROOT权限。 user：对应到用户版。同时ro.secure=1，ro.debuggable=0，关闭调试开关，关闭ROOT权限。最终发布到用户手里的都是user版。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:0:5","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#编译配置androidproductsmk"},{"categories":["AOSP"],"content":" vendorsetup.sh创建vendorsetup.sh文件如下： add_lunch_combo veecar-eng 主要作用就是向lunch界面中添加有一个combo，当我们执行source build/envsetup后再lunch，就会发现多了一个『veecar-eng』项目。 **注意：从android10开始不需要这玩意了，使用COMMON_LUNCH_CHOICES来替代。 ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:0:6","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#vendorsetupsh"},{"categories":["AOSP"],"content":" 编译验证执行下述指令编译验证。 source build/envsetup lunch veecar-eng m -j26 emulator ","date":"2023-02-07","objectID":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/:1:0","series":["跟秋少学Android系统开发"],"tags":[],"title":"第一课：添加product","uri":"/%E7%AC%AC%E4%B8%80%E8%AF%BE%E6%B7%BB%E5%8A%A0product/#编译验证"},{"categories":[],"content":" 练习java文件 package com.vee.test; public class HelloJNI { static { System.loadLibrary(\"HelloJNI\"); } public native void sayHello(); public static void main(String[] args) { new HelloJNI().sayHello(); } } 通过System.loadLibrary(\"[库名称]\")加载库。 通过native声明函数，表示这是个本地函数，需要通过jni来调用其他语言中的函数。 ","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:1:0","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#练习java文件"},{"categories":[],"content":" 生成头文件java10以下： javac HelloJNI javah HelloJNI java10及以上： javac -h include HelloJNI.java 以上命令会在相对地址include目录下生成com_vee_test_HelloJNI.h头文件： /* DO NOT EDIT THIS FILE - it is machine generated */ #include \u003cjni.h\u003e /* Header for class com_vee_test_HelloJNI */ #ifndef _Included_com_vee_test_HelloJNI #define _Included_com_vee_test_HelloJNI #ifdef __cplusplus extern \"C\" { #endif /* * Class: com_vee_test_HelloJNI * Method: sayHello * Signature: ()V */ JNIEXPORT void JNICALL Java_com_vee_test_HelloJNI_sayHello (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 其中最主要的就是函数JNIEXPORT void JNICALL Java_HelloJNI_sayHello (JNIEnv *, jobject);，参数解释如下： JNIEnv*：JNI运行环境的指针 jobject: 调用对象，指代java中的this对象。 ","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:2:0","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#生成头文件"},{"categories":[],"content":" 编译出库","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:3:0","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#编译出库"},{"categories":[],"content":" linux gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared include/HelloJNI.c -o libs/libHelloJNI.so -I 包含编译JNI必要的头文件 -fPIC 编译成与位置无关的独立代码 -shared 编译成动态库 -o 指定编译后动态库生成的路径和文件名（一般用libXXX.so命名）,这里我们把so放在libs目录下。 ","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:3:1","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#linux"},{"categories":[],"content":" 运行 java -Djava.library.path=./libs com/vee/test/HelloJNI.java -Djava.library.path是指明java的库路径，如果不加这个选项，则java默认会去系统属性指定的目录下查找动态库文件，找不到会报错： java.lang.UnsatisfiedLinkError: no HelloJNI in java.library.path: /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib 可以看到，java会默认从这两个目录中找： /usr/lib /usr/lib64 ","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:3:2","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#运行"},{"categories":[],"content":" 数据类型","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:4:0","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#数据类型"},{"categories":[],"content":" 基本数据类型 java jni c/c++ description boolean jboolean unsigned char unsigned 8 bits byte jbyte signed char signed 8 bits char jchar unsigned short unsigned 16 bits short jshort signed short signed 16 bits int jint signed int signed 64 bits long jlong signed long signed 64 bits float jfloat float 32 bits double jdouble double 64bits 注意：这些数据类型是可以在JNI中直接时使用的，不需转换。 ","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:4:1","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#基本数据类型"},{"categories":[],"content":" 引用数据类型 java jni java.lang.Object jobject java.lang.String jstring java.lang.Class jclass Object[] jobjectArray boolean[] jbooleanArray byte[] jbyteArray char[] jcharArray short[] jshortArray int[] jintArray long[] jlongArray float[] jfloatArray double[] jdoubleArray java.lang.Throwable jthrowable void void 引用类型不能直接使用，需要经过JNI函数转换才能使用： jclass intArrayClass = env-\u003eFindClass(\"[I\"); int len = 10; jobjectArray objectIntArray = env-\u003eNewObjectArray(len,intArrayClass,NULL); JNI中所有的array类型，都继承自jarray类型 ","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:4:2","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#引用数据类型"},{"categories":[],"content":" 类描述符","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:4:3","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#类描述符"},{"categories":[],"content":" 域描述符","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:4:4","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#域描述符"},{"categories":[],"content":" JNIENVJNIEnv,英文全称是Java Native Interface Environment，用咋中国话来说就是Java本地接口环境。 在JNI中，通过native方法编译出的.h文件中对应的函数声明，第一个参数永远是JNIEnv的指针。 JNI中提供了一系列的方式供我们使用： 函数 功能 FindClass 加载本地定义的类型 GetObjectClass 获取对象的类型 NewGlobalRef 创建obj参数所引用对象的新全局引用 NewObject 构造新的java对象 NewString 利用Unicode字符数组构造新的java.lang.String对象 NewArray 创建类型为Type的数组对象 GetField 获取类型为Type的字段 SetField 设置类型为Type的字段 GetStaticField 获取类型为Type的static的字段的值 SetStaticField 设置类型为Type的static的字段的值 CallMethod 调用返回类型为Type的方法 CallStaticMethod 调用返回值类型为Type的static方法 ","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:5:0","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#jnienv"},{"categories":[],"content":" 先到这里，待续。。。","date":"2023-01-15","objectID":"/jni%E5%AD%A6%E4%B9%A0/:6:0","series":[],"tags":[],"title":"JNI学习","uri":"/jni%E5%AD%A6%E4%B9%A0/#先到这里待续"},{"categories":[],"content":" scanf()函数scanf()函数用于格式化扫描，与print()函数正好相对。 #include \u003cstdio.h\u003e int main() { int a = 0, b = 0, c = 0, d = 0; scanf(\"%d\", \u0026a); //输入整数并赋值给变量a scanf(\"%d\", \u0026b); //输入整数并赋值给变量b printf(\"a+b=%d\\n\", a+b); //计算a+b的值并输出 scanf(\"%d %d\", \u0026c, \u0026d); //输入两个整数并分别赋值给c、d printf(\"c*d=%d\\n\", c*d); //计算c*d的值并输出 return 0; } 运行后在控制台中输入： 12回车 60回车 输出：a+b=72 再输入： 10 23回车 输出：c*d=230 ","date":"2022-12-16","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5/:1:0","series":[],"tags":[],"title":"C语言的输入","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5/#scanf函数"},{"categories":[],"content":" 字符","date":"2022-12-15","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":[],"tags":[],"title":"C语言的Char","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/#字符"},{"categories":[],"content":" 专用打印方式 char a = '1'; putchar(a); printf(\"%c\",a); putchar函数单次只能输出一个char,相对来说printf函数要强大的多。 ","date":"2022-12-15","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:1","series":[],"tags":[],"title":"C语言的Char","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/#专用打印方式"},{"categories":[],"content":" 字符与整数计算机在存储字符时并不是真的要存储字符的实体，而是存储该字符在字符集中的编号。对于char类型来说，世纪存储的就是字符的ASCII码。 无论在哪个字符集中，字符编号都是一个整数；从这个角度去考虑，字符类型本质上与整数一致。 我们可以给字符类型赋值一个整数，或者以整数的形式输出字符类型。反过来，也可以给整数类型赋值一个字符，或者以字符的形式输出整数类型。 #include \u003cstdio.h\u003e int main() { char a = 'E'; char b = 70; int c = 71; int d = 'H'; printf(\"a: %c, %d\\n\", a, a); printf(\"b: %c, %d\\n\", b, b); printf(\"c: %c, %d\\n\", c, c); printf(\"d: %c, %d\\n\", d, d); return 0; } 输出： a: E, 69 b: F, 70 c: G, 71 d: H, 72 ","date":"2022-12-15","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:2","series":[],"tags":[],"title":"C语言的Char","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/#字符与整数"},{"categories":[],"content":" 中文字符由于char使用电脑系统的默认编码，一般windows上都是ASCII，只能识别到英文字母，所以是不支持汉字单字符的。所以要存储汉字字符，需要使用宽字符wchar_t。 宽字符wchar_t使用UTF-16或UTF-32编码。 ","date":"2022-12-15","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:3","series":[],"tags":[],"title":"C语言的Char","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/#中文字符"},{"categories":[],"content":" 字符的编码char ","date":"2022-12-15","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:4","series":[],"tags":[],"title":"C语言的Char","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/#字符的编码"},{"categories":[],"content":" 字符串C语言中压根就没有字符串，只能使用数组和指针来渐渐的储存字符串。 //数组方式 char str1[] = \"http://c.biancheng.net\"; //这里帮原作打个广告 //指针方式 char *str2 = \"C语言中文网\"; ","date":"2022-12-15","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":[],"tags":[],"title":"C语言的Char","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/#字符串"},{"categories":[],"content":"TODO ","date":"2022-12-15","objectID":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AC%A6%E5%8F%B7%E4%BD%8D/:0:0","series":[],"tags":[],"title":"C语言的符号位","uri":"/c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AC%A6%E5%8F%B7%E4%BD%8D/#"},{"categories":[],"content":"一个数字默认就是十进制的，表示一个十进制数字不需要任何特殊的格式。但是表示其他进制的数组就需要加特定的前缀。 ","date":"2022-12-15","objectID":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/:0:0","series":[],"tags":[],"title":"进制数的表示","uri":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/#"},{"categories":[],"content":" 二进制前缀：0b或者0B。 int a = 0b101; //换算成十进制为 5 int b = -0b110010; //换算成十进制为 -50 int c = 0B100001; //换算成十进制为 33 ","date":"2022-12-15","objectID":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/:0:1","series":[],"tags":[],"title":"进制数的表示","uri":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/#二进制"},{"categories":[],"content":" 八进制前缀：0。 int a = 015; //换算成十进制为 13 int b = -0101; //换算成十进制为 -65 int c = 0177777; //换算成十进制为 65535 格式化输出：%ho,%o,%lo ","date":"2022-12-15","objectID":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/:0:2","series":[],"tags":[],"title":"进制数的表示","uri":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/#八进制"},{"categories":[],"content":" 十六进制十六进制由数字0~9、字母A~F（不区分大小写）组成。 前缀：0x或0X。 int a = 0X2A; //换算成十进制为 42 int b = -0XA0; //换算成十进制为 -160 int c = 0xffff; //换算成十进制为 65535 ","date":"2022-12-15","objectID":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/:0:3","series":[],"tags":[],"title":"进制数的表示","uri":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/#十六进制"},{"categories":[],"content":" 用进制进行格式化输出 int main() { short a = 0b1010110; //二进制数字 int b = 02713; //八进制数字 long c = 0X1DAB83; //十六进制数字 printf(\"a=%ho, b=%o, c=%lo\\n\", a, b, c); //以八进制形似输出 printf(\"a=%hd, b=%d, c=%ld\\n\", a, b, c); //以十进制形式输出 printf(\"a=%hx, b=%x, c=%lx\\n\", a, b, c); //以十六进制形式输出（字母小写） printf(\"a=%hX, b=%X, c=%lX\\n\", a, b, c); //以十六进制形式输出（字母大写） return 0; } 输出： a=126, b=2713, c=7325603 a=86, b=1483, c=1944451 a=56, b=5cb, c=1dab83 a=56, b=5CB, c=1DAB83 如果需要输出前缀，则在%后面加上#： int main() { short a = 0b1010110; //二进制数字 int b = 02713; //八进制数字 long c = 0X1DAB83; //十六进制数字 printf(\"a=%#ho, b=%#o, c=%#lo\\n\", a, b, c); //以八进制形似输出 printf(\"a=%hd, b=%d, c=%ld\\n\", a, b, c); //以十进制形式输出 printf(\"a=%#hx, b=%#x, c=%#lx\\n\", a, b, c); //以十六进制形式输出（字母小写） printf(\"a=%#hX, b=%#X, c=%#lX\\n\", a, b, c); //以十六进制形式输出（字母大写） return 0; } 对应输出： a=0126, b=02713, c=07325603 a=86, b=1483, c=1944451 a=0x56, b=0x5cb, c=0x1dab83 a=0X56, b=0X5CB, c=0X1DAB83 注意：不可以时用printf直接输出二进制。 ","date":"2022-12-15","objectID":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/:0:4","series":[],"tags":[],"title":"进制数的表示","uri":"/%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/#用进制进行格式化输出"},{"categories":[],"content":" 重点区分 ASCII,美国字符集，只支持英文字符。 GB2312,简体中文字符集，1984年发布。 GBK，中文字符集，1995年发布，在GB2312的基础上进行了扩展。 GB18030，中文字符集，2000年发布，在GBK上再次扩展。 Big5，中文繁体字符集 ","date":"2022-12-15","objectID":"/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/:0:0","series":[],"tags":[],"title":"1-1编程基础-ASCII与GBK","uri":"/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/#重点区分"},{"categories":[],"content":" 与ASCII的关系ASCII是最早的字符集，其他的字符集都是在ASCII的基础上进行扩展，所以全都兼容ASCII。 ","date":"2022-12-15","objectID":"/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/:1:0","series":[],"tags":[],"title":"1-1编程基础-ASCII与GBK","uri":"/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/#与ascii的关系"},{"categories":[],"content":" Unicode全球化范用的编码。 ","date":"2022-12-15","objectID":"/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/:2:0","series":[],"tags":[],"title":"1-1编程基础-ASCII与GBK","uri":"/1_1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ascii%E4%B8%8Egbk/#unicode"},{"categories":[],"content":" 模式 宽容模式-Permissive:只打印audit异常log，不会拒绝请求； 强制模式-Enforce:即打印audit异常log，也会拒绝请求； ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:1","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#模式"},{"categories":[],"content":" 策略文件 位置SELinux策略文件用于定义域和标签，以*.te结尾。 Android自带的策略文件位于AOSP中的system/sepolicy中，我们尽量不要去修改这里的策略，而是应修改位于device/manufacturer/device-name/sepolicy目录下（其实就是croot/device/制造商/设备/sepolicy/）的.te文件，同时也尽量不要去新建.te文件，而是应该在原有的基础上修改。 其实这里说的尽量不要，主要是针对企业，因为google有可能会找你麻烦，而且后续更新也会遇到问题，但是如果自己玩的话，想改就改。不过还是不建议改默认实现，否则升级之后又回退了。 格式 allow source target:class permissions; source:规则主题的类型（或属性），代表谁正在申请访问权限； target:对象类型（或属性），对哪些内容提出了访问权限； class:要访问的对象（）的类型; permissions:要执行的操作。 eg: allow untrusted_app app_data_file:file {read write}; 宏如果要添加的权限很多，为了简化规则定义，SEAndroid提供了宏，比如上面的例子可以这样写： eg: allow untrusted_app app_data_file:file rw_file_perms; ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:2","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#策略文件"},{"categories":[],"content":" 策略文件 位置SELinux策略文件用于定义域和标签，以*.te结尾。 Android自带的策略文件位于AOSP中的system/sepolicy中，我们尽量不要去修改这里的策略，而是应修改位于device/manufacturer/device-name/sepolicy目录下（其实就是croot/device/制造商/设备/sepolicy/）的.te文件，同时也尽量不要去新建.te文件，而是应该在原有的基础上修改。 其实这里说的尽量不要，主要是针对企业，因为google有可能会找你麻烦，而且后续更新也会遇到问题，但是如果自己玩的话，想改就改。不过还是不建议改默认实现，否则升级之后又回退了。 格式 allow source target:class permissions; source:规则主题的类型（或属性），代表谁正在申请访问权限； target:对象类型（或属性），对哪些内容提出了访问权限； class:要访问的对象（）的类型; permissions:要执行的操作。 eg: allow untrusted_app app_data_file:file {read write}; 宏如果要添加的权限很多，为了简化规则定义，SEAndroid提供了宏，比如上面的例子可以这样写： eg: allow untrusted_app app_data_file:file rw_file_perms; ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:2","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#位置"},{"categories":[],"content":" 策略文件 位置SELinux策略文件用于定义域和标签，以*.te结尾。 Android自带的策略文件位于AOSP中的system/sepolicy中，我们尽量不要去修改这里的策略，而是应修改位于device/manufacturer/device-name/sepolicy目录下（其实就是croot/device/制造商/设备/sepolicy/）的.te文件，同时也尽量不要去新建.te文件，而是应该在原有的基础上修改。 其实这里说的尽量不要，主要是针对企业，因为google有可能会找你麻烦，而且后续更新也会遇到问题，但是如果自己玩的话，想改就改。不过还是不建议改默认实现，否则升级之后又回退了。 格式 allow source target:class permissions; source:规则主题的类型（或属性），代表谁正在申请访问权限； target:对象类型（或属性），对哪些内容提出了访问权限； class:要访问的对象（）的类型; permissions:要执行的操作。 eg: allow untrusted_app app_data_file:file {read write}; 宏如果要添加的权限很多，为了简化规则定义，SEAndroid提供了宏，比如上面的例子可以这样写： eg: allow untrusted_app app_data_file:file rw_file_perms; ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:2","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#格式"},{"categories":[],"content":" 策略文件 位置SELinux策略文件用于定义域和标签，以*.te结尾。 Android自带的策略文件位于AOSP中的system/sepolicy中，我们尽量不要去修改这里的策略，而是应修改位于device/manufacturer/device-name/sepolicy目录下（其实就是croot/device/制造商/设备/sepolicy/）的.te文件，同时也尽量不要去新建.te文件，而是应该在原有的基础上修改。 其实这里说的尽量不要，主要是针对企业，因为google有可能会找你麻烦，而且后续更新也会遇到问题，但是如果自己玩的话，想改就改。不过还是不建议改默认实现，否则升级之后又回退了。 格式 allow source target:class permissions; source:规则主题的类型（或属性），代表谁正在申请访问权限； target:对象类型（或属性），对哪些内容提出了访问权限； class:要访问的对象（）的类型; permissions:要执行的操作。 eg: allow untrusted_app app_data_file:file {read write}; 宏如果要添加的权限很多，为了简化规则定义，SEAndroid提供了宏，比如上面的例子可以这样写： eg: allow untrusted_app app_data_file:file rw_file_perms; ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:2","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#宏"},{"categories":[],"content":" 上下文描述文件在device/manufacturer/device-name/sepolicy中存在各种上下文描述文件，主要负责为target打标签。 列举 file_contexts用于为文件分配标签，并且可供多种用户空间时用。 genfs_contexts用于为不支持扩展属性的文件系统分配标签。 property_contexts用于为Android系统属性分配标签，以便控制那些进程可以为设置这些属性。再启动期间，init进程会读取这些配置。 service_contexts用于为Android Binder服务分配标签，以便控制那些进程可以为相应服务添加（注册）和查找Binder引用。在启动期间，servicemanager进程会读取此配置。 seapp_contexts用于为应用进程和/data/data目录分配标签。在每次应用启动时，zygote进程都会读取此配置；在启动期间，installd会读取此配置。 mac_permissions.xml用于根据应用签名和应用软件包名称为应用分配seinfo标记。分配的seinfo标记可在seapp_contexts文件中用做密钥，以便为带有该seinfo标记的所有应用分配特定标签。在启动期间，sestem_server会读取此配置。 格式我们打开file_contexts文件，查看一下格式： /mnt/vendor/crypto(/.*)? u:object_r:mnt_vendor_crypto_file:s0 /(vendor|system/vendor)/bin/delete7dayslog.sh u:object_r:delete_seven_day_log-sh_exec:s0 就是目录+标签的方式，看起来很像host的定义。 这里要注意的是： 目录支持正则表达式 u，object_r,s0都是固定的 ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:3","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#上下文描述文件"},{"categories":[],"content":" 上下文描述文件在device/manufacturer/device-name/sepolicy中存在各种上下文描述文件，主要负责为target打标签。 列举 file_contexts用于为文件分配标签，并且可供多种用户空间时用。 genfs_contexts用于为不支持扩展属性的文件系统分配标签。 property_contexts用于为Android系统属性分配标签，以便控制那些进程可以为设置这些属性。再启动期间，init进程会读取这些配置。 service_contexts用于为Android Binder服务分配标签，以便控制那些进程可以为相应服务添加（注册）和查找Binder引用。在启动期间，servicemanager进程会读取此配置。 seapp_contexts用于为应用进程和/data/data目录分配标签。在每次应用启动时，zygote进程都会读取此配置；在启动期间，installd会读取此配置。 mac_permissions.xml用于根据应用签名和应用软件包名称为应用分配seinfo标记。分配的seinfo标记可在seapp_contexts文件中用做密钥，以便为带有该seinfo标记的所有应用分配特定标签。在启动期间，sestem_server会读取此配置。 格式我们打开file_contexts文件，查看一下格式： /mnt/vendor/crypto(/.*)? u:object_r:mnt_vendor_crypto_file:s0 /(vendor|system/vendor)/bin/delete7dayslog.sh u:object_r:delete_seven_day_log-sh_exec:s0 就是目录+标签的方式，看起来很像host的定义。 这里要注意的是： 目录支持正则表达式 u，object_r,s0都是固定的 ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:3","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#列举"},{"categories":[],"content":" 上下文描述文件在device/manufacturer/device-name/sepolicy中存在各种上下文描述文件，主要负责为target打标签。 列举 file_contexts用于为文件分配标签，并且可供多种用户空间时用。 genfs_contexts用于为不支持扩展属性的文件系统分配标签。 property_contexts用于为Android系统属性分配标签，以便控制那些进程可以为设置这些属性。再启动期间，init进程会读取这些配置。 service_contexts用于为Android Binder服务分配标签，以便控制那些进程可以为相应服务添加（注册）和查找Binder引用。在启动期间，servicemanager进程会读取此配置。 seapp_contexts用于为应用进程和/data/data目录分配标签。在每次应用启动时，zygote进程都会读取此配置；在启动期间，installd会读取此配置。 mac_permissions.xml用于根据应用签名和应用软件包名称为应用分配seinfo标记。分配的seinfo标记可在seapp_contexts文件中用做密钥，以便为带有该seinfo标记的所有应用分配特定标签。在启动期间，sestem_server会读取此配置。 格式我们打开file_contexts文件，查看一下格式： /mnt/vendor/crypto(/.*)? u:object_r:mnt_vendor_crypto_file:s0 /(vendor|system/vendor)/bin/delete7dayslog.sh u:object_r:delete_seven_day_log-sh_exec:s0 就是目录+标签的方式，看起来很像host的定义。 这里要注意的是： 目录支持正则表达式 u，object_r,s0都是固定的 ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:3","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#格式-1"},{"categories":[],"content":" BoardConfig.mk当修改或添加了策略文件和上下文描述文件后，需要更新/device/manufacturer/device-name/BoardConfig.mk来引用生效。 eg: BOARD_SEPOLICY_DIRS += \\ \u003croot\u003e/device/manufacturer/device-name/sepolicy BOARD_SEPOLICY_UNION += \\ genfs_contexts \\ file_contexts \\ sepolicy.te 最后需要需要重新编译才能生效！ ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:4","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#boardconfigmk"},{"categories":[],"content":" 启动用SELinux 在内核中启用（eg:在kernel/msm-5.4/kernel/configs/android-base.config）中配置：CONFIG_SECURITY_SELINUX=y; 更改Kernel_cmdline参数：BOARD_KERNEL_CMDLINE := androidboot.selinux=permissive,发版前应该移除此参数以变更为强制模式； ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:5","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#启动用selinux"},{"categories":[],"content":" 查看开机时的拒绝事件 adb root adb shell dmesg | grep audit | grep av 返回： [ 1.979517] audit: type=1400 audit(1.969:4): avc: denied { relabelfrom } for pid=261 comm=\"init\" name=\"/\" dev=\"tmpfs\" ino=10968 scontext=u:r:vendor_init:s0 tcontext=u:object_r:tmpfs:s0 tclass=dir permissive=0 ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:6","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#查看开机时的拒绝事件"},{"categories":[],"content":" 查看SContext标准的SContext格式如下： user:role:type[:range] User:用户，这里的用户并非linux的UID; Role：角色，不同的Role具有不同的权限； Type:Subject或者Object的类型，对于进程来说，type就是domain。 Range：MSL级别。MLS将系统的进程和文件进行了分级，不同级别的资源需要对应级别的进程才能访问。 文件的SContext命令：ls -Z u:object_r:system_file:s0 system u:该文件的SELinux用户,在SEAndroid中只有一个SELinux用户，就是u； object_r:角色，这里的object_r表示固定不变的东西，如文件，在SEAndroid中只定义了两个role，适用于主题的r和适用于对象的object_r； system_file:类型，这里表示system目录的类型； s0:MLS的敏感度，默认就是s0。 进程的SContext命令：ps -Z LABEL USER PID PPID VSZ RSS WCHAN ADDR S NAME u:r:su:s0 root 25497 8935 9320 3144 sigsuspend 0 S sh u:r:su:s0 root 27256 25497 11788 3128 0 0 R ps 最左侧LABEL这一列就是进程的SContext： u:就是SELinux用户（user）； r:为角色（role），相当于用户组； su:代表该进程所属的域为SU; s0:MLS级别。 ==================================================to be continue======== ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:7","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#查看scontext"},{"categories":[],"content":" 查看SContext标准的SContext格式如下： user:role:type[:range] User:用户，这里的用户并非linux的UID; Role：角色，不同的Role具有不同的权限； Type:Subject或者Object的类型，对于进程来说，type就是domain。 Range：MSL级别。MLS将系统的进程和文件进行了分级，不同级别的资源需要对应级别的进程才能访问。 文件的SContext命令：ls -Z u:object_r:system_file:s0 system u:该文件的SELinux用户,在SEAndroid中只有一个SELinux用户，就是u； object_r:角色，这里的object_r表示固定不变的东西，如文件，在SEAndroid中只定义了两个role，适用于主题的r和适用于对象的object_r； system_file:类型，这里表示system目录的类型； s0:MLS的敏感度，默认就是s0。 进程的SContext命令：ps -Z LABEL USER PID PPID VSZ RSS WCHAN ADDR S NAME u:r:su:s0 root 25497 8935 9320 3144 sigsuspend 0 S sh u:r:su:s0 root 27256 25497 11788 3128 0 0 R ps 最左侧LABEL这一列就是进程的SContext： u:就是SELinux用户（user）； r:为角色（role），相当于用户组； su:代表该进程所属的域为SU; s0:MLS级别。 ==================================================to be continue======== ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:7","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#文件的scontext"},{"categories":[],"content":" 查看SContext标准的SContext格式如下： user:role:type[:range] User:用户，这里的用户并非linux的UID; Role：角色，不同的Role具有不同的权限； Type:Subject或者Object的类型，对于进程来说，type就是domain。 Range：MSL级别。MLS将系统的进程和文件进行了分级，不同级别的资源需要对应级别的进程才能访问。 文件的SContext命令：ls -Z u:object_r:system_file:s0 system u:该文件的SELinux用户,在SEAndroid中只有一个SELinux用户，就是u； object_r:角色，这里的object_r表示固定不变的东西，如文件，在SEAndroid中只定义了两个role，适用于主题的r和适用于对象的object_r； system_file:类型，这里表示system目录的类型； s0:MLS的敏感度，默认就是s0。 进程的SContext命令：ps -Z LABEL USER PID PPID VSZ RSS WCHAN ADDR S NAME u:r:su:s0 root 25497 8935 9320 3144 sigsuspend 0 S sh u:r:su:s0 root 27256 25497 11788 3128 0 0 R ps 最左侧LABEL这一列就是进程的SContext： u:就是SELinux用户（user）； r:为角色（role），相当于用户组； su:代表该进程所属的域为SU; s0:MLS级别。 ==================================================to be continue======== ","date":"2022-12-12","objectID":"/selinux%E5%92%8Cseandroid/:0:7","series":[],"tags":[],"title":"SELinux和SEAndroid","uri":"/selinux%E5%92%8Cseandroid/#进程的scontext"},{"categories":[],"content":" 编译方式 基于Make的ndk-build CMake 独立工具链 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:1:0","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#编译方式"},{"categories":[],"content":" ndk-build方式ndk-build是基于make的编译工具，需要通过Android.mk和Application.mk来配置。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:2:0","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#ndk-build方式"},{"categories":[],"content":" 内部原理运行ndk-build脚本相当于运行了以下命令： $GNUMAKE -f \u003cndk\u003e/build/core/build-local.mk \u003cparameters\u003e $GNUMAKE 指向 GNU Make 3.81 或更高版本， 则指向 NDK 安装目录。您可以根据这些信息从其他 Shell 脚本（甚至是您自己的 Make 文件）中调用 ndk-build。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:2:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#内部原理"},{"categories":[],"content":" 使用 $ cd \u003cproject\u003e $ \u003cndk安装目录\u003e/ndk-build [option] option mean clean 清除之前的产物 V=1 启动构建 -B V=1 强行执行完整的构建并显示 NDK_APPLICATION_MK= 使用 NDK_APPLICATION_MK 变量指向的特定 Application.mk 文件进行构建 -C 指定项目路径 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:2:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#使用"},{"categories":[],"content":" Android.mk讲解 之前学习AOSP的时候，google说这货已经废弃了，在aosp中用Android.bp逐渐替代。但是我一直找不到bp的相关文档，现在才只知道bp文件里面那些shared_library这些都是直接从Android.mk中继承来的，我不学mk，就不会写bp！现在学习ndk时发现在AS创建项目时默认使用CMake，而CMake用的是CMakeLists.txt，我去你XX的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:3:0","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#androidmk讲解"},{"categories":[],"content":" 用途 配置项目和指定Application.mk文件。 模块化，Android.mk的语法支持将源文件分组为模块，模块是静态库、动态库或独立的可执行文件。 因为Application.mk是在Android.mk中指定的，所以ndk-build中不需要指定前者，而需要指定后者，再通过后者找到前者。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:3:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#用途"},{"categories":[],"content":" 基础我从ndk目录中直接打开了一个Android.mk文件如下： # 必须先定义这个变量，表示源文件在项目树中的位置，my-dir是ndk提供的宏，返回当前路径 LOCAL_PATH:= $(call my-dir) $(warning ndk_helper is no longer maintained in the NDK. This copy is left for \\ compatibility purposes only. For an up to date copy, see \\ https://github.com/googlesamples/android-ndk/tree/master/teapots/common/ndk_helper) # CLEAR_VARS指针指向一个特殊的GNU Makefile，可以清除LOCAL_XXX变量 include $(CLEAR_VARS) # 指定模块的名称，每个模块名称唯一且不含空格，产物以这个值来命名 LOCAL_MODULE:= ndk_helper变量 # 列举源文件，以空格分割 LOCAL_SRC_FILES:= JNIHelper.cpp interpolator.cpp tapCamera.cpp gestureDetector.cpp perfMonitor.cpp vecmath.cpp GLContext.cpp shader.cpp gl3stub.c # 变量 LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH) # 变量 LOCAL_EXPORT_LDLIBS := -llog -landroid -lEGL -lGLESv2 # 变量 LOCAL_STATIC_LIBRARIES := cpufeatures android_native_app_glue # BUILD_STATIC_LIBRARY变量指向一个Makefile脚本，用来收集最近include以来在LOCAL_XXX变量中定义的信息 include $(BUILD_STATIC_LIBRARY) #$(call import-module,android/native_app_glue) #$(call import-module,android/cpufeatures) ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:3:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#基础"},{"categories":[],"content":" 变量变量分为： ndk内置变量：以LOCAL_、PRIVATE_、NDK_、APP_开头的和部分小写字母变量； 自定义变量，推荐以MY_开头。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:0","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#变量"},{"categories":[],"content":" NDK定义的include变量 CLEAR_VARS用来取消所有LOCAL_XXX变量。 比如：LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 include $(CLEAR_VARS) 不会取消LOCAL_PATH。 BUILD_EXECUTABLE用于构建可执行文件。 include $(BUILD_EXECUTABLE) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_SHARED_LIBRARY用于构建动态库.so。 include $(BUILD_SHARED_LIBRARY) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_STATIC_LIBRARY用于编译静态库.a。 include $(BUILD_STATIC_LIBRARY) PREBUILT_SHARED_LIBRARY用于在编译动态库之前搞事情。 include $(PREBUILT_SHARED_LIBRARY) 这里的LOCAL_SRC_FILES不能是源文件，而是预构建共享库的路径，如：foo/libfoo.so。 也可以使用LOCAL_PREBUILTS变量引用另一个模块中的预构建库。 PREBUILT_STATIC_LIBRARY同上，用来在编译静态库之前搞事情的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#ndk定义的include变量"},{"categories":[],"content":" NDK定义的include变量 CLEAR_VARS用来取消所有LOCAL_XXX变量。 比如：LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 include $(CLEAR_VARS) 不会取消LOCAL_PATH。 BUILD_EXECUTABLE用于构建可执行文件。 include $(BUILD_EXECUTABLE) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_SHARED_LIBRARY用于构建动态库.so。 include $(BUILD_SHARED_LIBRARY) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_STATIC_LIBRARY用于编译静态库.a。 include $(BUILD_STATIC_LIBRARY) PREBUILT_SHARED_LIBRARY用于在编译动态库之前搞事情。 include $(PREBUILT_SHARED_LIBRARY) 这里的LOCAL_SRC_FILES不能是源文件，而是预构建共享库的路径，如：foo/libfoo.so。 也可以使用LOCAL_PREBUILTS变量引用另一个模块中的预构建库。 PREBUILT_STATIC_LIBRARY同上，用来在编译静态库之前搞事情的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#clear_vars"},{"categories":[],"content":" NDK定义的include变量 CLEAR_VARS用来取消所有LOCAL_XXX变量。 比如：LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 include $(CLEAR_VARS) 不会取消LOCAL_PATH。 BUILD_EXECUTABLE用于构建可执行文件。 include $(BUILD_EXECUTABLE) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_SHARED_LIBRARY用于构建动态库.so。 include $(BUILD_SHARED_LIBRARY) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_STATIC_LIBRARY用于编译静态库.a。 include $(BUILD_STATIC_LIBRARY) PREBUILT_SHARED_LIBRARY用于在编译动态库之前搞事情。 include $(PREBUILT_SHARED_LIBRARY) 这里的LOCAL_SRC_FILES不能是源文件，而是预构建共享库的路径，如：foo/libfoo.so。 也可以使用LOCAL_PREBUILTS变量引用另一个模块中的预构建库。 PREBUILT_STATIC_LIBRARY同上，用来在编译静态库之前搞事情的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#build_executable"},{"categories":[],"content":" NDK定义的include变量 CLEAR_VARS用来取消所有LOCAL_XXX变量。 比如：LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 include $(CLEAR_VARS) 不会取消LOCAL_PATH。 BUILD_EXECUTABLE用于构建可执行文件。 include $(BUILD_EXECUTABLE) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_SHARED_LIBRARY用于构建动态库.so。 include $(BUILD_SHARED_LIBRARY) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_STATIC_LIBRARY用于编译静态库.a。 include $(BUILD_STATIC_LIBRARY) PREBUILT_SHARED_LIBRARY用于在编译动态库之前搞事情。 include $(PREBUILT_SHARED_LIBRARY) 这里的LOCAL_SRC_FILES不能是源文件，而是预构建共享库的路径，如：foo/libfoo.so。 也可以使用LOCAL_PREBUILTS变量引用另一个模块中的预构建库。 PREBUILT_STATIC_LIBRARY同上，用来在编译静态库之前搞事情的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#build_shared_library"},{"categories":[],"content":" NDK定义的include变量 CLEAR_VARS用来取消所有LOCAL_XXX变量。 比如：LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 include $(CLEAR_VARS) 不会取消LOCAL_PATH。 BUILD_EXECUTABLE用于构建可执行文件。 include $(BUILD_EXECUTABLE) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_SHARED_LIBRARY用于构建动态库.so。 include $(BUILD_SHARED_LIBRARY) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_STATIC_LIBRARY用于编译静态库.a。 include $(BUILD_STATIC_LIBRARY) PREBUILT_SHARED_LIBRARY用于在编译动态库之前搞事情。 include $(PREBUILT_SHARED_LIBRARY) 这里的LOCAL_SRC_FILES不能是源文件，而是预构建共享库的路径，如：foo/libfoo.so。 也可以使用LOCAL_PREBUILTS变量引用另一个模块中的预构建库。 PREBUILT_STATIC_LIBRARY同上，用来在编译静态库之前搞事情的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#build_static_library"},{"categories":[],"content":" NDK定义的include变量 CLEAR_VARS用来取消所有LOCAL_XXX变量。 比如：LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 include $(CLEAR_VARS) 不会取消LOCAL_PATH。 BUILD_EXECUTABLE用于构建可执行文件。 include $(BUILD_EXECUTABLE) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_SHARED_LIBRARY用于构建动态库.so。 include $(BUILD_SHARED_LIBRARY) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_STATIC_LIBRARY用于编译静态库.a。 include $(BUILD_STATIC_LIBRARY) PREBUILT_SHARED_LIBRARY用于在编译动态库之前搞事情。 include $(PREBUILT_SHARED_LIBRARY) 这里的LOCAL_SRC_FILES不能是源文件，而是预构建共享库的路径，如：foo/libfoo.so。 也可以使用LOCAL_PREBUILTS变量引用另一个模块中的预构建库。 PREBUILT_STATIC_LIBRARY同上，用来在编译静态库之前搞事情的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#prebuilt_shared_library"},{"categories":[],"content":" NDK定义的include变量 CLEAR_VARS用来取消所有LOCAL_XXX变量。 比如：LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 include $(CLEAR_VARS) 不会取消LOCAL_PATH。 BUILD_EXECUTABLE用于构建可执行文件。 include $(BUILD_EXECUTABLE) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_SHARED_LIBRARY用于构建动态库.so。 include $(BUILD_SHARED_LIBRARY) 需要： LOCAL_MODULE LOCAL_SRC_FILES BUILD_STATIC_LIBRARY用于编译静态库.a。 include $(BUILD_STATIC_LIBRARY) PREBUILT_SHARED_LIBRARY用于在编译动态库之前搞事情。 include $(PREBUILT_SHARED_LIBRARY) 这里的LOCAL_SRC_FILES不能是源文件，而是预构建共享库的路径，如：foo/libfoo.so。 也可以使用LOCAL_PREBUILTS变量引用另一个模块中的预构建库。 PREBUILT_STATIC_LIBRARY同上，用来在编译静态库之前搞事情的。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#prebuilt_static_library"},{"categories":[],"content":" 目标信息变量 APP_ABI我们可以在Android.mk中定义一个APP_ABI变量指定编译的ABI（一个或多个），构建系统会根据这货来解析Android.mk，指定的ABI月多4则解析次数也越多。 TARGET_ARCH定义支持的cpu架构： arm arm64 x86 x86_64 TARGET_PLATFORM定义支持的Android API级别号: android-1 android-2 android-3 android-28 ifeq ($(TARGET_PLATFORM),android-22) # ... do something ... endif TARGET_ARCH_ABI用来指定ABI： CPU架构 ABI ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i686 x86 x86-64 x86_64 ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ... endif TARGET_ABI用来指定特定设备，说白了就是TARGET_PLATFORM-TARGET_ARCH_ABI的形式： ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ... endif ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#目标信息变量"},{"categories":[],"content":" 目标信息变量 APP_ABI我们可以在Android.mk中定义一个APP_ABI变量指定编译的ABI（一个或多个），构建系统会根据这货来解析Android.mk，指定的ABI月多4则解析次数也越多。 TARGET_ARCH定义支持的cpu架构： arm arm64 x86 x86_64 TARGET_PLATFORM定义支持的Android API级别号: android-1 android-2 android-3 android-28 ifeq ($(TARGET_PLATFORM),android-22) # ... do something ... endif TARGET_ARCH_ABI用来指定ABI： CPU架构 ABI ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i686 x86 x86-64 x86_64 ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ... endif TARGET_ABI用来指定特定设备，说白了就是TARGET_PLATFORM-TARGET_ARCH_ABI的形式： ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ... endif ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#app_abi"},{"categories":[],"content":" 目标信息变量 APP_ABI我们可以在Android.mk中定义一个APP_ABI变量指定编译的ABI（一个或多个），构建系统会根据这货来解析Android.mk，指定的ABI月多4则解析次数也越多。 TARGET_ARCH定义支持的cpu架构： arm arm64 x86 x86_64 TARGET_PLATFORM定义支持的Android API级别号: android-1 android-2 android-3 android-28 ifeq ($(TARGET_PLATFORM),android-22) # ... do something ... endif TARGET_ARCH_ABI用来指定ABI： CPU架构 ABI ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i686 x86 x86-64 x86_64 ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ... endif TARGET_ABI用来指定特定设备，说白了就是TARGET_PLATFORM-TARGET_ARCH_ABI的形式： ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ... endif ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#target_arch"},{"categories":[],"content":" 目标信息变量 APP_ABI我们可以在Android.mk中定义一个APP_ABI变量指定编译的ABI（一个或多个），构建系统会根据这货来解析Android.mk，指定的ABI月多4则解析次数也越多。 TARGET_ARCH定义支持的cpu架构： arm arm64 x86 x86_64 TARGET_PLATFORM定义支持的Android API级别号: android-1 android-2 android-3 android-28 ifeq ($(TARGET_PLATFORM),android-22) # ... do something ... endif TARGET_ARCH_ABI用来指定ABI： CPU架构 ABI ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i686 x86 x86-64 x86_64 ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ... endif TARGET_ABI用来指定特定设备，说白了就是TARGET_PLATFORM-TARGET_ARCH_ABI的形式： ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ... endif ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#target_platform"},{"categories":[],"content":" 目标信息变量 APP_ABI我们可以在Android.mk中定义一个APP_ABI变量指定编译的ABI（一个或多个），构建系统会根据这货来解析Android.mk，指定的ABI月多4则解析次数也越多。 TARGET_ARCH定义支持的cpu架构： arm arm64 x86 x86_64 TARGET_PLATFORM定义支持的Android API级别号: android-1 android-2 android-3 android-28 ifeq ($(TARGET_PLATFORM),android-22) # ... do something ... endif TARGET_ARCH_ABI用来指定ABI： CPU架构 ABI ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i686 x86 x86-64 x86_64 ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ... endif TARGET_ABI用来指定特定设备，说白了就是TARGET_PLATFORM-TARGET_ARCH_ABI的形式： ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ... endif ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#target_arch_abi"},{"categories":[],"content":" 目标信息变量 APP_ABI我们可以在Android.mk中定义一个APP_ABI变量指定编译的ABI（一个或多个），构建系统会根据这货来解析Android.mk，指定的ABI月多4则解析次数也越多。 TARGET_ARCH定义支持的cpu架构： arm arm64 x86 x86_64 TARGET_PLATFORM定义支持的Android API级别号: android-1 android-2 android-3 android-28 ifeq ($(TARGET_PLATFORM),android-22) # ... do something ... endif TARGET_ARCH_ABI用来指定ABI： CPU架构 ABI ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i686 x86 x86-64 x86_64 ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ... endif TARGET_ABI用来指定特定设备，说白了就是TARGET_PLATFORM-TARGET_ARCH_ABI的形式： ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ... endif ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#target_abi"},{"categories":[],"content":" 模块描述变量（重点） LOCAL_PATH用于指定当前文件的路径，必须在Android.mk文件的开头定义此变量。 LOCAL_PATH := $(call my-dir) 不会被CLEAR_VARS指向的脚本清掉。 LOCAL_MODULE模块名称。 LOCAL_MODULE := foo LOCAL_MODULE_FILENAME := libnewfoo 产物默认使用模块名称来命名，如果需要单独命名产物，则可以使用LOCAL_MODULE_FILENAME变量。 上面代码中编译出来的产物就是libnewfoo.so。 LOCAL_SRC_FILES用来指定构建编译的源文件列表，只需要列出构建时世纪传递到编译器的文件，构建系统会自动处理依赖关系，所以一般给这个变量指定一个入口文件就够了。 推荐使用相对路径。 LOCAL_CPP_EXTENSION可以使用此可选变量为 C++ 源文件指定 .cpp 以外的文件扩展名。 LOCAL_CPP_EXTENSION := .cxx 没啥用。 LOCAL_CPP_FEATURES太复杂，看不明白，后面需要再捋一下文档 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:3","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#模块描述变量重点"},{"categories":[],"content":" 模块描述变量（重点） LOCAL_PATH用于指定当前文件的路径，必须在Android.mk文件的开头定义此变量。 LOCAL_PATH := $(call my-dir) 不会被CLEAR_VARS指向的脚本清掉。 LOCAL_MODULE模块名称。 LOCAL_MODULE := foo LOCAL_MODULE_FILENAME := libnewfoo 产物默认使用模块名称来命名，如果需要单独命名产物，则可以使用LOCAL_MODULE_FILENAME变量。 上面代码中编译出来的产物就是libnewfoo.so。 LOCAL_SRC_FILES用来指定构建编译的源文件列表，只需要列出构建时世纪传递到编译器的文件，构建系统会自动处理依赖关系，所以一般给这个变量指定一个入口文件就够了。 推荐使用相对路径。 LOCAL_CPP_EXTENSION可以使用此可选变量为 C++ 源文件指定 .cpp 以外的文件扩展名。 LOCAL_CPP_EXTENSION := .cxx 没啥用。 LOCAL_CPP_FEATURES太复杂，看不明白，后面需要再捋一下文档 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:3","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#local_path"},{"categories":[],"content":" 模块描述变量（重点） LOCAL_PATH用于指定当前文件的路径，必须在Android.mk文件的开头定义此变量。 LOCAL_PATH := $(call my-dir) 不会被CLEAR_VARS指向的脚本清掉。 LOCAL_MODULE模块名称。 LOCAL_MODULE := foo LOCAL_MODULE_FILENAME := libnewfoo 产物默认使用模块名称来命名，如果需要单独命名产物，则可以使用LOCAL_MODULE_FILENAME变量。 上面代码中编译出来的产物就是libnewfoo.so。 LOCAL_SRC_FILES用来指定构建编译的源文件列表，只需要列出构建时世纪传递到编译器的文件，构建系统会自动处理依赖关系，所以一般给这个变量指定一个入口文件就够了。 推荐使用相对路径。 LOCAL_CPP_EXTENSION可以使用此可选变量为 C++ 源文件指定 .cpp 以外的文件扩展名。 LOCAL_CPP_EXTENSION := .cxx 没啥用。 LOCAL_CPP_FEATURES太复杂，看不明白，后面需要再捋一下文档 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:3","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#local_module"},{"categories":[],"content":" 模块描述变量（重点） LOCAL_PATH用于指定当前文件的路径，必须在Android.mk文件的开头定义此变量。 LOCAL_PATH := $(call my-dir) 不会被CLEAR_VARS指向的脚本清掉。 LOCAL_MODULE模块名称。 LOCAL_MODULE := foo LOCAL_MODULE_FILENAME := libnewfoo 产物默认使用模块名称来命名，如果需要单独命名产物，则可以使用LOCAL_MODULE_FILENAME变量。 上面代码中编译出来的产物就是libnewfoo.so。 LOCAL_SRC_FILES用来指定构建编译的源文件列表，只需要列出构建时世纪传递到编译器的文件，构建系统会自动处理依赖关系，所以一般给这个变量指定一个入口文件就够了。 推荐使用相对路径。 LOCAL_CPP_EXTENSION可以使用此可选变量为 C++ 源文件指定 .cpp 以外的文件扩展名。 LOCAL_CPP_EXTENSION := .cxx 没啥用。 LOCAL_CPP_FEATURES太复杂，看不明白，后面需要再捋一下文档 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:3","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#local_src_files"},{"categories":[],"content":" 模块描述变量（重点） LOCAL_PATH用于指定当前文件的路径，必须在Android.mk文件的开头定义此变量。 LOCAL_PATH := $(call my-dir) 不会被CLEAR_VARS指向的脚本清掉。 LOCAL_MODULE模块名称。 LOCAL_MODULE := foo LOCAL_MODULE_FILENAME := libnewfoo 产物默认使用模块名称来命名，如果需要单独命名产物，则可以使用LOCAL_MODULE_FILENAME变量。 上面代码中编译出来的产物就是libnewfoo.so。 LOCAL_SRC_FILES用来指定构建编译的源文件列表，只需要列出构建时世纪传递到编译器的文件，构建系统会自动处理依赖关系，所以一般给这个变量指定一个入口文件就够了。 推荐使用相对路径。 LOCAL_CPP_EXTENSION可以使用此可选变量为 C++ 源文件指定 .cpp 以外的文件扩展名。 LOCAL_CPP_EXTENSION := .cxx 没啥用。 LOCAL_CPP_FEATURES太复杂，看不明白，后面需要再捋一下文档 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:3","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#local_cpp_extension"},{"categories":[],"content":" 模块描述变量（重点） LOCAL_PATH用于指定当前文件的路径，必须在Android.mk文件的开头定义此变量。 LOCAL_PATH := $(call my-dir) 不会被CLEAR_VARS指向的脚本清掉。 LOCAL_MODULE模块名称。 LOCAL_MODULE := foo LOCAL_MODULE_FILENAME := libnewfoo 产物默认使用模块名称来命名，如果需要单独命名产物，则可以使用LOCAL_MODULE_FILENAME变量。 上面代码中编译出来的产物就是libnewfoo.so。 LOCAL_SRC_FILES用来指定构建编译的源文件列表，只需要列出构建时世纪传递到编译器的文件，构建系统会自动处理依赖关系，所以一般给这个变量指定一个入口文件就够了。 推荐使用相对路径。 LOCAL_CPP_EXTENSION可以使用此可选变量为 C++ 源文件指定 .cpp 以外的文件扩展名。 LOCAL_CPP_EXTENSION := .cxx 没啥用。 LOCAL_CPP_FEATURES太复杂，看不明白，后面需要再捋一下文档 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:4:3","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#local_cpp_features"},{"categories":[],"content":" 宏宏就是NDK提供的内置函数。 可以使用$(call \u003cfunction\u003e)方式调用宏，返回字符串。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:5:0","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#宏"},{"categories":[],"content":" my-dir这个宏返回最后包括的 makefile 的路径，通常是当前 Android.mk 的目录。 但是有时候重复调用就会出问题，比如: LOCAL_PATH := $(call my-dir) # ... declare one module # 你看这里，我include了一个也带有makefile的LOCAL_PATH include $(LOCAL_PATH)/foo/`Android.mk` # 再调用my-dir的话，路径就成了LOCAL—PATH的值了 LOCAL_PATH := $(call my-dir) # 所以我们也可以在此include回原来的路径来解决这个问题🦐 include $(LOCAL_PATH)/foo/Android.mk # ... declare another module ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:5:1","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#my-dir"},{"categories":[],"content":" all-subdir-makefiles返回位于当前 my-dir 路径所有子目录中的 Android.mk 文件列表。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:5:2","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#all-subdir-makefiles"},{"categories":[],"content":" this-makefile返回当前 makefile（构建系统从中调用函数）的路径。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:5:3","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#this-makefile"},{"categories":[],"content":" parent-makefile返回包含树中父 makefile 的路径（包含当前 makefile 的 makefile 的路径）。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:5:4","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#parent-makefile"},{"categories":[],"content":" grand-parent-makefile返回包含树中祖父 makefile 的路径（包含当前父 makefile 的 makefile 的路径）。 ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:5:5","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#grand-parent-makefile"},{"categories":[],"content":" import-module用来导入模块（会自动导入目标模块的Android.mk） $(call import-module,\u003cname\u003e) ","date":"2022-10-28","objectID":"/ndk%E7%BC%96%E8%AF%91/:5:6","series":[],"tags":[],"title":"Android.mk与ndk-build","uri":"/ndk%E7%BC%96%E8%AF%91/#import-module"},{"categories":[],"content":" 基本语法 // 引入头文件,这个是所有C语言编译器的标准部分，用来提供输入和输出的支持。 // include语句是C的预处理器指令，#符号标注的不是c的语句，而是表示在编译之前，由预处理器来处理的语句。 #include\u003cstdio.h\u003e //主函数 //返回值是返回给操作系统的 int main(void){ int number; number = 2014; printf(\"Hello ! I am dotcpp.com\\n\"); print(\"This tear is %d\\n\",number); return 0; } 变量名区分大小写，允许大小写字母、数字、下划线，第一个字符不能是数字。 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:1","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#基本语法"},{"categories":[],"content":" 数据类型 类型 关键字 占用字节数 字符 char 1 无符号字符 unsignedchar 1 整数 int 4 无符号整数 unsigned int 4 短整数 short 2 无符号短整数 unsignved short 2 长整数 long 4 无符号长整数 unsigned long 4 单精度浮点 float 4 双精度浮点 double 8 长双精度浮点 long double 10 类型转换 (type_name) expression eg: (float) a; //将变量 a 转换为 float 类型 (int)(x+y); //把表达式 x+y 的结果转换为 int 整型 (float) 100; //将数值 100（默认为int类型）转换为 float 类型 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:2","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#数据类型"},{"categories":[],"content":" 数据类型 类型 关键字 占用字节数 字符 char 1 无符号字符 unsignedchar 1 整数 int 4 无符号整数 unsigned int 4 短整数 short 2 无符号短整数 unsignved short 2 长整数 long 4 无符号长整数 unsigned long 4 单精度浮点 float 4 双精度浮点 double 8 长双精度浮点 long double 10 类型转换 (type_name) expression eg: (float) a; //将变量 a 转换为 float 类型 (int)(x+y); //把表达式 x+y 的结果转换为 int 整型 (float) 100; //将数值 100（默认为int类型）转换为 float 类型 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:2","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#类型转换"},{"categories":[],"content":" 数组 类型说明符 数组名 [常量表达式]; int a[1000]={1,2,3,4,5}; float b[10]; int a[3][4]={ {1,2,3}, {10,20,30}}; ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:3","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#数组"},{"categories":[],"content":" 输入与输出 printf putchar输出单字符。 getchar接收键盘输入的一个字符到变量。 格式化打印 printf(\"格式控制字符串\",输出表项); 返回可打印的字符的数量，如果输出错误，将返回-1。 占位符 解释 d,i 以十进制形式输出有符号整数 O 以八进制形式输出无符号整数（不含前缀0） x 以十六进制形式输出无符号整数（不含前缀0x） U 以十进制形式输出无符号整数 f 以小鼠形式输出单、双精度实数 e 以指数形式输出单、双精度实数 g 以%f或%e中较短输出宽度的一种格式输出单、双精度实数 C 输出单字符 S 输出字符串 puts #include \u003cstdio.h\u003e int main(void) { char str[100] = \"www.dotcpp.com\"; printf(\"%s\\n\", str); puts(str); return 0; } ``` | #### 接收单字符输入 ```c char c;//定义个字符变量c c=getchar();//将读取到的字符赋值给字符变量c scanf scanf(\"格式控制字符串\",输入项地址列表); 格式控制字符串的作用于printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串；地址表项中的地址要给出变量的地址，由\u0026后跟变量名组成。 get # include \u003cstdio.h\u003e int main(void) { char str[100] = \"\\0\"; printf(\"请输入字符串：\\n\"); gets(str); printf(\"刚才输入的字符串是：\\n\"); printf(\"%s\\n\", str); return 0; } get方式不会对输入进行检查和验证，所以输入内容过长可能会造成OOM，所以并不安全。 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:4","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#输入与输出"},{"categories":[],"content":" 输入与输出 printf putchar输出单字符。 getchar接收键盘输入的一个字符到变量。 格式化打印 printf(\"格式控制字符串\",输出表项); 返回可打印的字符的数量，如果输出错误，将返回-1。 占位符 解释 d,i 以十进制形式输出有符号整数 O 以八进制形式输出无符号整数（不含前缀0） x 以十六进制形式输出无符号整数（不含前缀0x） U 以十进制形式输出无符号整数 f 以小鼠形式输出单、双精度实数 e 以指数形式输出单、双精度实数 g 以%f或%e中较短输出宽度的一种格式输出单、双精度实数 C 输出单字符 S 输出字符串 puts #include int main(void) { char str[100] = \"www.dotcpp.com\"; printf(\"%s\\n\", str); puts(str); return 0; } ``` | #### 接收单字符输入 ```c char c;//定义个字符变量c c=getchar();//将读取到的字符赋值给字符变量c scanf scanf(\"格式控制字符串\",输入项地址列表); 格式控制字符串的作用于printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串；地址表项中的地址要给出变量的地址，由\u0026后跟变量名组成。 get # include int main(void) { char str[100] = \"\\0\"; printf(\"请输入字符串：\\n\"); gets(str); printf(\"刚才输入的字符串是：\\n\"); printf(\"%s\\n\", str); return 0; } get方式不会对输入进行检查和验证，所以输入内容过长可能会造成OOM，所以并不安全。 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:4","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#格式化打印"},{"categories":[],"content":" 输入与输出 printf putchar输出单字符。 getchar接收键盘输入的一个字符到变量。 格式化打印 printf(\"格式控制字符串\",输出表项); 返回可打印的字符的数量，如果输出错误，将返回-1。 占位符 解释 d,i 以十进制形式输出有符号整数 O 以八进制形式输出无符号整数（不含前缀0） x 以十六进制形式输出无符号整数（不含前缀0x） U 以十进制形式输出无符号整数 f 以小鼠形式输出单、双精度实数 e 以指数形式输出单、双精度实数 g 以%f或%e中较短输出宽度的一种格式输出单、双精度实数 C 输出单字符 S 输出字符串 puts #include int main(void) { char str[100] = \"www.dotcpp.com\"; printf(\"%s\\n\", str); puts(str); return 0; } ``` | #### 接收单字符输入 ```c char c;//定义个字符变量c c=getchar();//将读取到的字符赋值给字符变量c scanf scanf(\"格式控制字符串\",输入项地址列表); 格式控制字符串的作用于printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串；地址表项中的地址要给出变量的地址，由\u0026后跟变量名组成。 get # include int main(void) { char str[100] = \"\\0\"; printf(\"请输入字符串：\\n\"); gets(str); printf(\"刚才输入的字符串是：\\n\"); printf(\"%s\\n\", str); return 0; } get方式不会对输入进行检查和验证，所以输入内容过长可能会造成OOM，所以并不安全。 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:4","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#puts"},{"categories":[],"content":" 输入与输出 printf putchar输出单字符。 getchar接收键盘输入的一个字符到变量。 格式化打印 printf(\"格式控制字符串\",输出表项); 返回可打印的字符的数量，如果输出错误，将返回-1。 占位符 解释 d,i 以十进制形式输出有符号整数 O 以八进制形式输出无符号整数（不含前缀0） x 以十六进制形式输出无符号整数（不含前缀0x） U 以十进制形式输出无符号整数 f 以小鼠形式输出单、双精度实数 e 以指数形式输出单、双精度实数 g 以%f或%e中较短输出宽度的一种格式输出单、双精度实数 C 输出单字符 S 输出字符串 puts #include int main(void) { char str[100] = \"www.dotcpp.com\"; printf(\"%s\\n\", str); puts(str); return 0; } ``` | #### 接收单字符输入 ```c char c;//定义个字符变量c c=getchar();//将读取到的字符赋值给字符变量c scanf scanf(\"格式控制字符串\",输入项地址列表); 格式控制字符串的作用于printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串；地址表项中的地址要给出变量的地址，由\u0026后跟变量名组成。 get # include int main(void) { char str[100] = \"\\0\"; printf(\"请输入字符串：\\n\"); gets(str); printf(\"刚才输入的字符串是：\\n\"); printf(\"%s\\n\", str); return 0; } get方式不会对输入进行检查和验证，所以输入内容过长可能会造成OOM，所以并不安全。 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:4","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#scanf"},{"categories":[],"content":" 输入与输出 printf putchar输出单字符。 getchar接收键盘输入的一个字符到变量。 格式化打印 printf(\"格式控制字符串\",输出表项); 返回可打印的字符的数量，如果输出错误，将返回-1。 占位符 解释 d,i 以十进制形式输出有符号整数 O 以八进制形式输出无符号整数（不含前缀0） x 以十六进制形式输出无符号整数（不含前缀0x） U 以十进制形式输出无符号整数 f 以小鼠形式输出单、双精度实数 e 以指数形式输出单、双精度实数 g 以%f或%e中较短输出宽度的一种格式输出单、双精度实数 C 输出单字符 S 输出字符串 puts #include int main(void) { char str[100] = \"www.dotcpp.com\"; printf(\"%s\\n\", str); puts(str); return 0; } ``` | #### 接收单字符输入 ```c char c;//定义个字符变量c c=getchar();//将读取到的字符赋值给字符变量c scanf scanf(\"格式控制字符串\",输入项地址列表); 格式控制字符串的作用于printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串；地址表项中的地址要给出变量的地址，由\u0026后跟变量名组成。 get # include int main(void) { char str[100] = \"\\0\"; printf(\"请输入字符串：\\n\"); gets(str); printf(\"刚才输入的字符串是：\\n\"); printf(\"%s\\n\", str); return 0; } get方式不会对输入进行检查和验证，所以输入内容过长可能会造成OOM，所以并不安全。 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:4","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#get"},{"categories":[],"content":" sizeof运算符这玩意不是函数，而是c语言自带的32个关键字之一，叫做长度（求字节）运算符，用来计算类型或者变量占用内存的字节数。 由于不是函数，所以()并不是必须的，比如后面跟的是变量就可以省略()，而如果跟的是类型，则必须()。 #include\u003cstdio.h\u003e int main() { int n=0; int intsize = sizeof(int); printf(\"int sizeof is %d bytes\\n\",intsize); return 0; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:5","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#sizeof运算符"},{"categories":[],"content":" 三目运算符 2\u003e1?10:20 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:6","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#三目运算符"},{"categories":[],"content":" 逻辑语句 if语句 if(表达式) /*如果表达式成立，执行语句1否则继续判断表达式2*/ { //语句1 } else if(表达式2) /*如果表达式成立，执行语句2否则继续判断表达式3*/ { //语句2 } else /*如果以上表达式都不成立 则执行语句4*/ { //语句4 } switch语句 switch(表达式) /*首先计算表达式的值*/ { case 常量表达式1:语句1; break; case 常量表达式2:语句2; break; case 常量表达式3:语句3; break; // …… case 常量表达式n:语句n; default:语句n+1; } while循环 while(表达式) { 循环体语句 } dowhile循环 do { 循环体语句 }while(表达式); for循环 for(初始化表达式;判断表达式;更新表达式) { 循环体语句 continue; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:7","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#逻辑语句"},{"categories":[],"content":" 逻辑语句 if语句 if(表达式) /*如果表达式成立，执行语句1否则继续判断表达式2*/ { //语句1 } else if(表达式2) /*如果表达式成立，执行语句2否则继续判断表达式3*/ { //语句2 } else /*如果以上表达式都不成立 则执行语句4*/ { //语句4 } switch语句 switch(表达式) /*首先计算表达式的值*/ { case 常量表达式1:语句1; break; case 常量表达式2:语句2; break; case 常量表达式3:语句3; break; // …… case 常量表达式n:语句n; default:语句n+1; } while循环 while(表达式) { 循环体语句 } dowhile循环 do { 循环体语句 }while(表达式); for循环 for(初始化表达式;判断表达式;更新表达式) { 循环体语句 continue; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:7","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#if语句"},{"categories":[],"content":" 逻辑语句 if语句 if(表达式) /*如果表达式成立，执行语句1否则继续判断表达式2*/ { //语句1 } else if(表达式2) /*如果表达式成立，执行语句2否则继续判断表达式3*/ { //语句2 } else /*如果以上表达式都不成立 则执行语句4*/ { //语句4 } switch语句 switch(表达式) /*首先计算表达式的值*/ { case 常量表达式1:语句1; break; case 常量表达式2:语句2; break; case 常量表达式3:语句3; break; // …… case 常量表达式n:语句n; default:语句n+1; } while循环 while(表达式) { 循环体语句 } dowhile循环 do { 循环体语句 }while(表达式); for循环 for(初始化表达式;判断表达式;更新表达式) { 循环体语句 continue; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:7","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#switch语句"},{"categories":[],"content":" 逻辑语句 if语句 if(表达式) /*如果表达式成立，执行语句1否则继续判断表达式2*/ { //语句1 } else if(表达式2) /*如果表达式成立，执行语句2否则继续判断表达式3*/ { //语句2 } else /*如果以上表达式都不成立 则执行语句4*/ { //语句4 } switch语句 switch(表达式) /*首先计算表达式的值*/ { case 常量表达式1:语句1; break; case 常量表达式2:语句2; break; case 常量表达式3:语句3; break; // …… case 常量表达式n:语句n; default:语句n+1; } while循环 while(表达式) { 循环体语句 } dowhile循环 do { 循环体语句 }while(表达式); for循环 for(初始化表达式;判断表达式;更新表达式) { 循环体语句 continue; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:7","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#while循环"},{"categories":[],"content":" 逻辑语句 if语句 if(表达式) /*如果表达式成立，执行语句1否则继续判断表达式2*/ { //语句1 } else if(表达式2) /*如果表达式成立，执行语句2否则继续判断表达式3*/ { //语句2 } else /*如果以上表达式都不成立 则执行语句4*/ { //语句4 } switch语句 switch(表达式) /*首先计算表达式的值*/ { case 常量表达式1:语句1; break; case 常量表达式2:语句2; break; case 常量表达式3:语句3; break; // …… case 常量表达式n:语句n; default:语句n+1; } while循环 while(表达式) { 循环体语句 } dowhile循环 do { 循环体语句 }while(表达式); for循环 for(初始化表达式;判断表达式;更新表达式) { 循环体语句 continue; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:7","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#dowhile循环"},{"categories":[],"content":" 逻辑语句 if语句 if(表达式) /*如果表达式成立，执行语句1否则继续判断表达式2*/ { //语句1 } else if(表达式2) /*如果表达式成立，执行语句2否则继续判断表达式3*/ { //语句2 } else /*如果以上表达式都不成立 则执行语句4*/ { //语句4 } switch语句 switch(表达式) /*首先计算表达式的值*/ { case 常量表达式1:语句1; break; case 常量表达式2:语句2; break; case 常量表达式3:语句3; break; // …… case 常量表达式n:语句n; default:语句n+1; } while循环 while(表达式) { 循环体语句 } dowhile循环 do { 循环体语句 }while(表达式); for循环 for(初始化表达式;判断表达式;更新表达式) { 循环体语句 continue; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:7","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#for循环"},{"categories":[],"content":" 函数 返回值类型 函数名(形参表说明) /*函数首部*/ { 说明语句 /*函数体*/ 执行语句 } 注意：可以不指明返回值类型，这样系统默认返回整型。 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:8","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#函数"},{"categories":[],"content":" 变量储存从时间角度分为静态储存和动态储存两种： 静态储存，变量储存在内存的静态储存区，在编译时就分配了储存空间，在整个程序的运行期间，该变量占有固定的储存单元，在程序结束后，这部分空间才会释放，变量的值在整个程序中始终存在。 动态储存，变量在储存在内存的动态储存区，在程序的运行过程中，只有当变量所以在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值旨在函数调用期内存在。 变量的作用范围又分为局部变量和全局变量： 全局变量外部变量就是全局变量，是在函数外部定义的。他的作用于从变量定义处开始，到程序文件的末尾。如果在定义点之前的函数想饮用该外部变量，则应该在引用处用关键字extern对该变量进行声明，就可以合法的使用该变量了。 自动变量函数中的局部变量、函数中的形参，在调用时函数时系统会给他们分配储存空间，在函数调用后会自动释放这些空间，这类变量称为自动变量。 int fun(int a) { auto int b,c=3;/*定义b,c为自动变量*/ } 静态变量 #include\u003cstdio.h\u003e static a=5; int fun() { a=a*2; printf(\"a=%d\\n\",a); return 0; } int main() { int i=0; for(i=0;i\u003c10;i++) { fun(); } return 0; } 寄存器变量为提高效率，c语言允许将局部变量的值存放到cpu的寄存器中，叫做寄存器变量，用关键字register声明。 注意： 只有局部自动变量和形参可以作为寄存器变量。 一个计算机系统中的寄存器数量有限，不能定义任意多个寄存器变量。 不能使用地址运算符\u0026求寄存器变量的地址。 register int a=0;//将变量a存储在寄存器上 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:9","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#变量储存"},{"categories":[],"content":" 变量储存从时间角度分为静态储存和动态储存两种： 静态储存，变量储存在内存的静态储存区，在编译时就分配了储存空间，在整个程序的运行期间，该变量占有固定的储存单元，在程序结束后，这部分空间才会释放，变量的值在整个程序中始终存在。 动态储存，变量在储存在内存的动态储存区，在程序的运行过程中，只有当变量所以在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值旨在函数调用期内存在。 变量的作用范围又分为局部变量和全局变量： 全局变量外部变量就是全局变量，是在函数外部定义的。他的作用于从变量定义处开始，到程序文件的末尾。如果在定义点之前的函数想饮用该外部变量，则应该在引用处用关键字extern对该变量进行声明，就可以合法的使用该变量了。 自动变量函数中的局部变量、函数中的形参，在调用时函数时系统会给他们分配储存空间，在函数调用后会自动释放这些空间，这类变量称为自动变量。 int fun(int a) { auto int b,c=3;/*定义b,c为自动变量*/ } 静态变量 #include static a=5; int fun() { a=a*2; printf(\"a=%d\\n\",a); return 0; } int main() { int i=0; for(i=0;i\u003c10;i++) { fun(); } return 0; } 寄存器变量为提高效率，c语言允许将局部变量的值存放到cpu的寄存器中，叫做寄存器变量，用关键字register声明。 注意： 只有局部自动变量和形参可以作为寄存器变量。 一个计算机系统中的寄存器数量有限，不能定义任意多个寄存器变量。 不能使用地址运算符\u0026求寄存器变量的地址。 register int a=0;//将变量a存储在寄存器上 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:9","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#全局变量"},{"categories":[],"content":" 变量储存从时间角度分为静态储存和动态储存两种： 静态储存，变量储存在内存的静态储存区，在编译时就分配了储存空间，在整个程序的运行期间，该变量占有固定的储存单元，在程序结束后，这部分空间才会释放，变量的值在整个程序中始终存在。 动态储存，变量在储存在内存的动态储存区，在程序的运行过程中，只有当变量所以在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值旨在函数调用期内存在。 变量的作用范围又分为局部变量和全局变量： 全局变量外部变量就是全局变量，是在函数外部定义的。他的作用于从变量定义处开始，到程序文件的末尾。如果在定义点之前的函数想饮用该外部变量，则应该在引用处用关键字extern对该变量进行声明，就可以合法的使用该变量了。 自动变量函数中的局部变量、函数中的形参，在调用时函数时系统会给他们分配储存空间，在函数调用后会自动释放这些空间，这类变量称为自动变量。 int fun(int a) { auto int b,c=3;/*定义b,c为自动变量*/ } 静态变量 #include static a=5; int fun() { a=a*2; printf(\"a=%d\\n\",a); return 0; } int main() { int i=0; for(i=0;i\u003c10;i++) { fun(); } return 0; } 寄存器变量为提高效率，c语言允许将局部变量的值存放到cpu的寄存器中，叫做寄存器变量，用关键字register声明。 注意： 只有局部自动变量和形参可以作为寄存器变量。 一个计算机系统中的寄存器数量有限，不能定义任意多个寄存器变量。 不能使用地址运算符\u0026求寄存器变量的地址。 register int a=0;//将变量a存储在寄存器上 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:9","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#自动变量"},{"categories":[],"content":" 变量储存从时间角度分为静态储存和动态储存两种： 静态储存，变量储存在内存的静态储存区，在编译时就分配了储存空间，在整个程序的运行期间，该变量占有固定的储存单元，在程序结束后，这部分空间才会释放，变量的值在整个程序中始终存在。 动态储存，变量在储存在内存的动态储存区，在程序的运行过程中，只有当变量所以在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值旨在函数调用期内存在。 变量的作用范围又分为局部变量和全局变量： 全局变量外部变量就是全局变量，是在函数外部定义的。他的作用于从变量定义处开始，到程序文件的末尾。如果在定义点之前的函数想饮用该外部变量，则应该在引用处用关键字extern对该变量进行声明，就可以合法的使用该变量了。 自动变量函数中的局部变量、函数中的形参，在调用时函数时系统会给他们分配储存空间，在函数调用后会自动释放这些空间，这类变量称为自动变量。 int fun(int a) { auto int b,c=3;/*定义b,c为自动变量*/ } 静态变量 #include static a=5; int fun() { a=a*2; printf(\"a=%d\\n\",a); return 0; } int main() { int i=0; for(i=0;i\u003c10;i++) { fun(); } return 0; } 寄存器变量为提高效率，c语言允许将局部变量的值存放到cpu的寄存器中，叫做寄存器变量，用关键字register声明。 注意： 只有局部自动变量和形参可以作为寄存器变量。 一个计算机系统中的寄存器数量有限，不能定义任意多个寄存器变量。 不能使用地址运算符\u0026求寄存器变量的地址。 register int a=0;//将变量a存储在寄存器上 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:9","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#静态变量"},{"categories":[],"content":" 变量储存从时间角度分为静态储存和动态储存两种： 静态储存，变量储存在内存的静态储存区，在编译时就分配了储存空间，在整个程序的运行期间，该变量占有固定的储存单元，在程序结束后，这部分空间才会释放，变量的值在整个程序中始终存在。 动态储存，变量在储存在内存的动态储存区，在程序的运行过程中，只有当变量所以在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值旨在函数调用期内存在。 变量的作用范围又分为局部变量和全局变量： 全局变量外部变量就是全局变量，是在函数外部定义的。他的作用于从变量定义处开始，到程序文件的末尾。如果在定义点之前的函数想饮用该外部变量，则应该在引用处用关键字extern对该变量进行声明，就可以合法的使用该变量了。 自动变量函数中的局部变量、函数中的形参，在调用时函数时系统会给他们分配储存空间，在函数调用后会自动释放这些空间，这类变量称为自动变量。 int fun(int a) { auto int b,c=3;/*定义b,c为自动变量*/ } 静态变量 #include static a=5; int fun() { a=a*2; printf(\"a=%d\\n\",a); return 0; } int main() { int i=0; for(i=0;i\u003c10;i++) { fun(); } return 0; } 寄存器变量为提高效率，c语言允许将局部变量的值存放到cpu的寄存器中，叫做寄存器变量，用关键字register声明。 注意： 只有局部自动变量和形参可以作为寄存器变量。 一个计算机系统中的寄存器数量有限，不能定义任意多个寄存器变量。 不能使用地址运算符\u0026求寄存器变量的地址。 register int a=0;//将变量a存储在寄存器上 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:9","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#寄存器变量"},{"categories":[],"content":" 指针用\u0026符号表示指针或引用地址，用*符号获取指针对应的值。 #include\u003cstdio.h\u003e int main() { int num=2014; int *p=\u0026num; printf(\"num Address = 0x%x,num=%d\\n\",\u0026num,num); printf(\"p = 0x%x,*p=%d\\n\",p,*p); printf(\"%d\\n\",*\u0026num); return 0; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:10","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#指针"},{"categories":[],"content":" 字符串处理字符串初始化： char *str = \"www.dotcpp.com\" ; 可以用字符串常量对指针进行初始化。 函数 用途 strcpy 实现两个字符串的拷贝 strcat 实现两个字符串的拼接 strcmp 对比两个字符串是否相等 strlen 计算字符串长度 ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:11","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#字符串处理"},{"categories":[],"content":" 结构体声明： struct 结构类型名 { 数据类型 成员名 1; 数据类型 成员名 2; ...... 数据类型 成员名 n; }; 初始化： struct 结构类型名 结构变量 = { 初始化数据 1, ...... 初始化数据 n }; 示例： #include\u003cstdio.h\u003e #include\u003cstring.h\u003e struct _INFO { int num; char str[256]; }; int main() { struct _INFO A; A.num = 2014; strcpy(A.str,\"Welcome to dotcpp.com\"); printf(\"This year is %d %s\\n\",A.num,A.str); return 0; } 结构体指针结构体变量用.来访问成员，而结构体指针用-\u003e来访问。 示例： #include\u003cstdio.h\u003e struct address { char name[30]; /*姓名，字符数组作为结构体中的成员*/ char street[40]; /*街道*/ unsigned long tel; /*电话，无符号长整型作为结构体中的成员*/ unsigned long zip; /*邮政编码*/ }; int main() { struct address A[3]={\"Zhang\",\"Road NO.1\",111111,4444}, {\"Wang\",\" Road NO.2\",222222,5555}, {\"Li\",\" Road NO.3\",333333,6666}}; struct address *p; p=\u0026A[0]; printf(\"%s %s %u %u\\n\",p-\u003ename,p-\u003estreet,p-\u003etel,p-\u003ezip); return 0; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:12","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#结构体"},{"categories":[],"content":" 结构体声明： struct 结构类型名 { 数据类型 成员名 1; 数据类型 成员名 2; ...... 数据类型 成员名 n; }; 初始化： struct 结构类型名 结构变量 = { 初始化数据 1, ...... 初始化数据 n }; 示例： #include #include struct _INFO { int num; char str[256]; }; int main() { struct _INFO A; A.num = 2014; strcpy(A.str,\"Welcome to dotcpp.com\"); printf(\"This year is %d %s\\n\",A.num,A.str); return 0; } 结构体指针结构体变量用.来访问成员，而结构体指针用-\u003e来访问。 示例： #include struct address { char name[30]; /*姓名，字符数组作为结构体中的成员*/ char street[40]; /*街道*/ unsigned long tel; /*电话，无符号长整型作为结构体中的成员*/ unsigned long zip; /*邮政编码*/ }; int main() { struct address A[3]={\"Zhang\",\"Road NO.1\",111111,4444}, {\"Wang\",\" Road NO.2\",222222,5555}, {\"Li\",\" Road NO.3\",333333,6666}}; struct address *p; p=\u0026A[0]; printf(\"%s %s %u %u\\n\",p-\u003ename,p-\u003estreet,p-\u003etel,p-\u003ezip); return 0; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:12","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#结构体指针"},{"categories":[],"content":" 共用体在C语言中，允许几种不同类型的变量存放到同一段内存单元中，也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，被称为共用体类型结构，简称共用体。一般定义形式为： union 共用体名 { 数据类型 成员名 1; 数据类型 成员名 2; ...... 数据类型 成员名 n; }变量名表列; []暂时不知道有啥用，待学吧～ ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:13","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#共用体"},{"categories":[],"content":" typedef可以用来定义新的类型,或者说给类型起个别名： typedef 已定义的类型 新的类型; 例如： typedef int INTEGER; /*指定用 INTEGER 代表 int 类型*/ typedef float REAL; /*指定用 REAL 代表 float 类型*/ ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:14","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#typedef"},{"categories":[],"content":" 枚举 enum　枚举名　{枚举元素1,枚举元素2,……}; 如： #include\u003cstdio.h\u003e int main() { enum Week{MON, TUE, WED, THU, FRI, SAT, SUN};//定义一个enum week类型，七个值（0.1.2...6） enum Week A=WED; //第三个值赋给A printf(\"%d\\n\",A); return 0; } 枚举类型的特点默认是从0开始递增，若想更改，可以将其中某个类型赋值，后面的值将在此基础之上递增，如代码： #include\u003cstdio.h\u003e int main() { enum Week{MON, TUE=5, WED, THU, FRI, SAT, SUN}; enum Week A=WED; printf(\"%d\\n\",A); return 0; } ","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:15","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#枚举"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include \u003cstdio.h\u003e #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ }\u003c/stdio.h\u003e include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include \u003cstdio.h\u003e 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#预处理"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ } include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#宏"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ } include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#define"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ } include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#include"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ } include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#条件编译"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ } include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#error"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ } include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#line"},{"categories":[],"content":" 预处理 宏分为有参宏和无参宏， definedefine关键字用来自定义宏： 无参宏： #define 标识符 字符串or表达式; 有参宏： #define 宏名(形参表) 字符串or表达式; 如： #define M (y*y+3*y); 这个宏定义的意思是：使用M替代后面的表达式。 示例： #include #define MAX(a,b) (a\u003eb)?a:b /*带参数的宏定义*/ main() { int x,y,max; printf(\"input two numbers: \"); scanf(\"%d %d\",\u0026x,\u0026y); max=MAX(x,y); printf(\"max=%d\\n\",max); /*宏调用*/ } include用来把指定的文件与当前的源程序文件连成一个源文件。 #include \"stdio.h\" #include 尖括号表示在包含文件目录中去查找。 双引号表示在当前的源文件目录中查找，找不到则去包含文件目录中去找。 条件编译 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符已被#difine命令定义过，则对程序段1进行编译；否则对程序段2进行编译。 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 如果标识符未被#define命令定义过则对程序段1进行编译，反之编译程序段2. #if 常量表达式 程序段 1 #else 程序段 2 #endif 如果常量表达式的值为true，则对程序段1编译，反之则编译程序段2。 error强制停止编译，用于编译时调试。 line pragma","date":"2022-10-17","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:16","series":[],"tags":[],"title":"C语言简明教程","uri":"/c%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#pragma"},{"categories":null,"content":"今天重新安装了ubuntu20.04LTS，安装了IDEA后发现不能用adb连接车机，报错： no permissions (missing udev rules? user is in the plugdev group) 在这里找到了解决办法，感谢原作者！ 方法如下： ","date":"2022-10-10","objectID":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/:0:0","series":null,"tags":null,"title":"ubuntu22.04上不能使用adb","uri":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/#"},{"categories":null,"content":" 查看所有USB设备信息 adb start-server lsusb 结果： // 原作者的： $adb start-server $lsusb Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 003: ID 17ef:6099 Lenovo Bus 001 Device 002: ID 17ef:608d Lenovo Bus 001 Device 033: ID 18d1:4ee7 Google Inc. //android xxx Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub // 我的： Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 003: ID 046d:c52b Logitech, Inc. Unifying Receiver Bus 001 Device 002: ID 25a7:2420 2.4G Wireless Device Bus 001 Device 008: ID 12d1:3a07 Huawei Technologies Co., Ltd. HUAWEI USB-C HEADSET Bus 001 Device 007: ID 05c6:901d Qualcomm, Inc. Bus 001 Device 004: ID 214b:7250 USB2.0 HUB Bus 001 Device 006: ID 12d1:107e Huawei Technologies Co., Ltd. EVR-AL00 Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 这里就要根据如上信息找到自己设备的id，比如作者的应该是picxl手机，所以是【Google Inc】的那一行，而我的是车机，应该是高通的那一行【Qualcomm, Inc】。 ","date":"2022-10-10","objectID":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/:0:1","series":null,"tags":null,"title":"ubuntu22.04上不能使用adb","uri":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/#查看所有usb设备信息"},{"categories":null,"content":" 创建配置文件 sudo vim /etc/udev/rules.d/90-android.rules 这个文件名可以随意哈🦐 内容： ATTRS{idVendor}==\"自己设备那一行ID的左侧数字 我这里是18d1\" ATTRS{idProduct}==\"自己设备那一行ID的右侧数字 我这里是4ee7\" ","date":"2022-10-10","objectID":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/:0:2","series":null,"tags":null,"title":"ubuntu22.04上不能使用adb","uri":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/#创建配置文件"},{"categories":null,"content":" 启用配置文件 sudo udevadm control --reload-rules sudo service udev restart sudo udevadm trigger adb kill-server adb devices 然后就ok了！ ","date":"2022-10-10","objectID":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/:0:3","series":null,"tags":null,"title":"ubuntu22.04上不能使用adb","uri":"/ubuntu22.04%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8adb/#启用配置文件"},{"categories":[],"content":"最近工作要求，涉及到了HAL层开发，让我这个刚刚从上层转底层的小白无所适从，根本不知道怎么入手，从网上搜集了大堆的文章，照着做没有一个能成，前前后后一个月了，今天终于成功了，特此记录一下，希望能帮到其他像我一样高转低的同行吧。 本文大量借鉴这篇文章，非常感谢原作！ ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:0:0","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#"},{"categories":[],"content":" 环境介绍 aosp版本：android9 电脑操作系统：ubuntu20.04LTS 手机：google-pixcel-3xl-欧版 ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:1:0","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#环境介绍"},{"categories":[],"content":" 编译过程","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:0","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#编译过程"},{"categories":[],"content":" 定义软件包文件结构我们定义的一部分相关功能的集合，叫做软件包。 软件包名称可以具有子集，如package.subpackage，其根目录为hardware/interfaces或vendor/vendorName。软件包名称，在根目录下形成一个或多个子目录。 AOSP中的软件包分布如下： 前缀 位置 类型 android.hardware.* hardware/interfaces/* HAL android.frameworks.* frameworks/hardware/interfaces/* frameworks/ 相关 android.system.* system/hardware/interfaces/* system/ 相关 android.hidl.* system/libhidl/transport/* 核心 从上表看到，我们的HAL应该位于hardware/interfaces/*中，但由于AOSP某些分支是锁定的，不允许修改VNDK库列表，所以我们不能直接修改hardware/interfaces/*中的文件，一个很好的解决方式就是在我们的厂商目录vendor中建立同样的hardware/interfaces/*，然后映射到AOSP根目录下的相同位置。这种类型的HAL叫做厂商扩展。 接下来我们就定义一个软件包的目录结构： mkdir -p vendor/sample/hardware/interfaces/helloworld/1.0 我们在vendor中创建hal模块，仔细研究目录结构： sample是我们的组织名称； hardware/interfaces映射着着根目录里面的hardware/interfaces； interfaces后面将作为我们的root目录； helloworld是模块名称； 1.0是一个版本目录，以后可能还有2.0,3.0。 网上很多文章都是直接在根目录下的hardware/interface中操作，我试了很多次都编译失败了，都是关于VNDK的报错，VNDK是啥我都不知道，也没办法解决。后来才知道，不要直接在Android源码目录hardware/interfaces下面添加和修改接口,在API锁定分支中不允许更改VNDK库列表。 ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:1","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#定义软件包文件结构"},{"categories":[],"content":" 创建HIDL文件接下来，我们在1.0目录中创建三个.hal文件： IHelloWorld.hal package sample.hardware.helloworld@1.0; import IHelloWorldCallback; interface IHelloWorld { initial(); getInt() generates (int32_t i); setInt(int32_t val) generates (Result error); oneway setCallback(IHelloWorldCallback callback); }; 写法非常类似AIDL，事实上，从Android11开始，google已经用AIDL去替代HIDL,所以对于HIDL大概理解就行，没必要下功夫去学。 内容不多，我们在此声明了四个虚方法，后面会一一实现。 IHelloWorldCallback.hal package sample.hardware.helloworld@1.0; interface IHelloWorldCallback { oneway onEvent(Event event); }; types.haltypes.hal文件并没有定义接口，而是用来定义软件包中每个接口可以访问的数据类型。根据Google的规范，这个文件的名称必须是types.hal。 package sample.hardware.helloworld@1.0; enum Result : int32_t { OK, UNKNOWN, INVALID_ARGUMENTS, }; struct Event { uint32_t type; uint32_t code; uint32_t value; }; 最后注意一下package包声明，是与目录有一定联系的！ ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:2","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#创建hidl文件"},{"categories":[],"content":" 创建HIDL文件接下来，我们在1.0目录中创建三个.hal文件： IHelloWorld.hal package sample.hardware.helloworld@1.0; import IHelloWorldCallback; interface IHelloWorld { initial(); getInt() generates (int32_t i); setInt(int32_t val) generates (Result error); oneway setCallback(IHelloWorldCallback callback); }; 写法非常类似AIDL，事实上，从Android11开始，google已经用AIDL去替代HIDL,所以对于HIDL大概理解就行，没必要下功夫去学。 内容不多，我们在此声明了四个虚方法，后面会一一实现。 IHelloWorldCallback.hal package sample.hardware.helloworld@1.0; interface IHelloWorldCallback { oneway onEvent(Event event); }; types.haltypes.hal文件并没有定义接口，而是用来定义软件包中每个接口可以访问的数据类型。根据Google的规范，这个文件的名称必须是types.hal。 package sample.hardware.helloworld@1.0; enum Result : int32_t { OK, UNKNOWN, INVALID_ARGUMENTS, }; struct Event { uint32_t type; uint32_t code; uint32_t value; }; 最后注意一下package包声明，是与目录有一定联系的！ ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:2","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#ihelloworldhal"},{"categories":[],"content":" 创建HIDL文件接下来，我们在1.0目录中创建三个.hal文件： IHelloWorld.hal package sample.hardware.helloworld@1.0; import IHelloWorldCallback; interface IHelloWorld { initial(); getInt() generates (int32_t i); setInt(int32_t val) generates (Result error); oneway setCallback(IHelloWorldCallback callback); }; 写法非常类似AIDL，事实上，从Android11开始，google已经用AIDL去替代HIDL,所以对于HIDL大概理解就行，没必要下功夫去学。 内容不多，我们在此声明了四个虚方法，后面会一一实现。 IHelloWorldCallback.hal package sample.hardware.helloworld@1.0; interface IHelloWorldCallback { oneway onEvent(Event event); }; types.haltypes.hal文件并没有定义接口，而是用来定义软件包中每个接口可以访问的数据类型。根据Google的规范，这个文件的名称必须是types.hal。 package sample.hardware.helloworld@1.0; enum Result : int32_t { OK, UNKNOWN, INVALID_ARGUMENTS, }; struct Event { uint32_t type; uint32_t code; uint32_t value; }; 最后注意一下package包声明，是与目录有一定联系的！ ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:2","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#ihelloworldcallbackhal"},{"categories":[],"content":" 创建HIDL文件接下来，我们在1.0目录中创建三个.hal文件： IHelloWorld.hal package sample.hardware.helloworld@1.0; import IHelloWorldCallback; interface IHelloWorld { initial(); getInt() generates (int32_t i); setInt(int32_t val) generates (Result error); oneway setCallback(IHelloWorldCallback callback); }; 写法非常类似AIDL，事实上，从Android11开始，google已经用AIDL去替代HIDL,所以对于HIDL大概理解就行，没必要下功夫去学。 内容不多，我们在此声明了四个虚方法，后面会一一实现。 IHelloWorldCallback.hal package sample.hardware.helloworld@1.0; interface IHelloWorldCallback { oneway onEvent(Event event); }; types.haltypes.hal文件并没有定义接口，而是用来定义软件包中每个接口可以访问的数据类型。根据Google的规范，这个文件的名称必须是types.hal。 package sample.hardware.helloworld@1.0; enum Result : int32_t { OK, UNKNOWN, INVALID_ARGUMENTS, }; struct Event { uint32_t type; uint32_t code; uint32_t value; }; 最后注意一下package包声明，是与目录有一定联系的！ ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:2","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#typeshal"},{"categories":[],"content":" 指定interfaces为软件包根目录在interfaces中创建Android.bp文件： hidl_package_root { name: \"sample.hardware\", path: \"vendor/sample/hardware/interfaces\", } 我们知道.bp文件是用来描述软件包的，这里就是把interfaces指定为“sample.hardware”软件包的根目录。 如果没有指定目录，编译时会报错：Cannot find package root specification ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:3","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#指定interfaces为软件包根目录"},{"categories":[],"content":" 用hidl-gen工具生成相关文件hidl-gen是google提供的，用来生成hidl相关文件的工具，但他本身是以源码的形式，放在aosp代码中提供的，所以使用前需要先编译这玩意： cd到android9的根目录 source build/envsetup.sh lunch 20 make hidl-gen -j4 为了方便，我们可以先定义几个环境变量，一会要重复使用： // 包名 PACKAGE=sample.hardware // 软件名 NAME=$PACKAGE.helloworld@1.0 // 软件包根目录 ROOT=vendor/sample/hardware/interfaces // hidl实现文件存放的位置 LOC=$ROOT/helloworld/1.0/default ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:4","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#用hidl-gen工具生成相关文件"},{"categories":[],"content":" 生成版本控制文件版本控制文件是位于软件包根目录下的current.txt,用来做OTA升级时，确认软件包版本信息的。 hidl-gen -Lhash -r$PACKAGE:$ROOT -randroid.hidl:system/libhidl/transport $NAME\u003e $ROOT/current.txt 在$ROOT下会出现一个current.txt文件，里面是所有hidl的哈希，用来标记版本。 ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:5","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#生成版本控制文件"},{"categories":[],"content":" 生成HIDL的实现 hidl-gen -o $LOC -Lc++-impl -r$PACKAGE:$ROOT -randroid.hidl:system/libhidl/transport $NAME 在$LOC下会生成HIDL的c++实现文件，我们需要修改成自己的实现。 HelloWorld.h #ifndef SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #define SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #include \u003csample/hardware/helloworld/1.0/IHelloWorld.h\u003e #include \u003chidl/MQDescriptor.h\u003e #include \u003chidl/Status.h\u003e namespace sample { namespace hardware { namespace helloworld { namespace V1_0 { namespace implementation { using ::android::hardware::hidl_array; using ::android::hardware::hidl_memory; using ::android::hardware::hidl_string; using ::android::hardware::hidl_vec; using ::android::hardware::Return; using ::android::hardware::Void; using ::android::sp; struct HelloWorld : public IHelloWorld { Return\u003cvoid\u003e initial() override; Return\u003cint32_t\u003e getInt() override; Return\u003c::sample::hardware::helloworld::V1_0::Result\u003e setInt(int32_t val) override; Return\u003cvoid\u003e setCallback(const sp\u003c::sample::hardware::helloworld::V1_0::IHelloWorldCallback\u003e \u0026callback) override; static void *pollThreadWrapper(void *me); void pollThreadEntry(); private: pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER; pthread_t mPollThread; bool mRunning; std::vector\u003csp\u003cIHelloWorldCallback\u003e\u003e mCallbacks; }; } // namespace implementation } // namespace V1_0 } // namespace helloworld } // namespace hardware } // namespace sample #endif // SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H HeloWorld.cpp: #define LOG_TAG \"sample.hardware.helloworld@1.0-service\" #include \u003candroid-base/logging.h\u003e #include \u003clog/log.h\u003e #include \"HelloWorld.h\" namespace sample { namespace hardware { namespace helloworld { namespace V1_0 { namespace implementation { Return\u003cvoid\u003e HelloWorld::initial() { ALOGD(\"%s\", __FUNCTION__); if (mRunning) return Void(); mRunning = true; pthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_JOINABLE); pthread_create(\u0026mPollThread, \u0026attr, pollThreadWrapper, this); pthread_attr_destroy(\u0026attr); return Void(); } Return\u003cint32_t\u003e HelloWorld::getInt() { ALOGD(\"%s\", __FUNCTION__); return int32_t{666}; } Return\u003c::sample::hardware::helloworld::V1_0::Result\u003e HelloWorld::setInt(int32_t val) { ALOGD(\"%s %d\", __FUNCTION__, val); return ::sample::hardware::helloworld::V1_0::Result{}; } void *HelloWorld::pollThreadWrapper(void *me) { static_cast\u003cHelloWorld *\u003e(me)-\u003epollThreadEntry(); return NULL; } void HelloWorld::pollThreadEntry() { mRunning = true; ALOGD(\"%s enter\", __FUNCTION__); Event event; event.type = 0; event.code = 0; event.value = 0; while (mRunning) { event.code++; event.type++; event.value++; sleep(1); ALOGD(\"%s event %04x %04x %04x\\n\", __FUNCTION__, event.type, event.code, event.value); pthread_mutex_lock(\u0026mLock); if (!mCallbacks.empty()) { std::vector\u003csp\u003cIHelloWorldCallback\u003e\u003e::iterator it; for (it = mCallbacks.begin(); it != mCallbacks.end();) { sp\u003cIHelloWorldCallback\u003e callback = *it; Return\u003cvoid\u003e ret = callback-\u003eonEvent(event); if (!ret.isOk()) { ALOGE(\"error %s\", ret.description().c_str()); it = mCallbacks.erase(it); } else { it++; } } } pthread_mutex_unlock(\u0026mLock); } ALOGD(\"%s exit\", __FUNCTION__); } Return\u003cvoid\u003e HelloWorld::setCallback(const sp\u003c::sample::hardware::helloworld::V1_0::IHelloWorldCallback\u003e \u0026callback) { ALOGD(\"%s\", __FUNCTION__); pthread_mutex_lock(\u0026mLock); if (callback != nullptr) { mCallbacks.push_back(callback); } pthread_mutex_unlock(\u0026mLock); return Void(); } } // namespace implementation } // namespace V1_0 } // namespace helloworld } // namespace hardware } // namespace sample service.cpp以上全都是c++代码，c++需要一个main入口函数才能启动，接下来就要实现一个service作为入口，创建$LOC/service.cpp: #define LOG_TAG \"sample.hardware.helloworld@1.0-service\" #include \u003candroid-base/logging.h\u003e #include \u003chidl/HidlTransportSupport.h\u003e #include \"HelloWorld.h\" using android::OK; using android::sp; using android::status_t; using android::hardware::configureRpcThreadpool; using android::hardware::joinRpcThreadpool; using sample::hardware::helloworld::V1_0::IHelloWorld; using sample::hardware::hello","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:6","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#生成hidl的实现"},{"categories":[],"content":" 生成HIDL的实现 hidl-gen -o $LOC -Lc++-impl -r$PACKAGE:$ROOT -randroid.hidl:system/libhidl/transport $NAME 在$LOC下会生成HIDL的c++实现文件，我们需要修改成自己的实现。 HelloWorld.h #ifndef SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #define SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #include #include #include namespace sample { namespace hardware { namespace helloworld { namespace V1_0 { namespace implementation { using ::android::hardware::hidl_array; using ::android::hardware::hidl_memory; using ::android::hardware::hidl_string; using ::android::hardware::hidl_vec; using ::android::hardware::Return; using ::android::hardware::Void; using ::android::sp; struct HelloWorld : public IHelloWorld { Return initial() override; Return getInt() override; Return\u003c::sample::hardware::helloworld::V1_0::Result\u003e setInt(int32_t val) override; Return setCallback(const sp\u003c::sample::hardware::helloworld::V1_0::IHelloWorldCallback\u003e \u0026callback) override; static void *pollThreadWrapper(void *me); void pollThreadEntry(); private: pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER; pthread_t mPollThread; bool mRunning; std::vector","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:6","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#helloworldh"},{"categories":[],"content":" 生成HIDL的实现 hidl-gen -o $LOC -Lc++-impl -r$PACKAGE:$ROOT -randroid.hidl:system/libhidl/transport $NAME 在$LOC下会生成HIDL的c++实现文件，我们需要修改成自己的实现。 HelloWorld.h #ifndef SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #define SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #include #include #include namespace sample { namespace hardware { namespace helloworld { namespace V1_0 { namespace implementation { using ::android::hardware::hidl_array; using ::android::hardware::hidl_memory; using ::android::hardware::hidl_string; using ::android::hardware::hidl_vec; using ::android::hardware::Return; using ::android::hardware::Void; using ::android::sp; struct HelloWorld : public IHelloWorld { Return initial() override; Return getInt() override; Return\u003c::sample::hardware::helloworld::V1_0::Result\u003e setInt(int32_t val) override; Return setCallback(const sp\u003c::sample::hardware::helloworld::V1_0::IHelloWorldCallback\u003e \u0026callback) override; static void *pollThreadWrapper(void *me); void pollThreadEntry(); private: pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER; pthread_t mPollThread; bool mRunning; std::vector","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:6","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#heloworldcpp"},{"categories":[],"content":" 生成HIDL的实现 hidl-gen -o $LOC -Lc++-impl -r$PACKAGE:$ROOT -randroid.hidl:system/libhidl/transport $NAME 在$LOC下会生成HIDL的c++实现文件，我们需要修改成自己的实现。 HelloWorld.h #ifndef SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #define SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #include #include #include namespace sample { namespace hardware { namespace helloworld { namespace V1_0 { namespace implementation { using ::android::hardware::hidl_array; using ::android::hardware::hidl_memory; using ::android::hardware::hidl_string; using ::android::hardware::hidl_vec; using ::android::hardware::Return; using ::android::hardware::Void; using ::android::sp; struct HelloWorld : public IHelloWorld { Return initial() override; Return getInt() override; Return\u003c::sample::hardware::helloworld::V1_0::Result\u003e setInt(int32_t val) override; Return setCallback(const sp\u003c::sample::hardware::helloworld::V1_0::IHelloWorldCallback\u003e \u0026callback) override; static void *pollThreadWrapper(void *me); void pollThreadEntry(); private: pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER; pthread_t mPollThread; bool mRunning; std::vector","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:6","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#servicecpp"},{"categories":[],"content":" 生成HIDL的实现 hidl-gen -o $LOC -Lc++-impl -r$PACKAGE:$ROOT -randroid.hidl:system/libhidl/transport $NAME 在$LOC下会生成HIDL的c++实现文件，我们需要修改成自己的实现。 HelloWorld.h #ifndef SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #define SAMPLE_HARDWARE_HELLOWORLD_V1_0_HELLOWORLD_H #include #include #include namespace sample { namespace hardware { namespace helloworld { namespace V1_0 { namespace implementation { using ::android::hardware::hidl_array; using ::android::hardware::hidl_memory; using ::android::hardware::hidl_string; using ::android::hardware::hidl_vec; using ::android::hardware::Return; using ::android::hardware::Void; using ::android::sp; struct HelloWorld : public IHelloWorld { Return initial() override; Return getInt() override; Return\u003c::sample::hardware::helloworld::V1_0::Result\u003e setInt(int32_t val) override; Return setCallback(const sp\u003c::sample::hardware::helloworld::V1_0::IHelloWorldCallback\u003e \u0026callback) override; static void *pollThreadWrapper(void *me); void pollThreadEntry(); private: pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER; pthread_t mPollThread; bool mRunning; std::vector","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:6","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#initrc"},{"categories":[],"content":" 生成Android.bp生成$LOC下的Android.bp: hidl-gen -o $LOC -Landroidbp-impl -r$PACKAGE:$ROOT -randroid.hidl:system/libhidl/transport $NAME 生成$ROOT/helloworld/1.0中的Android.bp： $ source $ANDROID_BUILD_TOP/system/tools/hidl/update-makefiles-helper.sh $ do_makefiles_update $PACKAGE:ROOT android.hardware:hardware/interfaces android.hidl:system/libhidl/transport ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:7","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#生成androidbp"},{"categories":[],"content":" 在编译类型中注册HAL服务在devices中的对应厂商的对应编译类型（lunch指令的编译目标）目录下修改manifest.xml文件，比如我的aosp,对应调试手机为google-pixel-3xl,我在lunch时的目标类型是aosp-crosshatch-userdebug，那么就应该去修改device/google/crosshatch/manifest.xml文件。在文件中加入： \u003chal format=\"hidl\"\u003e \u003cname\u003esample.hardware.helloworld\u003c/name\u003e \u003ctransport\u003ehwbinder\u003c/transport\u003e \u003cversion\u003e1.0\u003c/version\u003e \u003cinterface\u003e \u003cname\u003eIHelloWorld\u003c/name\u003e \u003cinstance\u003edefault\u003c/instance\u003e \u003c/interface\u003e \u003c/hal\u003e 然后整编一下，更新manifest.xml。 这里不更新manifest.xml,可能会报错：W hwservicemanager: getTransport: Cannot find entry sample.hardware.helloworld@1.0::IHelloWorld/default in either framework or device manifest. 在这里我遇到了报错： [ 25% 4/16] build out/target/product/crosshatch/gen/ETC/framework_compatibility_matrix.xml_intermediates/compatibility_matrix.xml FAILED: out/target/product/crosshatch/gen/ETC/framework_compatibility_matrix.xml_intermediates/compatibility_matrix.xml /bin/bash -c \"PRODUCT_ENFORCE_VINTF_MANIFEST=\\\"true\\\" VINTF_ENFORCE_NO_UNUSED_HALS=true out/host/linux-x86/bin/assemble_vintf -i out/target/product/crosshatch/system/etc/vintf/compatibility_matrix.legacy.xml:out/target/product/crosshatch/system/etc/vintf/compatibility_matrix.1.xml:out/target/product/crosshatch/system/etc/vintf/compatibility_matrix.2.xml:out/target/product/crosshatch/system/etc/vintf/compatibility_matrix.3.xml:out/target/product/crosshatch/system/etc/vintf/compatibility_matrix.device.xml -o out/target/product/crosshatch/gen/ETC/framework_compatibility_matrix.xml_intermediates/compatibility_matrix.xml -c \\\"out/target/product/crosshatch/obj/ETC/device_manifest.xml_intermediates/manifest.xml\\\"\" Error: The following instances are in the device manifest but not specified in framework compatibility matrix: sample.hardware.helloworld@1.0::IHelloWorld/default Suggested fix: 1. Check for any typos in device manifest or framework compatibility matrices with FCM version \u003e= 3. 2. Add them to any framework compatibility matrix with FCM version \u003e= 3 where applicable. 3. Add them to DEVICE_FRAMEWORK_COMPATIBILITY_MATRIX_FILE. ninja: build stopped: subcommand failed. 10:01:12 ninja failed with: exit status 1 #### failed to build some targets (7 seconds) #### 猜想原因，是因为由于锁定分支的关系，我们没有直接在hardware/interfaces/*中建立我们的hal,而是在厂商目录vendor中玩的。 注意看错误信息：Error: The following instances are in the device manifest but not specified in framework compatibility matrix: sample.hardware.helloworld@1.0::IHelloWorld/default。意思是说，我们虽然在device的manifest中添加了一个实例，但是没有在framework compatibility matrix中指定。 然后下面给出了3条建议： 1. Check for any typos in device manifest or framework compatibility matrices with FCM version \u003e= 3. 2. Add them to any framework compatibility matrix with FCM version \u003e= 3 where applicable. 3. Add them to DEVICE_FRAMEWORK_COMPATIBILITY_MATRIX_FILE. 然后根据建议，在hardware/interfaces/compatibility_matrices/compatibility_matrix.3.xml中添加相同的内容： \u003chal format=\"hidl\"\u003e \u003cname\u003esample.hardware.helloworld\u003c/name\u003e \u003ctransport\u003ehwbinder\u003c/transport\u003e \u003cversion\u003e1.0\u003c/version\u003e \u003cinterface\u003e \u003cname\u003eIHelloWorld\u003c/name\u003e \u003cinstance\u003edefault\u003c/instance\u003e \u003c/interface\u003e \u003c/hal\u003e 再次整编成功！ 后面需要详细了解一下兼容性矩阵。 ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:8","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#在编译类型中注册hal服务"},{"categories":[],"content":" 添加本地c++测试// 包名 PACKAGE=sample.hardware // 软件名 NAME=$PACKAGE.helloworld@1.0 // 软件包根目录 ROOT=vendor/sample/hardware/interfaces // hidl实现文件存放的位置 LOC=$ROOT/helloworld/1.0/default 创建$ROOT/1.0/test/Android.cpp： cc_binary { name: \"sample.hardware.helloworld_hidl_hal_test\", vendor: true, srcs: [\"test.cpp\"], shared_libs: [ \"libhidlbase\", \"libhidltransport\", \"liblog\", \"libutils\", \"libhardware\", \"sample.hardware.helloworld@1.0\", ], } 创建$ROOT/1.0/test/test.cpp: #define LOG_TAG \"sample.hardware.helloworld_hidl_hal_test\" #include \u003candroid-base/logging.h\u003e #include \u003chidl/HidlTransportSupport.h\u003e #include \u003clog/log.h\u003e #include \u003csample/hardware/helloworld/1.0/IHelloWorld.h\u003e #include \u003csample/hardware/helloworld/1.0/types.h\u003e using ::android::sp; using ::android::hardware::Return; using ::android::hardware::Void; using ::sample::hardware::helloworld::V1_0::Event; using ::sample::hardware::helloworld::V1_0::IHelloWorld; using ::sample::hardware::helloworld::V1_0::IHelloWorldCallback; using ::sample::hardware::helloworld::V1_0::Result; class HelloWorldCallback : public IHelloWorldCallback { public: HelloWorldCallback() { printf(\"%s\\n\", __FUNCTION__); } ~HelloWorldCallback() { printf(\"%s\\n\", __FUNCTION__); } Return\u003cvoid\u003e onEvent(const Event \u0026event) { printf(\"%s %04x %04x %04x\\n\", __FUNCTION__, event.type, event.code, event.value); return Void(); } }; int main(int /* argc */, char ** /* argv */) { sp\u003cIHelloWorld\u003e service = IHelloWorld::getService(); if (service == nullptr) { printf(\"Failed to get service\\n\"); return -1; } printf(\"initial\\n\"); service-\u003einitial(); int ret = service-\u003egetInt(); printf(\"getInt %d\\n\", ret); Result result = service-\u003esetInt(888); printf(\"setInt result=%d\\n\", result); sp\u003cIHelloWorldCallback\u003e callback = new HelloWorldCallback(); printf(\"setCallback\\n\"); service-\u003esetCallback(callback); while (1) { sleep(1); } return 0; } ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:9","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#添加本地c测试"},{"categories":[],"content":" 编译出运行库 因为我是小白，还不能充分理解，下面完全摘抄原作。 mmm vendor/sample/hardware/interfaces/helloworld/1.0/ 编译hal文件生成的中间代码位于out/soong/.intermediates/vendor/sample/hardware/interfaces/helloworld/1.0/: default sample.hardware.helloworld@1.0 sample.hardware.helloworld@1.0-adapter sample.hardware.helloworld@1.0-adapter_genc++ sample.hardware.helloworld@1.0-adapter-helper sample.hardware.helloworld@1.0-adapter-helper_genc++ sample.hardware.helloworld@1.0-adapter-helper_genc++_headers sample.hardware.helloworld@1.0_genc++ sample.hardware.helloworld@1.0_genc++_headers sample.hardware.helloworld-V1.0-java sample.hardware.helloworld-V1.0-java_gen_java test “sample.hardware.helloworld@1.0_genc++“目录里面可以发现hal文件转换成了C++源码 ,里面就包含Binder Bn端,Binder Bp端的代码.不用像非Project Treble项目那样需要自己写Binder Bn端,Binder Bp端的代码.体会到了谷歌的良苦用心。 编译最终会在out/target/product/$TARGET_PRODUCT/目录下面生成了以下文件: out/target/product/$TARGET_PRODUCT/system/lib/sample.hardware.helloworld@1.0.so out/target/product/$TARGET_PRODUCT/system/lib/sample.hardware.helloworld@1.0-adapter-helper.so out/target/product/$TARGET_PRODUCT/system/lib64/sample.hardware.helloworld@1.0.so out/target/product/$TARGET_PRODUCT/system/lib64/sample.hardware.helloworld@1.0-adapter-helper.so out/target/product/$TARGET_PRODUCT/system/framework/sample.hardware.helloworld-V1.0-java.jar out/target/product/$TARGET_PRODUCT/system/framework/oat/arm/sample.hardware.helloworld-V1.0-java.odex out/target/product/$TARGET_PRODUCT/system/framework/oat/arm/sample.hardware.helloworld-V1.0-java.vdex out/target/product/$TARGET_PRODUCT/system/framework/oat/arm64/sample.hardware.helloworld-V1.0-java.odex out/target/product/$TARGET_PRODUCT/system/framework/oat/arm64/sample.hardware.helloworld-V1.0-java.vdex out/target/product/$TARGET_PRODUCT/vendor/lib/sample.hardware.helloworld@1.0-impl.so out/target/product/$TARGET_PRODUCT/vendor/lib/sample.hardware.helloworld@1.0.so out/target/product/$TARGET_PRODUCT/vendor/lib/sample.hardware.helloworld@1.0-adapter-helper.so out/target/product/$TARGET_PRODUCT/vendor/lib64/sample.hardware.helloworld@1.0-impl.so out/target/product/$TARGET_PRODUCT/vendor/lib64/sample.hardware.helloworld@1.0.so out/target/product/$TARGET_PRODUCT/vendor/lib64/sample.hardware.helloworld@1.0-adapter-helper.so out/target/product/$TARGET_PRODUCT/vendor/bin/hw/sample.hardware.helloworld@1.0-service out/target/product/$TARGET_PRODUCT/vendor/bin/sample.hardware.helloworld_hidl_hal_test out/target/product/$TARGET_PRODUCT/vendor/etc/init/sample.hardware.helloworld@1.0-service.rc ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:2:10","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#编译出运行库"},{"categories":[],"content":" 测试","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:3:0","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#测试"},{"categories":[],"content":" 推送包到设备将编译好的库和bin文件复制到设备中: $ adb root $ adb remount $ adb push out/target/product/$TARGET_PRODUCT/vendor/lib64/sample.hardware.helloworld@1.0-impl.so /vendor/lib64/sample.hardware.helloworld@1.0-impl.so $ adb push out/target/product/$TARGET_PRODUCT/vendor/lib64/sample.hardware.helloworld@1.0.so /vendor/lib64/sample.hardware.helloworld@1.0.so $ adb push out/target/product/$TARGET_PRODUCT/vendor/bin/hw/sample.hardware.helloworld@1.0-service /vendor/bin/hw/sample.hardware.helloworld@1.0-service $ adb push out/target/product/$TARGET_PRODUCT/vendor/bin/sample.hardware.helloworld_hidl_hal_test /vendor/bin/sample.hardware.helloworld_hidl_hal_test 我尝试直接整编，然后刷机，后续操作直接失败，说是找不到服务，然后进手机对应的目录，确实没有发现对应的库，暂时不知道是为什么。所以还是需要自己push到设备上。 整编刷机的问题 ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:3:1","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#推送包到设备"},{"categories":[],"content":" 启动服务在adb中启动服务： # ./vendor/bin/hw/sample.hardware.helloworld@1.0-service\u0026 注意： 指令最后的「\u0026」符号表示后台运行。 不加「\u0026」符号，输入指令后，shell会卡住不动，是正常的。 输入指令后，不会有任何输出，是正常的，想看输出，需要从logcat中查看。 ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:3:2","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#启动服务"},{"categories":[],"content":" 启动测试 # sample.hardware.helloworld_hidl_hal_test 这里我又遇到问题：Cannot find entry in either framework or device manifest 解决方式：在设备的system/etc/vintf/manifest.xml和vendor/etc/vintf/manifest.xml这两个文件中添加： \u003chal format=\"hidl\"\u003e \u003cname\u003esample.hardware.helloworld\u003c/name\u003e \u003ctransport\u003ehwbinder\u003c/transport\u003e \u003cversion\u003e1.0\u003c/version\u003e \u003cinterface\u003e \u003cname\u003eIHelloWorld\u003c/name\u003e \u003cinstance\u003edefault\u003c/instance\u003e \u003c/interface\u003e \u003c/hal\u003e 再次尝试调用客户端成功！输出如下： initial getInt 666 setInt result=0 HelloWorldCallback setCallback onEvent 0001 0001 0001 onEvent 0002 0002 0002 onEvent 0003 0003 0003 ... ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:3:3","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#启动测试"},{"categories":[],"content":" Java层App调试新建一个Android应用项目，然后将out/soong/.intermediates/vendor/sample/hardware/interfaces/helloworld/1.0/sample.hardware.helloworld-V1.0-java/android_common/combined/sample.hardware.helloworld-V1.0-java.jar复制到app的libs目录下，右键选择add as library，之后app的gradle: implementation files('libs\\\\sample.hardware.helloworld-V1.0-java.jar') MainActivity.kt: package site.leasa.haltest import android.os.Bundle import android.os.RemoteException import android.util.Log import android.view.View import androidx.appcompat.app.AppCompatActivity import sample.hardware.helloworld.V1_0.Event import sample.hardware.helloworld.V1_0.IHelloWorld import sample.hardware.helloworld.V1_0.IHelloWorldCallback class MainActivity : AppCompatActivity() { private lateinit var service: IHelloWorld private val TAG = \"HAL_SERVICE_ACTIVITY\" override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } open fun click(v: View) { try { this.service = IHelloWorld.getService() service.initial() val ret: Int = service.getInt() Log.d(TAG, \"getInt=$ret\") service.setInt(888) service.setCallback(HelloWorldCallback()) } catch (e: RemoteException) { Log.e(TAG, \"hal服务初始化失败: \", e) } } } class HelloWorldCallback : IHelloWorldCallback.Stub() { private val TAG = \"HAL_SERVICE_Callback\" override fun onEvent(event: Event) { Log.d(TAG, \"onEvent type=\" + event.type + \", code=\" + event.code + \", value=\" + event.value); } } 然后控制台进adb shell,启动服务： # ./vendor/bin/hw/sample.hardware.helloworld@1.0-service\u0026 启动App,点一下按钮出发click方法后，会报错：NoSuchElement，就是找不到我们的hal服务，之所以出现这个问题，是因为我们没有配置selinux的标签，这玩意太麻烦了，放后面学习，现在先关掉selinux： adb shell setenforce 0 然后重启启动app,点击按钮，logcat控制台输出如下： initial getInt 666 setInt result=0 HelloWorldCallback setCallback onEvent 0001 0001 0001 onEvent 0002 0002 0002 onEvent 0003 0003 0003 ... ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:3:4","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#java层app调试"},{"categories":[],"content":" 后记对于hal,我目前只是最粗浅的能够编译并运转，里面很多机制还不了解，后续会慢慢梳理好，补充道本文，这里还是特别感谢这篇文章，对我的学习产生莫大帮助！ 安卓系统是个很复杂的东西，当然HAL层启到承上启下的桥梁作用，对于我这个新手来说上手难度较大，本文的东西也是断断续续用了很长时间，磕磕绊绊解决了很多问题才产生的结果，可以说不容易，很庆幸，同时也见识到了操作系统层面的复杂精深，对知识广度有很高的要求。攻克下来，一马平川！还是那句话：If i want, i can do it! ","date":"2022-08-03","objectID":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/:4:0","series":[],"tags":[],"title":"手把手教你自定义HAL层","uri":"/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89hal%E5%B1%82/#后记"},{"categories":[],"content":" 编译指令 m -j32,m指令用于整编，就是完整编译所有的模块，「-j32」就是启动32个线程一起编译，通常在AOSP的根目录下执行； mm，双m指令用于在单一模块的目录下编译此单个模块; mmm，用于在根目录对单一模块进行单编，所以后面要跟模块的目录。 ","date":"2022-07-25","objectID":"/%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7/:1:0","series":[],"tags":[],"title":"编译技巧","uri":"/%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7/#编译指令"},{"categories":[],"content":" 清除指令 make clean,清除本次设置所生成的所有的output与中间文件，out/target/product/[product_name]； make clobber 会删除所有设置所生成的所有的output与中间文件out。 ","date":"2022-07-25","objectID":"/%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7/:2:0","series":[],"tags":[],"title":"编译技巧","uri":"/%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7/#清除指令"},{"categories":[],"content":" HAL的作用连通硬件驱动，提供一个标准接口（硬件供应商自己提供实现），让Android可以忽略底层驱动程序的实现。 ","date":"2022-07-18","objectID":"/%E7%90%86%E8%A7%A3hal/:1:0","series":[],"tags":[],"title":"理解HAL","uri":"/%E7%90%86%E8%A7%A3hal/#hal的作用"},{"categories":[],"content":" HAL类型 绑定式：以HAL接口定义语言或者AIDL表示的HAL。FrameWork与HAL通过Binder进行IPC通信，自Android8.0之后的版本都必须支持绑定式。 直通式：以HIDL封装的传统HAL或者旧版HAL。 ","date":"2022-07-18","objectID":"/%E7%90%86%E8%A7%A3hal/:2:0","series":[],"tags":[],"title":"理解HAL","uri":"/%E7%90%86%E8%A7%A3hal/#hal类型"},{"categories":[],"content":" HAL接口定义语言HIDL类似AIDL,安卓提供了一种用于HAL和其用户之间的接口的表述语言——HIDL。 当然非常google的是，HIDL在10.0废弃了，直接用AIDL替换了他，也就是说现在玩9.0车机的还是要学这玩意，然后很快就白学了。 HIDL也是用于描述IPC的，底层仍然采用Binder。他被设计出来的目的就是可以在无需重新构建HAL的情况下替换框架（简言之就是一种用于动态化实现的描述）。 HIDL是由供应商（比如我们长城）或者SOC供应商（高通）构建出来，放在/verdor分区（供应商分区）内。 ","date":"2022-07-18","objectID":"/%E7%90%86%E8%A7%A3hal/:3:0","series":[],"tags":[],"title":"理解HAL","uri":"/%E7%90%86%E8%A7%A3hal/#hal接口定义语言hidl"},{"categories":[],"content":" 鸣谢本文是边学官文和博客静默安装9339的文章边做的整理，感谢原作！ ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:1:0","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#鸣谢"},{"categories":[],"content":" 作用","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:2:0","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#作用"},{"categories":[],"content":" c/c+语言对编译器的选择 language build-tool c gcc,clang c++ g++,clang++ 这里推荐选择clang系列，clang系列的效率更高，编译产物也更小。 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:3:0","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#cc语言对编译器的选择"},{"categories":[],"content":" make的演变过程上面这些编译器都只能编译一个文件，所以当我们跑项目，有多个文件的时候，就需要做个批处理。 最早出现了make工具，通过编写makefile作为文件配置，实现了批处理。 但项目越来越大，文件越来越多，makefile编写也会越来越复杂，所以聪明的老外又弄出一个cmake工具，pregrammer们可以用简化后的cmakefile，通过这个工具转化为makefile，并且cmakefile中可以加入一些判断和循环等逻辑，帮我们省了不少工作量，最后cmake还是跨平台的。 然后google的大佬在编译越来越庞大的源码时，慢到不能忍，他就怪到了cmake的头上，所以做出一个Ninja来替换cmake，用.ninja文件替换cmakefile。所以Ninja与cmake是平级的。 最后，Ninja和cmake还是基于目录和文件的思维来组织项目（很有c的传统），google又弄出了个Soong来以「模块module」思维组织项目，同时带来了Android.bp文件，其内容描述的是模块结构，然后编译成.ninja文件，最后再由Ninja来实际编译。 说白了就是层层封装，由于到Android10.0的源码中还存在Android.mk,所以带给我们的就是需要把make、ninja和soong都学会才能解决复杂问题，然后soong还是go语言写的，所以我还得学个go，真google！ ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:4:0","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#make的演变过程"},{"categories":[],"content":" 文件格式我现在的理解，文件名必须是Android.bp。 cc_binary { name: \"gzip\", srcs: [\"src/test/minigzip.c\"], shared_libs: [\"libz\"], stl: \"none\", } 内容就是一个一个的模块，也没啥文件声明、版本号什么的，这点给好评。 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:5:0","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#文件格式"},{"categories":[],"content":" 语法 moduleType { name:value, srcs:[ \"src/test/minigzip.c\", \"src/test/minigzip.c\" ] } 每个模块由模块类型和模块的属性两部分组成，大括号里面的就是属性。 moduleType是固定的那几个，不能乱写，可在源码中android/build/soong/androidmk/cmd/androidmk/android.go中查看，也可以参考google慢成屎的网站 name是每个模块的必填项，并且文件内唯一。 srcs用于指定构建模块的源文件。[todo] 模块引用语法 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:5:1","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#语法"},{"categories":[],"content":" 默认模块cc_defaults类型的模块可用于在多个模块中复用属性，如： cc_defaults { name: \"gzip_defaults\", shared_libs: [\"libz\"], stl: \"none\", } cc_binary { name: \"gzip\", defaults: [\"gzip_defaults\"], srcs: [\"src/test/minigzip.c\"], } ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:5:2","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#默认模块"},{"categories":[],"content":" 预构建模块 [] 待完善 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:5:3","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#预构建模块"},{"categories":[],"content":" 命名空间 [] 待完善 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:5:4","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#命名空间"},{"categories":[],"content":" 逻辑编程","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:6:0","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#逻辑编程"},{"categories":[],"content":" 类型这里的变量和属性是强类型的，以初始化赋值时的类型来确定。 布尔 整型 字符串 字符串数组 映射表（类似HashMap） ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:6:1","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#类型"},{"categories":[],"content":" 通配符接受文件列表的属性（如srcs）可以采用glob写法。 这种写法可以包含通配符*，如*.java。 *匹配任意文件名，如*.java； **匹配0～n个路径，如java/**/*.java同时匹配 java/Main.java 和 java/com/android/Main.java。 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:6:2","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#通配符"},{"categories":[],"content":" 变量支持顶级变量形式： gzip_srcs = [\"src/test/minigzip.c\"], cc_binary { name: \"gzip\", srcs: gzip_srcs, shared_libs: [\"libz\"], stl: \"none\", } 变量只在文件内生效，且无法改变。可以通过+=变量的形式为其他变量赋值。 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:6:3","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#变量"},{"categories":[],"content":" 注释 单行// 多行/* */ ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:6:4","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#注释"},{"categories":[],"content":" 运算符 可以使用 + 运算符附加字符串、字符串列表和映射。可以使用 + 运算符对整数求和。附加映射会生成两个映射中键的并集，并附加在两个映射中都存在的所有键的值。 简言之就是只有一个+号能用。 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:6:5","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#运算符"},{"categories":[],"content":" 条件Soong不支持条件判断，需要额外写个go文件实现。然后条件语句会转换为映射属性，再把映射属性赋值给模块的属性。 比如,要区别不同的cpu架构： cc_library { ... srcs: [\"generic.cpp\"], arch: { arm: { srcs: [\"arm.cpp\"], }, x86: { srcs: [\"x86.cpp\"], }, }, } 还不会Go,先掠过。。。 [] 学习Go,再回来补充这里。 ","date":"2022-07-15","objectID":"/%E7%90%86%E8%A7%A3android.bp/:6:6","series":[],"tags":[],"title":"理解Android","uri":"/%E7%90%86%E8%A7%A3android.bp/#条件"},{"categories":[],"content":"今天又弄了一下fcitx5,并且配置了go环境变量，然后重启了一下电脑，到了登录页面，输入密码，竟然又退到登录页面，无论如何也进不去桌面。 ","date":"2022-07-13","objectID":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/:0:0","series":[],"tags":[],"title":"Ubuntu无法进入桌面","uri":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/#"},{"categories":[],"content":" 解决步骤 插入ubuntu启动盘，从usb引导，进入ubuntu安装页面，选择try ubuntu. 试用方式会以u盘为根目录，进入到系统，此时就能进入桌面了。 不要急，想想最近干了什么事情，哪些与操作系统配置相关，比如我就干了如下危险操作： 系统语言从英文切换到了中文，根目录保留了英文名称。（三天没出事，可以排除）； 安装了Fcitx5输入法，两天没事，但是今天在钉钉上不能切换中文，钉钉的技术帮我开了「默认激活」选项（严重怀疑）; 在格式化机械硬盘时强制重启了系统（系统装在ssd上，应该不会受影响）（轻度怀疑）； 安装了go环境，配置了环境变量（怀疑与系统自带的go冲突？）。 然后选择其他位置，找到原来系统的根目录； 先从最熟悉的环境变量开始检查，发现在fcitx的配置上，多了个「ls」，但是这顶多导致一些报错，不会影响到系统，顺手改了 继续去看go的配置，发现$PATH=$GO_HOME/bin,总感觉少了什么，我擦，正常的PATH应该各目录拼接成的，我这样写就成了赋值，会清空PATH变量！！ 修改成$PATH=$GO_HOME/bin:$PATH之后重启，可以正常进桌面了。 ","date":"2022-07-13","objectID":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/:1:0","series":[],"tags":[],"title":"Ubuntu无法进入桌面","uri":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/#解决步骤"},{"categories":[],"content":" 总结 环境变量是个严谨的玩意，每次修改都需要慎重对待； 我喜欢在vscode里面修改.profile,但是每次打开文件后就不管了，导致.profile一直处于可编辑状态，这样十分危险，以后改完就关闭； 我喜欢将环境变量写在~/.profile文件中，这样一旦出错就会影响自己的用户系统。以后应该把环境变量写在~/.bash_profile中，这样只会影响终端，不至于出现连桌面都进不去的局面。 ","date":"2022-07-13","objectID":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/:2:0","series":[],"tags":[],"title":"Ubuntu无法进入桌面","uri":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/#总结"},{"categories":[],"content":" 更新解决桌面进不去的问题之后，发现钉钉又不能输入中文了，通过把fcitx5的配置还原回.profile，并且重启生效后，解决了这个问题。 看来不是什么环境变量都能写到.bash_profile的，比如fcitx5输入法的配置，就应该是用户系统全局生效的，而不是只在bash里面生效。 ","date":"2022-07-13","objectID":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/:3:0","series":[],"tags":[],"title":"Ubuntu无法进入桌面","uri":"/ubuntu%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2/#更新"},{"categories":[],"content":"主要参考了这篇文章,感谢原作！ ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:0:0","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#"},{"categories":[],"content":" 安装","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:0","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#安装"},{"categories":[],"content":" 安装flatpak sudo add-apt-repository ppa:flatpak/stable sudo apt update sudo apt install flatpak sudo apt install gnome-software-plugin-flatpak flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo sudo reboot ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:1","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#安装flatpak"},{"categories":[],"content":" 安装flatub仓库 # 添加 flatub 仓库, fcitx5-unstable 也会依赖一些这个仓库中的运行时软件包。 flatpak remote-add --user --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo # 可选部分: 如果你想要使用不稳定版本的fcitx5，也可以添加 fcitx5 非稳定仓库。 # flatpak remote-add --user --if-not-exists fcitx5-unstable https://flatpak.fcitx-im.org/unstable-repo/fcitx5-unstable.flatpakrepo 这个安装完之后，桌面会出现一个另一个应用市场。 ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:2","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#安装flatub仓库"},{"categories":[],"content":" 安装fcitx5 # 如果您使用的是旧版flatpak，在安装的时候会需要显示的指定软件仓库名字: flatpak install flathub org.fcitx.Fcitx5 flatpak install org.fcitx.Fcitx5 # 中文输入法引擎 flatpak install org.fcitx.Fcitx5.Addon.ChineseAddons # 日文输入法（不用装） # flatpak install org.fcitx.Fcitx5.Addon.Mozc # 安装fcitx5服务，好像是这么个意思 sudo apt install fcitx5-frontend-gtk2 fcitx5-frontend-gtk3 fcitx5-frontend-qt5 这里日文输入不用安装。 ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:3","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#安装fcitx5"},{"categories":[],"content":" 配置环境变量编辑~/.profile，加入： export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx 然后重启。 ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:4","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#配置环境变量"},{"categories":[],"content":" 配置开机自启","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:5","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#配置开机自启"},{"categories":[],"content":" 安装主题我使用这个主题，蛮漂亮的，README里面有详细的安装方法。 git clone https://github.com/hosxy/Fcitx5-Material-Color.git ~/.local/share/fcitx5/themes/Material-Color cd ~/.local/share/fcitx5/themes/Material-Color ln -sf ./theme-teal.conf theme.conf ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:6","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#安装主题"},{"categories":[],"content":" 安装词库萌娘百科词库 维基百科词库 下载*.dict文件, 放置到 ~/.local/share/fcitx5/pinyin/dictionaries ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:1:7","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#安装词库"},{"categories":[],"content":" FAQ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:2:0","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#faq"},{"categories":[],"content":" 钉钉不能输入中文找了钉钉的技术客服，教了我一招，可以参考这里对fcitx5的配置，但是我这里还不一样。 编辑/opt/apps/com.alibabainc.dingtalk/files/Elevator.sh文件，在文件声明#！/bin/bin/sh下面加入如下内容： export GTK_IM_MODULE DEFAULT=fcitx export QT_IM_MODULE DEFAULT=fcitx export XMODIFIERS DEFAULT=@im=fcitx export INPUT_METHOD DEFAULT=fcitx export SDL_IM_MODULE DEFAULT=fcitx export QT_QPA_PLATFORM=xcb 然后重启钉钉即可。 之后电脑重启，老毛病又犯了，然后我又去撩了阿里的大佬，得到了解决办法，打开fcitx5的配置-\u003e全局选项-\u003e行为-\u003e勾选“默认状态为激活”-\u003e共享输入状态选“所有”,一套下来搞定！！ ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:2:1","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#钉钉不能输入中文"},{"categories":[],"content":" 喷脑浆IntelliJ系列IDE输入问题此问题的根本原因是 IDE 附带的 JBR 不正确，要处理此问题，需要： 前往 这里 下载 jbr 并解压到任意路径 更改 IDE 的 JBR,启动IDE后快捷键ctrl+shift+A , 输入 Choose Boot Java Runtime for the IDE，选择Add Custom Runtime option，选择解压出的文件夹。 ","date":"2022-07-12","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/:2:2","series":[],"tags":[],"title":"Ubuntu20.04安装fcitx5","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85fcitx5/#喷脑浆intellij系列ide输入问题"},{"categories":[],"content":"最近事多，整天瞎忙，都是沟通、开会、填表格和填坑，今天想休息休息，打算有空再写写后端服务，把自己的网盘和图床先弄好。思来想去，自己一个人的项目，时间少，所以尽量还是要方便维护，那么就不要用JAVA了，罗里吧嗦的，可惜Dart这边没什么好的框架，要不然一个语言全站了，最终还是选择了kotlin，但是又不想用idea，于是我瞄向了vscode… ","date":"2022-07-07","objectID":"/vscode%E7%BC%96%E5%86%99kotlin/:0:0","series":[],"tags":[],"title":"vscode+gradle+kotlin","uri":"/vscode%E7%BC%96%E5%86%99kotlin/#"},{"categories":[],"content":" IDE和技术选型由于idea太贵了，今年又涨价了，并且破解经常失效，总是突然把我搞的焦头烂额的，所以很反感这类收费的IDE。 后来转回eclipse，发现这货慢、丑、笨，于是又开始尝试宇宙第一IDE的小老弟——vscode。 一开始，尝试用vscode写了几个java微服务，真叫香啊，仿佛就是天生为SpringCloud而生的。但是Spring本身生态混乱，庞大，笨拙，比如注册中心我采用阿里的nacos，鉴权中心采用keycloak，这俩货本身是脱离SpringCloud而独立存在的，再加上熔断、网关等等，我的项目就是家里几个人用，我何必这么卷自己呢？况且我的小树莓派也不一定吃的消。 后来陆续又尝试了Dart的两个后端框架，官方维护的跟狗屎一样，又尝试了红帽的Quarkus，也是太庞大复杂了。 最后又看了一下Kotlin这边倒是出现了一个新框架叫ktor，设计的挺清奇的，用起来也还不错，生态基本也算健全。 那么现在唯一的问题就是IDE的选择了。在网上搜vscode开发kotlin，基本都是基于codeRunner，这个东西实在太幼稚了…于是乎，一年过去了我的项目还没落地，艹！ 时间来到最近，我看了几篇在vscode上搭建c++环境的文章，根本不需要什么codeRunner，今天闲下来突然灵机一动，我照猫画虎，终于搞定了！✌🏻 ","date":"2022-07-07","objectID":"/vscode%E7%BC%96%E5%86%99kotlin/:1:0","series":[],"tags":[],"title":"vscode+gradle+kotlin","uri":"/vscode%E7%BC%96%E5%86%99kotlin/#ide和技术选型"},{"categories":[],"content":" 插件选择需要这个和这个 目前最好用的kotlin-languageServer，还带代码补全（聊胜于无）和lint还有debug。 另一个是巨硬官方的gradle插件，稳定性可靠。 ","date":"2022-07-07","objectID":"/vscode%E7%BC%96%E5%86%99kotlin/:2:0","series":[],"tags":[],"title":"vscode+gradle+kotlin","uri":"/vscode%E7%BC%96%E5%86%99kotlin/#插件选择"},{"categories":[],"content":" gradle环境变量在这里下载gradle，尽量选择正式的高版本的，解压，然后设置环境变量： export GRADLE_HOME=/Users/vee/Library/gradle-7.4.2 export PATH=$PATH:$GRADLE_HOME/bin windows怎么设置自己去查，我不会用windows。 然后终端source .profile 最后终端执行命令gradle看看成功没。 ","date":"2022-07-07","objectID":"/vscode%E7%BC%96%E5%86%99kotlin/:3:0","series":[],"tags":[],"title":"vscode+gradle+kotlin","uri":"/vscode%E7%BC%96%E5%86%99kotlin/#gradle环境变量"},{"categories":[],"content":" gradle创建kotlin项目 gradle init --type kotlin-application 跟着提示一直走。 ","date":"2022-07-07","objectID":"/vscode%E7%BC%96%E5%86%99kotlin/:4:0","series":[],"tags":[],"title":"vscode+gradle+kotlin","uri":"/vscode%E7%BC%96%E5%86%99kotlin/#gradle创建kotlin项目"},{"categories":[],"content":" vscode配置cd到项目根目录，然后直接code .，就可以在vscode中打开项目了。 然后vscode的菜单栏-\u003e终端-\u003e配置默认生成任务-》gradle:app:build，一顿操作猛如狗，就会发现项目根目录多了一个.vscode/tasks.json,如果是多moudle工程，可以在这个文件的tasks数组里面照猫画虎再添加个task就行了。 { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"gradle\", \"id\": \"/Users/vee/Downloads/testapp:buildapp\", \"script\": \"app:build\", \"description\": \"Assembles and tests this project.\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"project\": \"app\", \"buildFile\": \"/Users/vee/Downloads/test/app/build.gradle.kts\", \"rootProject\": \"test\", \"projectFolder\": \"/Users/vee/Downloads/test\", \"workspaceFolder\": \"/Users/vee/Downloads/test\", \"args\": \"\", \"javaDebug\": false, \"problemMatcher\": [ \"$gradle\" ], \"label\": \"gradle: app:build\" } ] } 接下来在相同目录下创建一个launch.json文件，文件内容如下： { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"kotlin\", \"request\": \"launch\", \"name\": \"Kotlin Launch\", \"projectRoot\": \"${workspaceFolder}/app\", \"mainClass\": \"MyKotlinTest.AppKt\", \"preLaunchTask\": \"gradle: app:build\" } ] } 首先添加preLaunchTask字段，值就是刚才task的label，要原封不动的复制过来。 然后修改projectRoot字段，他默认是\"${workspaceFolder}\"，这是vscode中的环境变量，表示项目的根目录。但是gradle的文件结构是多了一层app目录的，所以需要在后面添加app路径。 最后修改mainClass字段，这个字段表示程序入口类，值是入口类的全名称（包名+文件名）。由于是kotlin类型的文件，后缀名都是.kt，所以类名要加上Kt后缀，这是kotlin插件要求的，真tm思路清奇。 最后放心直接按F5，当然我的touch bar上直接显示了play按钮，点他一下，就可以看到程序自动build，并且运行了✌🏻 ","date":"2022-07-07","objectID":"/vscode%E7%BC%96%E5%86%99kotlin/:5:0","series":[],"tags":[],"title":"vscode+gradle+kotlin","uri":"/vscode%E7%BC%96%E5%86%99kotlin/#vscode配置"},{"categories":[],"content":" 后记9点回来，弄好环境，去洗了个香香，然后洗袜子，洗内裤，拖地，回来写blog，一看表又12点半了，睡吧，明天继续去编译系统了。 ","date":"2022-07-07","objectID":"/vscode%E7%BC%96%E5%86%99kotlin/:6:0","series":[],"tags":[],"title":"vscode+gradle+kotlin","uri":"/vscode%E7%BC%96%E5%86%99kotlin/#后记"},{"categories":[],"content":" adb客户端环境变量 # ANDROID_HOME export ANDROID_HOME=$ENV_HOME/Android # android-sdk export ANDROID_SDK_ROOT=${ANDROID_HOME}/sdk export PATH=$PATH:$ANDROID_SDK_ROOT/platform-tools:$ANDROID_SDK_ROOT/tools 把sdk中的platform-tools和tools加入PATH即可。 ","date":"2022-07-07","objectID":"/adb/:1:0","series":[],"tags":[],"title":"adb","uri":"/adb/#adb客户端环境变量"},{"categories":[],"content":" adb的组成 客户端：位于电脑，用于发送命令； 服务器：位于电脑，用于管理客户端与守护进程之间的通信； adbd：位于设备，守护进程，用于在设备上运行命令。 执行过程： 我在终端中，通过adb命令向客户端输入命令； 客户端检查服务器是否运行，没有则启动服务器进程； 服务器进程与本地TCP端口5037绑定，并监听客户端发出的命令，双方基于5037通信； 服务器通过扫描设备的5555～5585之间的奇数号端口查找模拟器，发现adbd后建立连接； 此时客户端可以通过adb命令控制设备。 ","date":"2022-07-07","objectID":"/adb/:2:0","series":[],"tags":[],"title":"adb","uri":"/adb/#adb的组成"},{"categories":[],"content":" wifi-adb","date":"2022-07-07","objectID":"/adb/:3:0","series":[],"tags":[],"title":"adb","uri":"/adb/#wifi-adb"},{"categories":[],"content":" Android11及以上 设备上，开发者模式，启动无线调试，选择Pair device with pairing code；记下设备的IP、端口号和配对码； 运行adb pair ipaddr:port，出现提示时输入配对码。 ","date":"2022-07-07","objectID":"/adb/:3:1","series":[],"tags":[],"title":"adb","uri":"/adb/#android11及以上"},{"categories":[],"content":" Android11以下 usb线连设； 执行adb tcpip 5555来监听设备的5555； 拔线 执行adb connect device_ip_addresss:5555，其实很多情况下我都不加端口，默认就是5555； 执行adb devices确认连接成功。 ","date":"2022-07-07","objectID":"/adb/:3:2","series":[],"tags":[],"title":"adb","uri":"/adb/#android11以下"},{"categories":[],"content":" 常用adb命令 adb kill-server 杀掉adb服务器。 adb start-server 启动adb服务器，一般不需要用。 adb devices -l 查询设备,-l参数可打印出更多的信息。 adb -s \u003cdevice serial\u003e 多个设备中指定一个设备。 adb -e 多个设备中只有一个模拟器，则指定模拟器。 adb -d 多个设备中只有一个硬件，则指定硬件。 adb connect \u003cip:port\u003e 连接一个设备。 adb disconnect 断连所有设备。 adb install apk_file_path 把apk安装到用户分区data/data。 adb uninstall \u003cpackage name\u003e 通过包名卸载App。 adb forward tcp:6100 tcp:7100 端口转发。 adb pull remote local 拉取设备文件。 adb push local remote 推送本地文件到设备，会覆盖设备同名文件。 adb --help 调取帮助信息。 adb [-d|-e|-s] shell 进入设备的shell。 adb [-d|-e|-s] shell \u003ccommand\u003e 向设备发送shell指令。 exit 或者快捷键control+D退出shell。 adb root 同 adb shell su 启动管理员权限。 adb unroot 取消管理员权限。 adb remount 重新挂在system分区，system分区默认只读，remount之后变为读写权限。 adb disable-verity -R 关闭分区检测，需要root权限，重启生效，-R表示自动重启。 adb reboot [bootloader|recovery|sideload|sideload-auto-reboot] 设备重启。 adb logcat 抓取log。 ","date":"2022-07-07","objectID":"/adb/:4:0","series":[],"tags":[],"title":"adb","uri":"/adb/#常用adb命令"},{"categories":[],"content":" adb shell","date":"2022-07-07","objectID":"/adb/:5:0","series":[],"tags":[],"title":"adb","uri":"/adb/#adb-shell"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile \u003cfilePath\u003e 启动性能剖析器并将结果发送至file -P \u003cfile\u003e 同上，但当应用空闲时停止 -R \u003ccount\u003e 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user \u003cuserID\u003e|currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user \u003cuserID\u003e|currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#activitymanageram"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#启动activity"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#启动service"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#终止进程"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#发送广播"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#性能监控"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#系统监视"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#调整显示"},{"categories":[],"content":" ActivityManager(am) 启动Activity start [options] intent option description -D 启用调试 -W 等待启动完成 –start-profile 启动性能剖析器并将结果发送至file -P 同上，但当应用空闲时停止 -R 启动Activity count次 -S 启动Activity前强行停止目标应用 –opengl-trace 启用OpenGL汉书追踪 –user |currnet 指定作为哪个用户运行。默认current 启动Service startservice [options] intent option description –user |currnet 指定作为哪个用户运行。默认current 终止进程 force-stop [package] // 强制停止包名相关的所有进程 kill [--user userID|all|current] [package] //安全终止包名相关进程，可指定用户，默认all kill-all //终止所有后台进程 发送广播 broadcast [--user userID|all|current] intent 性能监控 profile start [process] [file]//启动进程的性能剖析器，结果写入文件 profile stop [process]//停止性能剖析 系统监视 monitor [--gdb] //开始监控崩溃或ANR,---gdb参数可在给定的端口上启动gdbserv 调整显示 screen-compat {on | off} package //控制 package 的屏幕兼容性模式。 display-size [reset | widthxheight] //替换设备显示尺寸 display-density dpi //替换设备显示密度 主要用于在大屏上调试小屏应用，或者反过来。 查看intent规范 to-uri intent to-intent-uri intent ","date":"2022-07-07","objectID":"/adb/:5:1","series":[],"tags":[],"title":"adb","uri":"/adb/#查看intent规范"},{"categories":[],"content":" PackageManager(pm) 列出软件包 list packages [options] [filter] option description -f 查看关联文件 -d 只显示已停用的包 -e 只显示已启用的包 -s 只显示系统应用 -3 只显示第三方软件 -i 查看软件包安装程序 -u 包含已卸载的软件 –user userID 查询指定用户空间 查看权限组 list permission-groups list permissions [options] group option description -g 按组整理 -f 输出所有信息 -s 输出摘要 -d 列出危险权限 -u 列出用户能看到的权限 查找应用安装路径 path [package] 安装软件 install [options] [path] option description -r 重装应用保留数据 -t 允许安装debug包 -d 允许降级安装 -g 授予应用清单中的所有权限 –fastdeploy 只更新差异 卸载软件 uninstall [-k] [package] //-k表示保留数据 clear [package] // 删除数据 ","date":"2022-07-07","objectID":"/adb/:5:2","series":[],"tags":[],"title":"adb","uri":"/adb/#packagemanagerpm"},{"categories":[],"content":" PackageManager(pm) 列出软件包 list packages [options] [filter] option description -f 查看关联文件 -d 只显示已停用的包 -e 只显示已启用的包 -s 只显示系统应用 -3 只显示第三方软件 -i 查看软件包安装程序 -u 包含已卸载的软件 –user userID 查询指定用户空间 查看权限组 list permission-groups list permissions [options] group option description -g 按组整理 -f 输出所有信息 -s 输出摘要 -d 列出危险权限 -u 列出用户能看到的权限 查找应用安装路径 path [package] 安装软件 install [options] [path] option description -r 重装应用保留数据 -t 允许安装debug包 -d 允许降级安装 -g 授予应用清单中的所有权限 –fastdeploy 只更新差异 卸载软件 uninstall [-k] [package] //-k表示保留数据 clear [package] // 删除数据 ","date":"2022-07-07","objectID":"/adb/:5:2","series":[],"tags":[],"title":"adb","uri":"/adb/#列出软件包"},{"categories":[],"content":" PackageManager(pm) 列出软件包 list packages [options] [filter] option description -f 查看关联文件 -d 只显示已停用的包 -e 只显示已启用的包 -s 只显示系统应用 -3 只显示第三方软件 -i 查看软件包安装程序 -u 包含已卸载的软件 –user userID 查询指定用户空间 查看权限组 list permission-groups list permissions [options] group option description -g 按组整理 -f 输出所有信息 -s 输出摘要 -d 列出危险权限 -u 列出用户能看到的权限 查找应用安装路径 path [package] 安装软件 install [options] [path] option description -r 重装应用保留数据 -t 允许安装debug包 -d 允许降级安装 -g 授予应用清单中的所有权限 –fastdeploy 只更新差异 卸载软件 uninstall [-k] [package] //-k表示保留数据 clear [package] // 删除数据 ","date":"2022-07-07","objectID":"/adb/:5:2","series":[],"tags":[],"title":"adb","uri":"/adb/#查看权限组"},{"categories":[],"content":" PackageManager(pm) 列出软件包 list packages [options] [filter] option description -f 查看关联文件 -d 只显示已停用的包 -e 只显示已启用的包 -s 只显示系统应用 -3 只显示第三方软件 -i 查看软件包安装程序 -u 包含已卸载的软件 –user userID 查询指定用户空间 查看权限组 list permission-groups list permissions [options] group option description -g 按组整理 -f 输出所有信息 -s 输出摘要 -d 列出危险权限 -u 列出用户能看到的权限 查找应用安装路径 path [package] 安装软件 install [options] [path] option description -r 重装应用保留数据 -t 允许安装debug包 -d 允许降级安装 -g 授予应用清单中的所有权限 –fastdeploy 只更新差异 卸载软件 uninstall [-k] [package] //-k表示保留数据 clear [package] // 删除数据 ","date":"2022-07-07","objectID":"/adb/:5:2","series":[],"tags":[],"title":"adb","uri":"/adb/#查找应用安装路径"},{"categories":[],"content":" PackageManager(pm) 列出软件包 list packages [options] [filter] option description -f 查看关联文件 -d 只显示已停用的包 -e 只显示已启用的包 -s 只显示系统应用 -3 只显示第三方软件 -i 查看软件包安装程序 -u 包含已卸载的软件 –user userID 查询指定用户空间 查看权限组 list permission-groups list permissions [options] group option description -g 按组整理 -f 输出所有信息 -s 输出摘要 -d 列出危险权限 -u 列出用户能看到的权限 查找应用安装路径 path [package] 安装软件 install [options] [path] option description -r 重装应用保留数据 -t 允许安装debug包 -d 允许降级安装 -g 授予应用清单中的所有权限 –fastdeploy 只更新差异 卸载软件 uninstall [-k] [package] //-k表示保留数据 clear [package] // 删除数据 ","date":"2022-07-07","objectID":"/adb/:5:2","series":[],"tags":[],"title":"adb","uri":"/adb/#安装软件"},{"categories":[],"content":" PackageManager(pm) 列出软件包 list packages [options] [filter] option description -f 查看关联文件 -d 只显示已停用的包 -e 只显示已启用的包 -s 只显示系统应用 -3 只显示第三方软件 -i 查看软件包安装程序 -u 包含已卸载的软件 –user userID 查询指定用户空间 查看权限组 list permission-groups list permissions [options] group option description -g 按组整理 -f 输出所有信息 -s 输出摘要 -d 列出危险权限 -u 列出用户能看到的权限 查找应用安装路径 path [package] 安装软件 install [options] [path] option description -r 重装应用保留数据 -t 允许安装debug包 -d 允许降级安装 -g 授予应用清单中的所有权限 –fastdeploy 只更新差异 卸载软件 uninstall [-k] [package] //-k表示保留数据 clear [package] // 删除数据 ","date":"2022-07-07","objectID":"/adb/:5:2","series":[],"tags":[],"title":"adb","uri":"/adb/#卸载软件"},{"categories":[],"content":" 截屏/录屏 screencap \u003cfilepath\u003e // 截屏到文件 screenrecord [options] \u003cfilepath\u003e // 录屏 可以通过control+C停止，或者通过--time-limit设置时间，默认3分钟。 ","date":"2022-07-07","objectID":"/adb/:5:3","series":[],"tags":[],"title":"adb","uri":"/adb/#截屏录屏"},{"categories":[],"content":" 附录：help信息 Android Debug Bridge version 1.0.41 Version 33.0.2-8557947 Installed as /home/vee/.env/Android/sdk/platform-tools/adb global options: -a listen on all network interfaces, not just localhost -d use USB device (error if multiple devices connected) -e use TCP/IP device (error if multiple TCP/IP devices available) -s SERIAL use device with given serial (overrides $ANDROID_SERIAL) -t ID use device with given transport id -H name of adb server host [default=localhost] -P port of adb server [default=5037] -L SOCKET listen on given socket for adb server [default=tcp:localhost:5037] --one-device SERIAL|USB only allowed with 'start-server' or 'server nodaemon', server will only connect to one USB device, specified by a serial number or USB device address. --exit-on-write-error exit if stdout is closed general commands: devices [-l] list connected devices (-l for long output) help show this help message version show version num networking: connect HOST[:PORT] connect to a device via TCP/IP [default port=5555] disconnect [HOST[:PORT]] disconnect from given TCP/IP device [default port=5555], or all pair HOST[:PORT] [PAIRING CODE] pair with a device for secure TCP/IP communication forward --list list all forward socket connections forward [--no-rebind] LOCAL REMOTE forward socket connection using: tcp:\u003cport\u003e (\u003clocal\u003e may be \"tcp:0\" to pick any open port) localabstract:\u003cunix domain socket name\u003e localreserved:\u003cunix domain socket name\u003e localfilesystem:\u003cunix domain socket name\u003e jdwp:\u003cprocess pid\u003e (remote only) vsock:\u003cCID\u003e:\u003cport\u003e (remote only) acceptfd:\u003cfd\u003e (listen only) forward --remove LOCAL remove specific forward socket connection forward --remove-all remove all forward socket connections ppp TTY [PARAMETER...] run PPP over USB reverse --list list all reverse socket connections from device reverse [--no-rebind] REMOTE LOCAL reverse socket connection using: tcp:\u003cport\u003e (\u003cremote\u003e may be \"tcp:0\" to pick any open port) localabstract:\u003cunix domain socket name\u003e localreserved:\u003cunix domain socket name\u003e localfilesystem:\u003cunix domain socket name\u003e reverse --remove REMOTE remove specific reverse socket connection reverse --remove-all remove all reverse socket connections from device mdns check check if mdns discovery is available mdns services list all discovered services file transfer: push [--sync] [-z ALGORITHM] [-Z] LOCAL... REMOTE copy local files/directories to device --sync: only push files that are newer on the host than the device -n: dry run: push files to device without storing to the filesystem -z: enable compression with a specified algorithm (any/none/brotli/lz4/zstd) -Z: disable compression pull [-a] [-z ALGORITHM] [-Z] REMOTE... LOCAL copy files/dirs from device -a: preserve file timestamp and mode -z: enable compression with a specified algorithm (any/none/brotli/lz4/zstd) -Z: disable compression sync [-l] [-z ALGORITHM] [-Z] [all|data|odm|oem|product|system|system_ext|vendor] sync a local build from $ANDROID_PRODUCT_OUT to the device (default all) -n: dry run: push files to device without storing to the filesystem -l: list files that would be copied, but don't copy them -z: enable compression with a specified algorithm (any/none/brotli/lz4/zstd) -Z: disable compression shell: shell [-e ESCAPE] [-n] [-Tt] [-x] [COMMAND...] run remote shell command (interactive shell if no command given) -e: choose escape character, or \"none\"; default '~' -n: don't read from stdin -T: disable pty allocation -t: allocate a pty if on a tty (-tt: force pty allocation) -x: disable remote exit codes and stdout/stderr separation emu COMMAND run emulator console command app installation (see also `adb shell cmd package help`): install [-lrtsdg] [--instant] PACKAGE push a single package to the device and install it install-multiple [-lrtsdpg] [--instant] PACKAGE... push multiple APKs to the device for a single package and install them install-multi-package [-lrtsdpg] [--instant] PACKAGE... push one or more packages to the device and install them atomical","date":"2022-07-07","objectID":"/adb/:6:0","series":[],"tags":[],"title":"adb","uri":"/adb/#附录help信息"},{"categories":[],"content":"今天是我过得非常不爽的一天，因为今天说了『我不会』『我不懂』『我看不明白』，从哥2017年自学安卓到现在，从一点不会到基本不百度，我还没说过这些话。今天真是太刺激了，从上层转底层真的这么费劲吗，还是说年纪大了学不动了？都不是，是我一开始学系统底层还没找到要领，同时又事物缠身，分身无术。仔细想想还是先从常用工具入手，别他妈让我抓个log都这么费劲。 ","date":"2022-07-06","objectID":"/logcat/:0:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#"},{"categories":[],"content":" logcat是什么就是Android-sdk提供的抓取log的工具，位于Android/sdk/platform-tools/adb. ","date":"2022-07-06","objectID":"/logcat/:1:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#logcat是什么"},{"categories":[],"content":" logcat启动方式","date":"2022-07-06","objectID":"/logcat/:2:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#logcat启动方式"},{"categories":[],"content":" adb方式 adb logcat ","date":"2022-07-06","objectID":"/logcat/:2:1","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#adb方式"},{"categories":[],"content":" shell方式 adb shell logcat ","date":"2022-07-06","objectID":"/logcat/:2:2","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#shell方式"},{"categories":[],"content":" logcat帮助 adb logcat --help ","date":"2022-07-06","objectID":"/logcat/:3:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#logcat帮助"},{"categories":[],"content":" 缓冲区 buffer description radio 无线装置/电话短信 events 二进制系统事件 main 主日志缓冲区，不包含系统和崩溃 system 系统 crash 崩溃 all 所有 default 默认，包含main、system、crash ","date":"2022-07-06","objectID":"/logcat/:4:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#缓冲区"},{"categories":[],"content":" 命令格式 logcat [options] [filterspecs] 注意，这里的options可以有多个。 ","date":"2022-07-06","objectID":"/logcat/:5:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#命令格式"},{"categories":[],"content":" 选项 option description -b 加载可供查看的日志缓冲区 -g 输出日志缓冲区信息 -c 清楚所选的缓冲区并退出，默认缓冲区集合为main、system、crash,清楚所有缓冲区则使用-b all -c -e \u003cexpr\u003e 抓取正则表达式匹配的行 -m \u003ccount\u003e 输出\u003ccount\u003e行后退出，可与-e配合使用 -d 将缓冲区的log转存到屏幕后退出 -f \u003cfilePath\u003e 将日志写入文件，默认文件名为stdout，像不像std::cout -s 过滤，一会详细了解一下 -v \u003cformat\u003e 设置日志的输出格式，默认为threadtime -D 输出日志时给各个缓冲区之间加个分割线来区分，推荐使用 -t \u003ccount\u003e 仅输出最新的行数，包含-d -t \u003ctime\u003e 输出指定时间锚点以来的最新行，包含-d，如：adb logcat -t ‘01-26 20:52:41.820’ -T 与-t一致，不包含-d -L 在最后一次重启之前转存log -B 以二进制文件输出日志 -S 输出统计信息 -G 设置日志缓冲区大小，单位是K或M –pid=\u003cpid\u003e 仅输出指定pid的log ","date":"2022-07-06","objectID":"/logcat/:6:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#选项"},{"categories":[],"content":" 过滤","date":"2022-07-06","objectID":"/logcat/:7:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#过滤"},{"categories":[],"content":" 优先级与TAG以下是log的优先级，与AS中对应： priority description V 详细 D 调试 I 信息 W 警告 E 错误 F 严重错误 S 静默，毛没有 TAG不用解释了，我懂得。 格式： \u003cpriority\u003e/\u003ctag\u003e eg: adb logcat ActivityManager:I MyApp:D *:S 显示tag为ActivityManager并且等级是I以上的日志；和tag为MyApp并且等级为D以上的日志；与此同时，通过*:S让其他日志静默。 注意这里，实测用tag过滤后，并不能阻止其他日志的出现，所以后面必须加*:S才能单独显示tag标记后的日志。 ","date":"2022-07-06","objectID":"/logcat/:7:1","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#优先级与tag"},{"categories":[],"content":" 格式控制可以通过-v参数控制日志输出的格式。 format description brief priority+tag+PID long 元数据字段，并使用空白行区分 process PID raw 不包含其他元数据的原始日志消息 tag priority+tag thread priority+PID+TID threadtime 默认，time+priority+tag+PID+TID time date+time+priority+tag+PID ","date":"2022-07-06","objectID":"/logcat/:8:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#格式控制"},{"categories":[],"content":" logcat导出 adb logcat -d \u003ewzj.txt ","date":"2022-07-06","objectID":"/logcat/:9:0","series":[],"tags":[],"title":"Logcat","uri":"/logcat/#logcat导出"},{"categories":[],"content":" 安装Repo","date":"2022-06-29","objectID":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/:1:0","series":[],"tags":[],"title":"Ubuntu22.04安装配置repo","uri":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/#安装repo"},{"categories":[],"content":" apt安装（不推荐） sudo apt-get update sudo apt-get install repo 实测apt安装非常方便，而且能自动配置好环境变量。但是ubuntu22.04LTS源上的版本是比较旧，对我这种新潮党很不友好。 ","date":"2022-06-29","objectID":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/:1:1","series":[],"tags":[],"title":"Ubuntu22.04安装配置repo","uri":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/#apt安装不推荐"},{"categories":[],"content":" 下载安装在用户根目录下创建一个bin目录： mkdir ~/bin 不需要修改，直接执行以下命令： export REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-key 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026\u0026 install -m 755 ${REPO} ~/bin/repo 这些命令会设置一个临时文件，将 Repo 下载到该文件中，并验证提供的密钥是否与所需的密钥匹配。如果这些步骤成功完成，就会继续进行安装。 mktemp命令可查看https://www.runoob.com/linux/linux-comm-mktemp.html 这一步执行完毕之后，在bin目录下就会出现一个repo文件，它是个python可执行文件。 我们用任何编辑器打开它，比如我喜欢vscode： cd ~/bin code repo 在文件顶端第一行有格式声明，我下载的repo用的是python2,但是我的ubuntu只安装了python3,所以需要把2改成3： #!/usr/bin/env python 改为： #!/usr/bin/env python3 之后，由于repo在初始化时默认访问google地址，速度非常慢，所以需要改成清华的镜像，在repo文件内把https://gerrit.googlesource.com/git-repo替换成https://mirrors.tuna.tsinghua.edu.cn/git/git-repo，并保存。 REPO_URL = os.environ.get('REPO_URL', None) if not REPO_URL: # REPO_URL = 'https://gerrit.googlesource.com/git-repo' REPO_URL = 'https://mirrors.tuna.tsinghua.edu.cn/git/git-repo' REPO_REV = os.environ.get('REPO_REV') if not REPO_REV: REPO_REV = 'stable' # URL to file bug reports for repo tool issues. BUG_URL = 'https://bugs.chromium.org/p/gerrit/issues/entry?template=Repo+tool+issue' Python是一种强格式语言，所以替换的时候一定要注意缩进的位数与之前一致。 最后查看一下repo版本号，验证是否安装成功： repo version ","date":"2022-06-29","objectID":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/:1:2","series":[],"tags":[],"title":"Ubuntu22.04安装配置repo","uri":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/#下载安装"},{"categories":[],"content":" 下载安卓源码","date":"2022-06-29","objectID":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/:2:0","series":[],"tags":[],"title":"Ubuntu22.04安装配置repo","uri":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/#下载安卓源码"},{"categories":[],"content":" 初始化Repo创建一个空目录来存放您的工作文件。为其指定一个您喜欢的任意名称： mkdir WORKING_DIRECTORY cd WORKING_DIRECTORY git需要配置全局名称和邮箱： git config --global user.name Your Name git config --global user.email you@example.com 运行repo init更新repo,并为repo指定一个网址： repo init -u https://android.googlesource.com/platform/manifest 据说从google仓库下载会非常慢，而且很容易失败，幸好公司这边已经有了😀： repo init -u \"git://10.53.131.102/platform/manifest\" -b android-9.0.0_r46 最后同步Android源码： repo sync 更快的方式，加上参数: -c 表示从当前分支同步 -j8 表示启动8个线程并发同步 repo sync -c -j8 执行之后，发现好慢，抽烟去了。 ","date":"2022-06-29","objectID":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/:2:1","series":[],"tags":[],"title":"Ubuntu22.04安装配置repo","uri":"/ubuntu22.04%E5%AE%89%E8%A3%85repo/#初始化repo"},{"categories":[],"content":" 分区概念现在了解到安卓系统大概分三个分区： system/priv-app:系统预置分区 vendor/app：厂商预置分区 data:用户软件分区 平时我们靠adb安装的apk，都会装到data中，会覆盖掉另外两个分器的预置apk。 当卸载时，也只会卸载掉用户分区的apk，不会影响另外两个分区。当卸载掉用户分区的apk后，预置的同包名apk就会暴露出来，让人有种垃圾软件卸载不掉的感觉。 ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:1:0","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#分区概念"},{"categories":[],"content":" 调试时的安装卸载方式以下两种方式都只能卸载用户分区的apk，只有第三种实测可删除system和vendor中的apk。 ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:0","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#调试时的安装卸载方式"},{"categories":[],"content":" adb方式安卓调试桥： adb install [package name] adb uninstall [package name] ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:1","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#adb方式"},{"categories":[],"content":" pm方式PackageManager包管理器： adb shell pm install [package name] pm uninstall [package name] ### shell方式 ```shell adb shell cd xxxx rm xxx.xx ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:2","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#pm方式"},{"categories":[],"content":" 获取root权限 adb root ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:3","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#获取root权限"},{"categories":[],"content":" 重新挂载system分区因为android系统的system分区在启动之后是只读分区，但在开发过程中需要对system分区进行修改，则需重新挂载成读写模式。 比如Android9.0启动了系统验证，因此在替换vendor目录内容时需要先禁止系统验证，并重新挂载system分区： adb root adb remount adb disable-verity adb reboot adb root adb remount ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:4","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#重新挂载system分区"},{"categories":[],"content":" 文件传输这里通常用来传输apk文件。 adb pull [目标设备文件] [本地路径] adb push [本地文件] [目标设备路径] ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:5","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#文件传输"},{"categories":[],"content":" md5验证apk由于替换system/vendor，我们不知道替换成功没有，这时就需要对比操作前后的apk的md5: md5sum 文件 如果文件有改动，其md5必定与最之前的不同，说明替换成功。 ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:6","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#md5验证apk"},{"categories":[],"content":" 抓log由于现在很多东西都装在vendor，安装尚且困难，更别提挂端点调试了，也不会看到任何log，这时候就需要我们主动抓取log： ","date":"2022-06-17","objectID":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/:2:7","series":[],"tags":[],"title":"Android9刷写vendor中的apk","uri":"/android9%E5%88%B7%E5%86%99vendor%E4%B8%AD%E7%9A%84apk/#抓log"},{"categories":[],"content":" yuml类图基本格式 // {type:class} // {direction:topDown} // {generate:true} [note: You can stick notes on diagrams too!{bg:cornsilk}] [Customer]\u003c\u003e1-orders 0..*\u003e[Order] [Order]++*-*\u003e[LineItem] [Order]-1\u003e[DeliveryMethod] [Order]*-*\u003e[Product|EAN_Code|promo_price()] [Category]-.-\u003e[Product] [DeliveryMethod]^[National] [DeliveryMethod]^[International] 上面是个列子。 Item Example Class [Customer] Directional(单向关联) [Customer]-\u003e[Order] Bidirectional(双向关联) [Customer]\u003c-\u003e[Order] Aggregation(聚合) [Customer]+-[Order] or [Customer]\u003c\u003e-[Order] Composition(组合) [Customer]++-[Order] Inheritance(泛化) [Customer]^[Cool Customer] Dependencies(依赖) [Customer]uses-.-\u003e[PaymentStrategy] Cardinality [Customer]\u003c1-1..2\u003e[Address] Labels [Person]customer-billingAddress[Address] Notes [Address]-[note: Value Object] Full Class `[Customer Color splash [Customer{bg:orange}]\u003c\u003e1-\u003e*[Order{bg:green}] ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:1:0","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#yuml类图基本格式"},{"categories":[],"content":" 访问修饰符 修饰符 描述 + public - private # protected 无 package ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:2:0","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#访问修饰符"},{"categories":[],"content":" 关系","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:0","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#关系"},{"categories":[],"content":" 依赖关系表示一种临时性的，借助外部事物的【使用】关系，比如我们要打电话，此时需要一台手机，那么就是person依赖mobilePhone，但是人的身体里并没有手机，手机是外部的。一般在代码中的体现就是，某个类通过调用其他类的某些方法完成任务，叫做”某个类“依赖”其他类”。 // {type:class} [Customer]uses-.-\u003e[PaymentStrategy] ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:1","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#依赖关系"},{"categories":[],"content":" 泛化关系泛化关系式对象之间耦合度最大的关系，表示一种扩展（继承）关系，是符合is-a的关系。 表示为空心箭头： // {type:class} [Student]^[Person] ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:2","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#泛化关系"},{"categories":[],"content":" 实现关系接口与实现类的关系。 表示为虚线+空心箭头。 // {type:class} [Student]^[Person] ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:3","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#实现关系"},{"categories":[],"content":" 关联关系是对象之间的一种引用关系，表示一类对象与另一类对象之间的联系。JAVA中一般指类内部包含的属性，而这个属性一般是其他类型。 单向\u0026双向关联在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。 [Customer]\u003c-\u003e[Order] 表示为实线+实心箭头指向被关联的类。 聚合聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 表示为实线+空心菱形（指向整体）。 [Teacher]+-[University] 组合表示类之间的“整体”与“部分”的关系。是contains-a关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不对在，部分对象也将不存在，部分对象不能脱离整体对象而存在。 表示为实线+实心菱形指向整体。 ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:4","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#关联关系"},{"categories":[],"content":" 关联关系是对象之间的一种引用关系，表示一类对象与另一类对象之间的联系。JAVA中一般指类内部包含的属性，而这个属性一般是其他类型。 单向\u0026双向关联在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。 [Customer]\u003c-\u003e[Order] 表示为实线+实心箭头指向被关联的类。 聚合聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 表示为实线+空心菱形（指向整体）。 [Teacher]+-[University] 组合表示类之间的“整体”与“部分”的关系。是contains-a关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不对在，部分对象也将不存在，部分对象不能脱离整体对象而存在。 表示为实线+实心菱形指向整体。 ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:4","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#单向双向关联"},{"categories":[],"content":" 关联关系是对象之间的一种引用关系，表示一类对象与另一类对象之间的联系。JAVA中一般指类内部包含的属性，而这个属性一般是其他类型。 单向\u0026双向关联在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。 [Customer]\u003c-\u003e[Order] 表示为实线+实心箭头指向被关联的类。 聚合聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 表示为实线+空心菱形（指向整体）。 [Teacher]+-[University] 组合表示类之间的“整体”与“部分”的关系。是contains-a关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不对在，部分对象也将不存在，部分对象不能脱离整体对象而存在。 表示为实线+实心菱形指向整体。 ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:4","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#聚合"},{"categories":[],"content":" 关联关系是对象之间的一种引用关系，表示一类对象与另一类对象之间的联系。JAVA中一般指类内部包含的属性，而这个属性一般是其他类型。 单向\u0026双向关联在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。 [Customer]\u003c-\u003e[Order] 表示为实线+实心箭头指向被关联的类。 聚合聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 表示为实线+空心菱形（指向整体）。 [Teacher]+-[University] 组合表示类之间的“整体”与“部分”的关系。是contains-a关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不对在，部分对象也将不存在，部分对象不能脱离整体对象而存在。 表示为实线+实心菱形指向整体。 ","date":"2022-06-08","objectID":"/%E7%B1%BB%E5%9B%BE/:3:4","series":[],"tags":[],"title":"类图","uri":"/%E7%B1%BB%E5%9B%BE/#组合"},{"categories":[],"content":"前段时间面试滴滴的时候，跟面试官聊了一下属性动画，上来就问：你看过源码吗？我说没看过，然后他表示属性动画并不是真正的改变view的属性，原因是一个例子：在constraintlayout中，通过相互约束定义纵向的一列view，然后通过属性动画，让第一个view平移，你认为下面的view是否会跟着动？他的结论是从系统设计上，谷歌就不可能允许跟着动的情况，因为我们指定动画的目标就是第一个view，所以平移操作也应该局限在第一个view中，而不应该影响其他的view。我当时觉得他太牛逼了，能从源码想到设计思想，后面我还靠他这个结论去忽悠过其他人，而其他人也觉得我很牛逼，哈哈哈。今天心血来潮，自己写个demo测一下，通过属性动画去改view的x位置，结果下面的view真的没有跟着动，可是接下来的表现却让我瞠目结舌。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:0:0","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#"},{"categories":[],"content":" 使用方式","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:0","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#使用方式"},{"categories":[],"content":" ObjectAnimator \u0026 ValueAnimator class MainActivity : AppCompatActivity() { private lateinit var target: Button private lateinit var objectAni: ObjectAnimator private lateinit var valueAni: ValueAnimator private var type = 0 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) target = findViewById(R.id.btn_target) objectAni = ObjectAnimator.ofFloat(target, \"alpha\", 1f, 0f) valueAni = ValueAnimator.ofFloat(1f, 0f).apply { duration = 500 startDelay = 1000 repeatCount = 2 repeatMode = ValueAnimator.REVERSE addUpdateListener { val currentValue = it.animatedValue as Float target.alpha = currentValue target.invalidate() } setTarget(target) } } fun objectStart(v: View) { objectAni.start() type = 1 } fun valueStart(v: View) { valueAni.start() type = 2 } /** * 反转 */ fun reset(v: View) { when (type) { 1 -\u003e objectAni.reverse() 2 -\u003e valueAni.reverse() } } } 以上就是属性动画的用法，期中的ObjectAnimator是ValueAnimator的父类，而由于后者更加灵活，可复用程度更高，所以一般我们常用ValueAnimator。而ObjectAnimator呢，需要在创建时通过参数传递属性的名称，那不用猜也知道他用了运行时反射，而反射会带来更多的资源消耗，所以拉倒吧！ ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:1","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#objectanimator--valueanimator"},{"categories":[],"content":" 组合动画AnimatorSet after(Animator anim) ：在参数动画执行完之后再执行 after(long delay) ：参数动画执行完之后延迟执行 before(Animator anim)： 插入到参数动画之前执行 with(Animator anim) ：与参数动画同时执行 AnimatorSet aniset = new AnimatorSet(); aniset.play(ani2).with(ani3).before(ani1).after(ani0); ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:2","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#组合动画animatorset"},{"categories":[],"content":" 插值器与估值器插值器和估值器用来定义动画执行时的矢量动态，如加速度、重力、阻力、阻尼等。 eg: ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, \"rotation\", 0.0f, 360.0f); anim.setDuration(5000); anim.setInterpolator(new DecelerateAccelerateInterpolator()); anim.start(); 插值器：时间矢量插值器（Interpolator）用于定义动画随时间流逝的变化规律。 默认插值器 插值器 表现 AccelerateDecelerateInterpolator 先加速，后减速 LinearInterpolator 线性插值器，动画匀速运行 AccelerateInterpolator 加速插值器，动画加速运行至结束 DecelerateInterpolator 减速插值器，动画减速运行至结束 OvershootInterpolator 弹簧插值器，快速完成动画，超出终点一小部分后再回到终点 AnticipateInterpolator 发条插值器，先后退一小步再加速前进至结束 AnticipateOvershootInterpolator 板簧插值器，先后退一小步再加速前进，超出终点一小部分后再回到终点 BounceInterpolator 弹性插值器，在动画结束之前会有一个弹性动画的效果 CycleInterpolator 周期运动 自定义插值器需要实现接口： public interface TimeInterpolator { /** * 回调参数是动画执行时间的百分比 */ float getInterpolation(float input); } 估值器：起始矢量估值器（TypeEvaluator）的作用是定义从初始值过渡到结束值的计算规则。 自定义估值器需要实现接口： public interface TypeEvaluator\u003cT\u003e { public T evaluate(float fraction, T startValue, T endValue); } 参数fraction表示动画的完成度，实际上就是插值器中getInterpolation()方法的返回值。最后的返回值是在『当前完成度』这个条件之下的计算结果值。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:3","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#插值器与估值器"},{"categories":[],"content":" 插值器与估值器插值器和估值器用来定义动画执行时的矢量动态，如加速度、重力、阻力、阻尼等。 eg: ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, \"rotation\", 0.0f, 360.0f); anim.setDuration(5000); anim.setInterpolator(new DecelerateAccelerateInterpolator()); anim.start(); 插值器：时间矢量插值器（Interpolator）用于定义动画随时间流逝的变化规律。 默认插值器 插值器 表现 AccelerateDecelerateInterpolator 先加速，后减速 LinearInterpolator 线性插值器，动画匀速运行 AccelerateInterpolator 加速插值器，动画加速运行至结束 DecelerateInterpolator 减速插值器，动画减速运行至结束 OvershootInterpolator 弹簧插值器，快速完成动画，超出终点一小部分后再回到终点 AnticipateInterpolator 发条插值器，先后退一小步再加速前进至结束 AnticipateOvershootInterpolator 板簧插值器，先后退一小步再加速前进，超出终点一小部分后再回到终点 BounceInterpolator 弹性插值器，在动画结束之前会有一个弹性动画的效果 CycleInterpolator 周期运动 自定义插值器需要实现接口： public interface TimeInterpolator { /** * 回调参数是动画执行时间的百分比 */ float getInterpolation(float input); } 估值器：起始矢量估值器（TypeEvaluator）的作用是定义从初始值过渡到结束值的计算规则。 自定义估值器需要实现接口： public interface TypeEvaluator { public T evaluate(float fraction, T startValue, T endValue); } 参数fraction表示动画的完成度，实际上就是插值器中getInterpolation()方法的返回值。最后的返回值是在『当前完成度』这个条件之下的计算结果值。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:3","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#插值器时间矢量"},{"categories":[],"content":" 插值器与估值器插值器和估值器用来定义动画执行时的矢量动态，如加速度、重力、阻力、阻尼等。 eg: ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, \"rotation\", 0.0f, 360.0f); anim.setDuration(5000); anim.setInterpolator(new DecelerateAccelerateInterpolator()); anim.start(); 插值器：时间矢量插值器（Interpolator）用于定义动画随时间流逝的变化规律。 默认插值器 插值器 表现 AccelerateDecelerateInterpolator 先加速，后减速 LinearInterpolator 线性插值器，动画匀速运行 AccelerateInterpolator 加速插值器，动画加速运行至结束 DecelerateInterpolator 减速插值器，动画减速运行至结束 OvershootInterpolator 弹簧插值器，快速完成动画，超出终点一小部分后再回到终点 AnticipateInterpolator 发条插值器，先后退一小步再加速前进至结束 AnticipateOvershootInterpolator 板簧插值器，先后退一小步再加速前进，超出终点一小部分后再回到终点 BounceInterpolator 弹性插值器，在动画结束之前会有一个弹性动画的效果 CycleInterpolator 周期运动 自定义插值器需要实现接口： public interface TimeInterpolator { /** * 回调参数是动画执行时间的百分比 */ float getInterpolation(float input); } 估值器：起始矢量估值器（TypeEvaluator）的作用是定义从初始值过渡到结束值的计算规则。 自定义估值器需要实现接口： public interface TypeEvaluator { public T evaluate(float fraction, T startValue, T endValue); } 参数fraction表示动画的完成度，实际上就是插值器中getInterpolation()方法的返回值。最后的返回值是在『当前完成度』这个条件之下的计算结果值。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:3","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#默认插值器"},{"categories":[],"content":" 插值器与估值器插值器和估值器用来定义动画执行时的矢量动态，如加速度、重力、阻力、阻尼等。 eg: ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, \"rotation\", 0.0f, 360.0f); anim.setDuration(5000); anim.setInterpolator(new DecelerateAccelerateInterpolator()); anim.start(); 插值器：时间矢量插值器（Interpolator）用于定义动画随时间流逝的变化规律。 默认插值器 插值器 表现 AccelerateDecelerateInterpolator 先加速，后减速 LinearInterpolator 线性插值器，动画匀速运行 AccelerateInterpolator 加速插值器，动画加速运行至结束 DecelerateInterpolator 减速插值器，动画减速运行至结束 OvershootInterpolator 弹簧插值器，快速完成动画，超出终点一小部分后再回到终点 AnticipateInterpolator 发条插值器，先后退一小步再加速前进至结束 AnticipateOvershootInterpolator 板簧插值器，先后退一小步再加速前进，超出终点一小部分后再回到终点 BounceInterpolator 弹性插值器，在动画结束之前会有一个弹性动画的效果 CycleInterpolator 周期运动 自定义插值器需要实现接口： public interface TimeInterpolator { /** * 回调参数是动画执行时间的百分比 */ float getInterpolation(float input); } 估值器：起始矢量估值器（TypeEvaluator）的作用是定义从初始值过渡到结束值的计算规则。 自定义估值器需要实现接口： public interface TypeEvaluator { public T evaluate(float fraction, T startValue, T endValue); } 参数fraction表示动画的完成度，实际上就是插值器中getInterpolation()方法的返回值。最后的返回值是在『当前完成度』这个条件之下的计算结果值。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:3","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#自定义插值器"},{"categories":[],"content":" 插值器与估值器插值器和估值器用来定义动画执行时的矢量动态，如加速度、重力、阻力、阻尼等。 eg: ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, \"rotation\", 0.0f, 360.0f); anim.setDuration(5000); anim.setInterpolator(new DecelerateAccelerateInterpolator()); anim.start(); 插值器：时间矢量插值器（Interpolator）用于定义动画随时间流逝的变化规律。 默认插值器 插值器 表现 AccelerateDecelerateInterpolator 先加速，后减速 LinearInterpolator 线性插值器，动画匀速运行 AccelerateInterpolator 加速插值器，动画加速运行至结束 DecelerateInterpolator 减速插值器，动画减速运行至结束 OvershootInterpolator 弹簧插值器，快速完成动画，超出终点一小部分后再回到终点 AnticipateInterpolator 发条插值器，先后退一小步再加速前进至结束 AnticipateOvershootInterpolator 板簧插值器，先后退一小步再加速前进，超出终点一小部分后再回到终点 BounceInterpolator 弹性插值器，在动画结束之前会有一个弹性动画的效果 CycleInterpolator 周期运动 自定义插值器需要实现接口： public interface TimeInterpolator { /** * 回调参数是动画执行时间的百分比 */ float getInterpolation(float input); } 估值器：起始矢量估值器（TypeEvaluator）的作用是定义从初始值过渡到结束值的计算规则。 自定义估值器需要实现接口： public interface TypeEvaluator { public T evaluate(float fraction, T startValue, T endValue); } 参数fraction表示动画的完成度，实际上就是插值器中getInterpolation()方法的返回值。最后的返回值是在『当前完成度』这个条件之下的计算结果值。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:3","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#估值器起始矢量"},{"categories":[],"content":" 插值器与估值器插值器和估值器用来定义动画执行时的矢量动态，如加速度、重力、阻力、阻尼等。 eg: ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, \"rotation\", 0.0f, 360.0f); anim.setDuration(5000); anim.setInterpolator(new DecelerateAccelerateInterpolator()); anim.start(); 插值器：时间矢量插值器（Interpolator）用于定义动画随时间流逝的变化规律。 默认插值器 插值器 表现 AccelerateDecelerateInterpolator 先加速，后减速 LinearInterpolator 线性插值器，动画匀速运行 AccelerateInterpolator 加速插值器，动画加速运行至结束 DecelerateInterpolator 减速插值器，动画减速运行至结束 OvershootInterpolator 弹簧插值器，快速完成动画，超出终点一小部分后再回到终点 AnticipateInterpolator 发条插值器，先后退一小步再加速前进至结束 AnticipateOvershootInterpolator 板簧插值器，先后退一小步再加速前进，超出终点一小部分后再回到终点 BounceInterpolator 弹性插值器，在动画结束之前会有一个弹性动画的效果 CycleInterpolator 周期运动 自定义插值器需要实现接口： public interface TimeInterpolator { /** * 回调参数是动画执行时间的百分比 */ float getInterpolation(float input); } 估值器：起始矢量估值器（TypeEvaluator）的作用是定义从初始值过渡到结束值的计算规则。 自定义估值器需要实现接口： public interface TypeEvaluator { public T evaluate(float fraction, T startValue, T endValue); } 参数fraction表示动画的完成度，实际上就是插值器中getInterpolation()方法的返回值。最后的返回值是在『当前完成度』这个条件之下的计算结果值。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:3","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#自定义估值器"},{"categories":[],"content":" XML方式上面提到ObjectAnimator是靠反射的方式获取到View的属性，那么自然可以想到通过xml文件声明，然后同样靠反射获取到View的属性再赋值，于是有了通过定义xml文件的方式来玩动画的方案： 在res资源目录下创建一个xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003canimator android:duration=\"100\" android:repeatMode=\"reverse\"/\u003e \u003c/set\u003e 然后就可以填充动画了： val animator = AnimatorInflater.loadAnimator(this,R.animator.my_ani) ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:1:4","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#xml方式"},{"categories":[],"content":" 源码解读","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:2:0","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#源码解读"},{"categories":[],"content":" ValueAnimator 从ofFloat方法入手 // 注意这个 PropertyValuesHolder[] mValues; // 创建对象并赋值。 public static ValueAnimator ofFloat(float... values) { ValueAnimator anim = new ValueAnimator(); anim.setFloatValues(values); return anim; } // 赋值操作 public void setFloatValues(float... values) { if (values == null || values.length == 0) { return; } if (mValues == null || mValues.length == 0) { setValues(PropertyValuesHolder.ofFloat(\"\", values)); } else { PropertyValuesHolder valuesHolder = mValues[0]; valuesHolder.setFloatValues(values); } // New property/values/target should cause re-initialization prior to starting mInitialized = false; } 通过内存储存mValues这个数组的类型，和代码中赋值的方式，我们可以发现他用了一个类似RecyclerView的holder的方式做缓存和复用。 这里感觉要去复习一下View的相关知识才能继续写下去了，包括对View的一些新的理解，还有安卓整体的布局体系。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:2:1","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#valueanimator"},{"categories":[],"content":" ValueAnimator 从ofFloat方法入手 // 注意这个 PropertyValuesHolder[] mValues; // 创建对象并赋值。 public static ValueAnimator ofFloat(float... values) { ValueAnimator anim = new ValueAnimator(); anim.setFloatValues(values); return anim; } // 赋值操作 public void setFloatValues(float... values) { if (values == null || values.length == 0) { return; } if (mValues == null || mValues.length == 0) { setValues(PropertyValuesHolder.ofFloat(\"\", values)); } else { PropertyValuesHolder valuesHolder = mValues[0]; valuesHolder.setFloatValues(values); } // New property/values/target should cause re-initialization prior to starting mInitialized = false; } 通过内存储存mValues这个数组的类型，和代码中赋值的方式，我们可以发现他用了一个类似RecyclerView的holder的方式做缓存和复用。 这里感觉要去复习一下View的相关知识才能继续写下去了，包括对View的一些新的理解，还有安卓整体的布局体系。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:2:1","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#从offloat方法入手"},{"categories":[],"content":" 摘要的结论 我通过属性动画，去改变view.translateX，不论是调用invalidate()还是requestLayout(),都只有targetView自己产生了平移； 而当我改为修改LayoutParams的marginStart后再requestLayout(),下面的所有View都跟着平移了。 看着这个结果，我是恍然大悟，艹，以前太把大厂的人当神看了，再加上面试时紧张，就没考虑那么多。现在看看，这根本就是个伪命题啊，首先constraintlayout所建立的布局体系是LayoutParams相关的，而View的位置属性(x/y)也在measure和layout过程中根据lp来确定的。所以当我通过属性动画改变translateX时，并不会影响lp，所以也不会改变约束，当然也不会影响到其他View了。 结论：不要感觉大厂的人很权威，其中有很多人可能就擅长装个逼而已，你说你自己都没弄懂，就敢拿来面试别人，还误导人家，好意思吗？现在非常庆幸，虽然当初面试过了，但是幸好因为薪资问题没有去，要不然跟这种人共事天天看他装逼，我心里也不舒服。 ","date":"2022-05-22","objectID":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:3:0","series":[],"tags":[],"title":"属性动画","uri":"/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/#摘要的结论"},{"categories":[],"content":"最近打算自己开发独立App，那么首先考虑的就是账号密码的网络传输安全，也就是所谓的登录安全。 HTTPS通信框架下； 加固后的.so文件，通过验证App签名，返回RSA公钥； 通过RSA公钥加密用户名密码，上报服务器； 服务器通过私钥解密取得用户名密码，验证用户名密码合法性，返回jwt的token； —————-7月7日更新————————- 最近正好负责了PKI，了解了双向认证机制，那么自己的安全可以完全使用双向认证来玩了： 找个免费的tsl证书，配置好https双向认证。 在建立连接握手时采用非对称加密，传输使用对称加密，已经非常安全了，但是握手过程速度很慢，所以需要配合链接保活。 重要信息使用双向认证，非重要信息可以采用单向认证。如果全采用双向，则任意浏览器不具备自颁发证书，就很麻烦了。 客户端可以使用android的密钥库。 ","date":"2022-05-17","objectID":"/%E7%99%BB%E5%BD%95%E5%AE%89%E5%85%A8/:0:0","series":[],"tags":[],"title":"登录安全","uri":"/%E7%99%BB%E5%BD%95%E5%AE%89%E5%85%A8/#"},{"categories":[],"content":" 使用https防拦截； 采用动态密钥，首次登录先检查是否存在本地密钥，然后可从服务器动态剩下公私钥，公钥下载至客户端，储存在.so文件中。 从.so读取公钥，.so需要认证证书签名，拿到公钥后以公钥加密数据再发送。 token可通过时间戳实现有效性验证。 ","date":"2022-05-17","objectID":"/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/:0:0","series":[],"tags":[],"title":"客户端网络安全设计","uri":"/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/#"},{"categories":[],"content":" 常见淘汰策略 FIFO（First In，First Out）先进先出； FILO 先进后出； LFU（Least Frequently Used）最少使用； LRU（Least Recently Used）最近最少使用。 ","date":"2022-05-14","objectID":"/%E9%93%BE%E8%A1%A8/:0:1","series":[],"tags":[],"title":"链表","uri":"/%E9%93%BE%E8%A1%A8/#常见淘汰策略"},{"categories":[],"content":" 链表的特性不需要连续的储存空间，而是通过指针讲一堆零散的内存快串联起来。； ","date":"2022-05-14","objectID":"/%E9%93%BE%E8%A1%A8/:0:2","series":[],"tags":[],"title":"链表","uri":"/%E9%93%BE%E8%A1%A8/#链表的特性"},{"categories":[],"content":" 单链表 后继指针：由于数据存储不连续，所以链表中的每一个节点都需要记录下一个节点的地址，叫做后继指针； 头节点，记录了链表的基地址； 尾节点，后继指针指向空地址null。 由于数组需要连续的储存空间，所以在增删操作时需要移位补漏，所以时间复杂度是O(n)，而链表因为空间本身不是连续的，所以不需要移位，所以时间复杂度是O(1)。 ","date":"2022-05-14","objectID":"/%E9%93%BE%E8%A1%A8/:0:3","series":[],"tags":[],"title":"链表","uri":"/%E9%93%BE%E8%A1%A8/#单链表"},{"categories":[],"content":" 循环链表 一种特殊的单项链，尾节点的后继指针指向头节点。 从链尾可以轻松返回链头。 当数据具备环形特点时适合使用循环链表。 ","date":"2022-05-14","objectID":"/%E9%93%BE%E8%A1%A8/:0:4","series":[],"tags":[],"title":"链表","uri":"/%E9%93%BE%E8%A1%A8/#循环链表"},{"categories":[],"content":" 双向链表节点中同时具备前驱和**后继双指针 ","date":"2022-05-14","objectID":"/%E9%93%BE%E8%A1%A8/:0:5","series":[],"tags":[],"title":"链表","uri":"/%E9%93%BE%E8%A1%A8/#双向链表"},{"categories":[],"content":" LRU算法在一个固定长度并且有序的链表结构中存入数据，由于有序，所以最先插入的就会排在链尾。 当访问数据时，从链头开始遍历查询到对应节点，并将它移到链头； 如果没有查询到，则将新数据插入链头。 如果插入后发现链表已超出固定长度，则删除链尾。 ","date":"2022-05-14","objectID":"/%E9%93%BE%E8%A1%A8/:0:6","series":[],"tags":[],"title":"链表","uri":"/%E9%93%BE%E8%A1%A8/#lru算法"},{"categories":[],"content":" 数组的特性 线性表结构； 需要内存中有足够的连续储存空间，否则剩余空间再大也会创建失败； 可通过下标随机访问，时间复杂度为O(1)常量阶； 如果不通过下标访问，而是通过算法查找(比如二分法)，则时间复杂度为O(logn)对数阶。 插入删除操作低效，在插入/删除操作时，最坏时间复杂度为O(n)。 ","date":"2022-05-14","objectID":"/%E6%95%B0%E7%BB%84/:0:1","series":[],"tags":[],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#数组的特性"},{"categories":[],"content":" ArrayList能否完全替代数组ArrayList只支持包装类型，如Intenger，Long等，却不支持结构体，在存入结构体时会自动装箱，而装箱操作会有一定的性能消耗。 在做一些底层开发时，建议使用数组。 ","date":"2022-05-14","objectID":"/%E6%95%B0%E7%BB%84/:0:2","series":[],"tags":[],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#arraylist能否完全替代数组"},{"categories":[],"content":" 为何下标从0开始下标可以理解为「偏移量」，从0开始就意味着不需要偏移，才是正确的理解。当我们通过下标查找元素时，cpu会通过计算偏移量来查找，而如果以1开始，cpu计算完偏移量之后还要追加一次减1操作。 ","date":"2022-05-14","objectID":"/%E6%95%B0%E7%BB%84/:0:3","series":[],"tags":[],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#为何下标从0开始"},{"categories":[],"content":"同样基于交换的思想，选择排序法的效率要比冒泡排序高很多。 ","date":"2022-05-13","objectID":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/:0:0","series":[],"tags":[],"title":"选择排序法","uri":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/#"},{"categories":[],"content":" 核心思想将数据分成两组，通过遍历找到极值，并存放到另一组末尾。 ","date":"2022-05-13","objectID":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/:0:1","series":[],"tags":[],"title":"选择排序法","uri":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/#核心思想"},{"categories":[],"content":" 选择查找极值","date":"2022-05-13","objectID":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/:0:2","series":[],"tags":[],"title":"选择排序法","uri":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/#选择查找极值"},{"categories":[],"content":" 选择法查找极值 private static int max(int[] original) { int[] arr = Arrays.copyOf(original, original.length); int i = 0; int pos = i + 1; for (; i \u003c arr.length; i++) { if (arr[i] \u003e arr[pos]) { pos = i; } } return arr[pos]; } ","date":"2022-05-13","objectID":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/:0:3","series":[],"tags":[],"title":"选择排序法","uri":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/#选择法查找极值"},{"categories":[],"content":" 选择法排序 private static int[] sort(int[] original) { // copy一份数据出来，不让原数据受影响 int[] aar = Arrays.copyOf(original, original.length); int num; // 只遍历n-1次就够了，最后一个数不用管 for (int i = 0; i \u003c aar.length - 1; i++) { // 记录极值的位置 int minPos = i; // 让出已处理过的数据，只需遍历剩下的数据 for (int j = i + 1; j \u003c aar.length; j++) { // 比较并更新位置 if (aar[j] \u003c aar[minPos]) { minPos = j; } } // 一轮遍历之后开始交换 if (i != minPos) { num = aar[i]; aar[i] = aar[minPos]; aar[minPos] = num; } } return aar; } 首先从左往右选择一个元素i，然后定义一个指针minPos，之后遍历i后面的元素查找最小值的位置记录到指针，最后用初始选定的元素i去与minPos交换。 外层循环遍历n-1次，剩下最后一个值不需要管； 一份数据分成两组整理，所以遍历次数会依次减少，提高效率； 元素每次不只移动一位； 通过记录下标，内层循环一轮之后元素才会移动； 时间复杂度：O(n²) ","date":"2022-05-13","objectID":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/:0:4","series":[],"tags":[],"title":"选择排序法","uri":"/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/#选择法排序"},{"categories":[],"content":"冒泡法可以用来找队列中的最大值，也可以通过多次冒泡对集合进行排序。 ","date":"2022-05-13","objectID":"/%E5%86%92%E6%B3%A1%E6%B3%95/:0:0","series":[],"tags":[],"title":"冒泡法","uri":"/%E5%86%92%E6%B3%A1%E6%B3%95/#"},{"categories":[],"content":" 核心思想遍历数组或集合中，用当前位置的值与后面一个值相比较并且交换，使极值永远处于数组或集合的最末。 ","date":"2022-05-13","objectID":"/%E5%86%92%E6%B3%A1%E6%B3%95/:1:0","series":[],"tags":[],"title":"冒泡法","uri":"/%E5%86%92%E6%B3%A1%E6%B3%95/#核心思想"},{"categories":[],"content":" 冒泡找最大值逐个比对，通过交换使极值拍到末尾，但并不保证前面的顺序。 private static int max(int[] original) { // copy数组，不会影响原数组 int[] newArray = Arrays.copyOf(original, original.length); int num1, num2; // 注意这里减1以提高效率 for (int i = 0; i \u003c newArray.length - 1; i++) { num1 = newArray[i]; num2 = newArray[i + 1]; if (num1 \u003e num2) { newArray[i] = num2; newArray[i + 1] = num1; } } // 返回末端 return newArray[newArray.length - 1]; } 为何循环中减1呢？因为不断的遍历和比较，当遍历到倒数第二个值的时候，会与倒数第一去比较，不论结果如何，最大值已经到达末尾了，所以就没有必要再去遍历到最后一个值了。 时间复杂度：O(n) 空间复杂度：O(n) ","date":"2022-05-13","objectID":"/%E5%86%92%E6%B3%A1%E6%B3%95/:1:1","series":[],"tags":[],"title":"冒泡法","uri":"/%E5%86%92%E6%B3%A1%E6%B3%95/#冒泡找最大值"},{"categories":[],"content":" 冒泡排序在冒泡找极值的基础上加入循环，使数组或集合从后往前数依次是：极值、次极值、次次极值… private static int[] sort(int[] original, int k) { int[] newArray = Arrays.copyOf(original, original.length); int num1, num2; int i = 0; // 外层循环控制冒泡的轮数 for (; i \u003c k - 1; i++) { //记录内层是否发生过交换 boolean flag = false; //内层循环控制冒泡的次数 for (int j = 0; j \u003c newArray.length - 1 - i; j++) { num1 = newArray[j]; num2 = newArray[j + 1]; if (num1 \u003c num2) { newArray[j] = num2; newArray[j + 1] = num1; flag = false; } } // 如果内层一轮遍历下来美誉发生过交换，说明已经排序好了，直接跳出外层循环 if (flag) { break; } } return newArray; } 外层循环每遍历一次，内层就会找出极值放到末尾。那么当只剩下最后一个值时，他自己就是反极值了，没必要再让内层去遍历一轮了，所以我们给外层循环次数减1. 与查询极值类似，内层循环为了提高效率也应该减1。 每当外层循环一轮，都会找出极值放到末尾，那么内层在冒泡时，对于已经找到的极值并不需要关注了，为了提高效率应该再减去外层循环的次数。 最坏时间复杂度：O(n²)； 最好时间复杂度：O(n)； 冒泡排序由于比较和交换相邻元素，元素每次只移动一位，所以需要多次的循环遍历和判断，效率非常低。 ","date":"2022-05-13","objectID":"/%E5%86%92%E6%B3%A1%E6%B3%95/:1:2","series":[],"tags":[],"title":"冒泡法","uri":"/%E5%86%92%E6%B3%A1%E6%B3%95/#冒泡排序"},{"categories":[],"content":" 时间复杂度分析法","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#时间复杂度分析法"},{"categories":[],"content":" 核心思想忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。 int cal(int n) { int sum = 0; int i = 1; for (; i \u003c= n; ++i) { sum = sum + i; } return sum; } 2、3行是常量，可以直接排除，我们只看其中的for循环就可以了。上面代码的时间复杂度是：O(n)。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:1","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#核心思想"},{"categories":[],"content":" 嵌套循环的分析法 int cal(int n) { int ret = 0; int i = 1; for (; i \u003c n; ++i) { ret = ret + f(i); } } int f(int n) { int sum = 0; int i = 1; for (; i \u003c n; ++i) { sum = sum + i; } return sum; } 上面的代码，在cal()方法里面循环调用了f(),如果把前者循环里面的部分当作常量，那么前者的时间复杂度是O(n)，而后者的时间复杂度是O(n)，那么总共就是O(n x n)，也就是O(n²)。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:2","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#嵌套循环的分析法"},{"categories":[],"content":" 常见的时间复杂度（数量级递增） 多项式量级 O(1)-常量阶 O(n)-线性阶 O(logⁿ)-对数阶 O(nlogⁿ)-线性对数阶 O(n²)-平方阶、立方阶…k次方阶 非多项式量级 O(2ⁿ)-指数阶 O(n!)-阶乘阶 当数据规模n越来越大时，非多项式量级的执行时间会急剧增加。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:3","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#常见的时间复杂度数量级递增"},{"categories":[],"content":" 常见的时间复杂度（数量级递增） 多项式量级 O(1)-常量阶 O(n)-线性阶 O(logⁿ)-对数阶 O(nlogⁿ)-线性对数阶 O(n²)-平方阶、立方阶…k次方阶 非多项式量级 O(2ⁿ)-指数阶 O(n!)-阶乘阶 当数据规模n越来越大时，非多项式量级的执行时间会急剧增加。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:3","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#多项式量级"},{"categories":[],"content":" 常见的时间复杂度（数量级递增） 多项式量级 O(1)-常量阶 O(n)-线性阶 O(logⁿ)-对数阶 O(nlogⁿ)-线性对数阶 O(n²)-平方阶、立方阶…k次方阶 非多项式量级 O(2ⁿ)-指数阶 O(n!)-阶乘阶 当数据规模n越来越大时，非多项式量级的执行时间会急剧增加。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:3","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#非多项式量级"},{"categories":[],"content":" 对数阶 i = 1; while (i \u003c= n) { i = i * 2; } 变量i的值从1开始，每次循环都会x2，实际上就形成了一个等比数列： 2⁰ 2¹ 2² ... 2ˣ = n 这种形式就是对数阶，因为以2为底，计作O(log₂n)。又由于底可以忽略，所以记为O(logn)。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:4","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#对数阶"},{"categories":[],"content":" 多数量级 int cal(int m, int n) { int sum_1 = 0; int i = 1; for (; i \u003c m; ++i) { sum_1 = sum_1 + i; } int sum_2 = 0; int j = 1; for (; j \u003c n; ++j) { sum_2 = sum_2 + j; } return sum_1 + sum_2; } 这段代码即有m又有n，表示两个不同的数据量级，我们无法评估谁的数量级更大，所以两个都要考虑在内，记作O(m + n)。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:5","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#多数量级"},{"categories":[],"content":" 空间复杂度","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#空间复杂度"},{"categories":[],"content":" 核心思想排除常量、系数和运算，只记录最大空间占用。 void print(int n) { int i = 0; int[] a = new int[n]; for (i; i \u003cn; ++i) { a[i] = i * i; } for (i = n-1; i \u003e= 0; --i) { print out a[i] } } 第二行代码申请了一个空间用来储存变量i，但由于是常量阶，可以忽略。 第三行代码申请了n个空间。 后续代码没有再继续申请空间。 所以空间复杂度就是O(n)。 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:1","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#核心思想-1"},{"categories":[],"content":" 常见空间复杂度 O(1)-常量阶 O(n)-线性阶 O(n²)-平方阶 ","date":"2022-05-12","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:2","series":[],"tags":[],"title":"时间复杂度与空间复杂度","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#常见空间复杂度"},{"categories":[],"content":"一个无限大的文件，里面包函大量的数据，需求是从中取出top50。 ","date":"2022-05-12","objectID":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/:0:0","series":[],"tags":[],"title":"大数据量取top","uri":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/#"},{"categories":[],"content":" 先说点废话吧这是现在面试问的TM的最多的问题，解答时往往还不让用ide。我就在想现在都卷成什么样了，这种量级的数据怎么能拿到移动端来做呢，者面试题明显是从服务端抄过来的，用来考核移动端的能力有什么用？问这种问题的面试官用意也很明显，其目的根本不在于考察面试者的实际业务水平，而是仅仅为了看你有没有刷过题，比如玩过leetCode，所以他们最后招到的最多也就是理论家，这种人我都不信他有什么解决问题的能力。 ","date":"2022-05-12","objectID":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/:1:0","series":[],"tags":[],"title":"大数据量取top","uri":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/#先说点废话吧"},{"categories":[],"content":" 解答方案","date":"2022-05-12","objectID":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/:2:0","series":[],"tags":[],"title":"大数据量取top","uri":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/#解答方案"},{"categories":[],"content":" 方案一：全排序如果不考虑内存的话，可以采用快速排序法对整个文件做全排序，然后取top50。 时间复杂度：O(n) ","date":"2022-05-12","objectID":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/:2:1","series":[],"tags":[],"title":"大数据量取top","uri":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/#方案一全排序"},{"categories":[],"content":" 方案二：","date":"2022-05-12","objectID":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/:2:2","series":[],"tags":[],"title":"大数据量取top","uri":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%96top/#方案二"},{"categories":[],"content":" 异常的捕获可以使用try-catch捕获同步异常，使用catchERROR捕获异步代码的异常。 ","date":"2022-04-20","objectID":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/:1:0","series":[],"tags":[],"title":"Flutter异常监控","uri":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/#异常的捕获"},{"categories":[],"content":" 未捕获异常可以在main函数中重写FlutterError.onError函数设置默认的未捕获异常处理机制。 void main(){ Flutter.Error.onError = (detail){ // 异常处理 }; runApp(MyApp()); } ","date":"2022-04-20","objectID":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/:2:0","series":[],"tags":[],"title":"Flutter异常监控","uri":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/#未捕获异常"},{"categories":[],"content":" 捕获Future的异常可以使用zone,zone表示一个代码执行的上下文，给异步代码提供了一个稳定的运行环境，可以理解为一个沙盒： void main(){ runZone((){ runApp(MyApp()); },onError(error,stackTrace){ // 异常处理 }); } ","date":"2022-04-20","objectID":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/:3:0","series":[],"tags":[],"title":"Flutter异常监控","uri":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/#捕获future的异常"},{"categories":[],"content":" 红白屏捕获可以在main函数中重写ErrorWidgetBuilder： void performRebuild() { ... try { ... } catch (e, stack) { // ErrorWidget.builder回调方法替换错误页面 built = ErrorWidget.builder( _debugReportException( ErrorDescription('building $this'), e, stack, informationCollector: () sync* { yield DiagnosticsDebugCreator(DebugCreator(this)); }, ), ); } ... } //默认的处理方式,我们也可以在main中覆盖处理 static ErrorWidgetBuilder builder = _defaultErrorWidgetBuilder; ","date":"2022-04-20","objectID":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/:4:0","series":[],"tags":[],"title":"Flutter异常监控","uri":"/flutter%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/#红白屏捕获"},{"categories":[],"content":" 电量优化 优化代码，减少不必要的操作，或者合并操作，减少设备活跃时间，比如一次性的请求网络数据，一次性的IO。 延迟操作，通过监听系统广播、WorkManager等方式监听设备充满电之后再搞事情。 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:1:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#电量优化"},{"categories":[],"content":" 网络优化 直接使用IP地址，避免漫长的DNS解析过程 连接复用，避免多次建立连接（okHttp自带的keep-alive和多路复用） 对数据压缩处理（gzip） 采用json，protobuf，甚至graphQL减少数据体积和传输频次 本地缓存数据，避免频繁请求接口 识别设备网络状态，在2/3/4G流量状态下传输低清图片 使用webP格式图片 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:2:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#网络优化"},{"categories":[],"content":" UI卡顿优化","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:3:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#ui卡顿优化"},{"categories":[],"content":" layout加载问题正常的流程是在主线程先IO读取并递归解析一个xml文件，再通过反射创建View对象，效率很低，遇到复杂的layout，甚至可能引发ANR。 使用约束布局，减少布局嵌套，减少递归； 使用AsyncLayoutInflater异步加载，不会阻塞主线程； 使用注解处理器+javaPoet在编译时生成View文件。（掌阅x2c原理） ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:3:1","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#layout加载问题"},{"categories":[],"content":" 重复绘制问题 使用约束布局，减少布局嵌套 去除看不见的背景图片 减少alpha的使用，使用alpha会导致View绘制两次，可使用ARGB色值替代 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:3:2","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#重复绘制问题"},{"categories":[],"content":" 卡顿问题 自定义View的onDraw优化 内存抖动频繁GC ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:3:3","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#卡顿问题"},{"categories":[],"content":" 排查工具 Systrace profile adb ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:3:4","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#排查工具"},{"categories":[],"content":" apk体积优化 lint检查无效资源 混淆minifyEnabled 资源排除 图片压缩，webP，VectorDrawable 使用tint前台改色复用图片 指定本地化语言 指定NDK 本地库压缩，在manifast文件中为application指定android:extractNativeLibs = true ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:4:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#apk体积优化"},{"categories":[],"content":" 内存优化","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:5:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#内存优化"},{"categories":[],"content":" 数据结构优化 ArrayList 初始化长度定位0，避免第一次add时扩容，空间换时间 增删时使用LinkedList，查询时转换成ArrayList 避免在中间插入和移除，这样会遍历改变下标，非常耗时，可以从末尾操作 使用HashMap替代，HashMap增删快，查询快 HashMap 预估长度避免扩容 长度为2的整数倍，避免哈希冲突 使用SpaceArray替代，其核心是二维数组，并采用二分法提高查询效率。 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:5:1","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#数据结构优化"},{"categories":[],"content":" 数据结构优化 ArrayList 初始化长度定位0，避免第一次add时扩容，空间换时间 增删时使用LinkedList，查询时转换成ArrayList 避免在中间插入和移除，这样会遍历改变下标，非常耗时，可以从末尾操作 使用HashMap替代，HashMap增删快，查询快 HashMap 预估长度避免扩容 长度为2的整数倍，避免哈希冲突 使用SpaceArray替代，其核心是二维数组，并采用二分法提高查询效率。 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:5:1","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#arraylist"},{"categories":[],"content":" 数据结构优化 ArrayList 初始化长度定位0，避免第一次add时扩容，空间换时间 增删时使用LinkedList，查询时转换成ArrayList 避免在中间插入和移除，这样会遍历改变下标，非常耗时，可以从末尾操作 使用HashMap替代，HashMap增删快，查询快 HashMap 预估长度避免扩容 长度为2的整数倍，避免哈希冲突 使用SpaceArray替代，其核心是二维数组，并采用二分法提高查询效率。 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:5:1","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#hashmap"},{"categories":[],"content":" 崩溃监控 Thread.setDefaultUnCauthExceptionHandler linux错误信号 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:6:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#崩溃监控"},{"categories":[],"content":" ANR监控通过监听linux错误信号，经判断找出ANR错误，然后上报。 ","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:7:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#anr监控"},{"categories":[],"content":" 安全性相关优化","date":"2022-04-19","objectID":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/:8:0","series":[],"tags":[],"title":"性能优化总览","uri":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%A7%88/#安全性相关优化"},{"categories":[],"content":" 发送广播","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:1:0","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#发送广播"},{"categories":[],"content":" 普通广播（无序）完全异步执行，无序。发出之后，所有广播接收器都可接收到，无法被拦截。 //intent中的参数为action Intent intent = new Intent(\"com.example.dimple.BROADCAST_TEST\"); sendBroadcast(intent); ","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:1:1","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#普通广播无序"},{"categories":[],"content":" 有序广播同步执行，有序。发出之后，广播接收器按照优先级顺序接收，并可拦截掉广播，类似View事件分发机制。 //intent中的参数为action Intent intent = new Intent(\"com.example.dimple.BROADCAST_TEST\"); sendOrderBroadcast(intent，null);//第二个参数是与权限相关的字符串。 设置广播接收器的优先级： \u003creceiver android:name=\".MyReceiver\" android:enabled=\"true\" android:exported=\"true\"\u003e \u003c!--注意此时有一个Priority属性--\u003e \u003cintent-filter android:priority=\"100\"\u003e \u003caction android:name=\"android.intent.action.BROADCAST_TEST\"\u003e\u003c/action\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e ","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:1:2","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#有序广播"},{"categories":[],"content":" 广播接收器","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:2:0","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#广播接收器"},{"categories":[],"content":" 动态注册自定义一个类，继承BroadcastReceiver。 MyBroadcastReceiver myBroadcastReceiver = new MyBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(\"com.example.dimple.MY_BROADCAST\"); registerReceiver(myBroadcastReceiver,intentFilter); Activity关闭时要取消注册： @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(myBroadcastReceiver); } 如果需要接收系统的广播（比如电量变化，网络变化等等），别忘记在AndroidManifest配置文件中加上权限。 ","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:2:1","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#动态注册"},{"categories":[],"content":" 静态注册也是自定义一个 然后不需要在代码中注册，直接在中注册即可： \u003creceiver android:name=\".MyReceiver\" android:enabled=\"true\" android:exported=\"true\"\u003e \u003c!--添加action--\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.BOOT_COMPLETED\" /\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e ","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:2:2","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#静态注册"},{"categories":[],"content":" 两种方式的区别 动态注册，与Activity生命周期一致，所以只能在Activity启动后才能接收广播，并且需要手动取消注册。 静态注册的广播不受程序是否启动的约束，当应用程序关闭之后，还是可以接收到广播，适合监听系统广播，甚至可以在收到广播后拉起应用（在后续版本中取消了）。 ","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:2:3","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#两种方式的区别"},{"categories":[],"content":" 本地广播一般我们发送的广播都是基于intent的action过滤实现的，在系统中是全局的，会引发安全性问题，安卓还提供了一套本地广播的机制，就是依靠LocalBroadcastManager。 class MainActivity : AppCompatActivity() { private val localBroadcastReceiver = MyReceiver() private lateinit var lcalBroadcastManager: LocalBroadcastManager private val action = \"com.vee.intentservicetest.local_broadcast_receiver\" override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 初始化LocalBroadcastManager lcalBroadcastManager = LocalBroadcastManager.getInstance(this) // 注册广播接收器 lcalBroadcastManager.registerReceiver(localBroadcastReceiver, IntentFilter(action)) // 发送广播 lcalBroadcastManager.sendBroadcast(Intent(action)) } override fun onDestroy() { super.onDestroy() //别忘了取消注册 lcalBroadcastManager.unregisterReceiver(localBroadcastReceiver) } } /** * 自定义的广播接收器 */ class MyReceiver : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { TODO(\"Not yet implemented\") } } ","date":"2022-03-28","objectID":"/%E5%B9%BF%E6%92%AD/:3:0","series":[],"tags":[],"title":"广播","uri":"/%E5%B9%BF%E6%92%AD/#本地广播"},{"categories":[],"content":"面试题：场景需要在子线程中依次执行多个子任务，要保证任务时序，所有子任务执行完毕该线程自动退出，怎么实现？ IntentService扩展自Service，是Service和HandlerThread的结合体，天生就在自线程中，且完成任务后自动停止，适合处理自线程耗时任务。如果多次启动IntentService，则每一个任务会以队列的方式在onHandlerIntent方法中依次执行。 ","date":"2022-03-28","objectID":"/intentservice/:0:0","series":[],"tags":[],"title":"IntentService","uri":"/intentservice/#"},{"categories":[],"content":" 原理 public abstract class IntentService extends Service { private volatile Looper mServiceLooper; @UnsupportedAppUsage private volatile ServiceHandler mServiceHandler; private String mName; // 子线程Handler private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { //收到消息后调用onHandleIntent方法 onHandleIntent((Intent)msg.obj); //任务执行完毕后关闭自己，注意这里的参数 stopSelf(msg.arg1); } } /** * 构造方法需要传递线程名称 */ public IntentService(String name) { super(); mName = name; } @Override public void onCreate() { // 初始化一个HandlerThread HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); mServiceLooper = thread.getLooper(); // 用子线程的Looper初始化了子线程的Handler mServiceHandler = new ServiceHandler(mServiceLooper); } /** * 直接调用onStart方法 */ @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; } /** * 主要是把任务封装成消息，发送给子线程处理 */ @Override public void onStart(@Nullable Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } /** * 退出时关闭子线程Looper，使线程终止 */ @Override public void onDestroy() { mServiceLooper.quit(); } /** * 一般不需要用这个方法，也可以通过重写实现 */ @Override @Nullable public IBinder onBind(Intent intent) { return null; } /** * 我们需要重写这个方法去实现业务逻辑 */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent); } 原理很简单： 在创建service时，onCreate方法是必须只调用一次的，所以在这里初始化了一个HandlerThread和归属于他的Handler。 当我们在activity中每次调用startService()，会回调service的onStartCommand()方法，在其中调用了onStart()，把intent封装成消息发送给子线程。由于消息没有when参数限制延迟时间，所以消息在MessageQueue中是按照FIFO(先进后出)的顺序排列的。 当消息经过Looper传递到Handler的HandlerMessage()方法时，会调用onHandleIntent()方法由我们自己去处理。处理完之后会尝试销毁service。 在销毁service时传递了startID，此时系统会检查service中是否还有其他的startID，如果有的话就不会退出，好让剩余的任务继续执行；如果没有，则会销毁Service. ","date":"2022-03-28","objectID":"/intentservice/:1:0","series":[],"tags":[],"title":"IntentService","uri":"/intentservice/#原理"},{"categories":[],"content":" startService的生命周期 onCreate onStartCommant onDestroy fun start(v: View) { Intent(this, MyService::class.java).run { startService(this) } } fun stop(v: View) { Intent(this, MyService::class.java).run { stopService(this) } // or 在service中调用stopSelf() } 这种方式创建Service，可以多次调用startService，并且onStartCommant方法也会随之回调，但是onCreate只会回调一次。 可以通过Intent向service传递信息。 当不需要service不需要继续运行时，需要手动关闭。 ","date":"2022-03-28","objectID":"/service%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","series":[],"tags":[],"title":"Service的使用","uri":"/service%E7%9A%84%E4%BD%BF%E7%94%A8/#startservice的生命周期"},{"categories":[],"content":" bindService的生命周期 onCreate onBind onDestroy Activity代码： private lateinit var service: MyService /** * 自定义一个连接，用来获取service对象 */ private val conn = object : ServiceConnection { override fun onServiceConnected(name: ComponentName?, binder: IBinder) { // 获取service val myBinder = (binder as MyService.MyBinder) //调用业务方法 myBinder.startDownload.invoke() } override fun onServiceDisconnected(name: ComponentName?) { // 当Service未正常退出，而是因为其他原因退出时回调 } } fun bind(v: View) { Intent(this, MyService::class.java).run { bindService(this, conn, BIND_AUTO_CREATE) } } fun unbind(v: View) { Intent(this, MyService::class.java).run { unbindService(conn) } } Service代码： class MyService : Service() { /** * 预置一个自定义的binder **/ private val mBinder = MyBinder { startDownload() } override fun onCreate() { Log.d(TAG, \"onCreate: \") super.onCreate() } override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Log.d(TAG, \"onStartCommand: \") return super.onStartCommand(intent, flags, startId) } override fun onBind(intent: Intent): IBinder { // 返回自定义的binder return mBinder } override fun onDestroy() { Log.d(TAG, \"onDestroy: \") super.onDestroy() } /** * Activity可以直接通过service对象调用业务方法 */ private fun startDownload() { //处理下载任务，完成后通知Activity刷新UI mBinder.callback?.refreshUI() } /** * 自定义一个Binder内部类 * 通过传递函数参数，实现Activity直接通过binder调用service的内部方法 */ inner class MyBinder(val startDownload: () -\u003e Unit) : Binder() { var callback: MyBinderCallback? = null } } interface MyBinderCallback { fun refreshUI() } 通过bindService方法绑定service，可以使用BIND_AUTO_CREATE这个flag自动创建service，也可以直接绑定到startService方法创建的service之上。 当不再需要service继续执行时（例如Activity退出前），必须调用unbindService进行解绑，否则会报错。 当多个页面都绑定到同一个service，单个页面的解绑不会影响service。 当没有页面继续绑定时，service会自动销毁。 当通过startService创建了service，并且有其他activity又通过bindService绑定到了service，那么只有unbindService和stopService都调用之后，才会销毁service。 ","date":"2022-03-28","objectID":"/service%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","series":[],"tags":[],"title":"Service的使用","uri":"/service%E7%9A%84%E4%BD%BF%E7%94%A8/#bindservice的生命周期"},{"categories":["趣味题"],"content":"假设有个单向链，我们并不知道长度，要求找到倒数的第N个节点。 ","date":"2022-03-24","objectID":"/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","series":[],"tags":[],"title":"单向链找倒数第N个节点","uri":"/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/#"},{"categories":["趣味题"],"content":" 解题思路用常规的数学思路去解是不行的，我们可以用逻辑思路去解。 首先，既然是单向链，肯定有头有尾，就像一个轨道一样有起有终。那么假设我们有一列火车的长度就是N，当火车驶到终点时，车位的位置不就是我们要找的位置吗？ ","date":"2022-03-24","objectID":"/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/:1:0","series":[],"tags":[],"title":"单向链找倒数第N个节点","uri":"/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/#解题思路"},{"categories":["趣味题"],"content":" 代码实操 /** * 有个不知道长度的单向链node，我们要找到其倒数第num个节点返回 * @param num * @return */ private static Node findNode(int num) { //定义头尾指针 Node nodeHead = node; Node nodeTail = node; //让头先走num步 for (int i = 0; i \u003c num - 1; i++) { nodeHead = nodeHead.next; } //头尾一起，一步一个脚印，直到头触底 while (nodeHead.next != null) { nodeTail = nodeTail.next; nodeHead = nodeHead.next; } //返回尾，此时尾指针指向的就是我们要找的num节点 return nodeTail; } ","date":"2022-03-24","objectID":"/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/:2:0","series":[],"tags":[],"title":"单向链找倒数第N个节点","uri":"/%E5%8D%95%E5%90%91%E9%93%BE%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/#代码实操"},{"categories":[],"content":" 伪范型和范型擦除在编译期间，所有的范型信息都会被擦除掉。 Java中的范型是在编译器这个层次来实现的，在生成Java字节码中是不包含范型中的类型信息的，使用范型的时候加上的类型参数，会在编译期间去掉，这个过程就叫范型擦除。 验证：声明两个不同范型的List，然后比较两个list的类型。 ArrayList\u003cString\u003e list1 = new ArrayList(); ArrayList\u003cInteger\u003e list2 = new ArrayList(); System.out.print(list1.getClass() == list2.getClass()); // 输出 true ","date":"2022-03-19","objectID":"/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/:1:0","series":[],"tags":[],"title":"Java中的范型","uri":"/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/#伪范型和范型擦除"},{"categories":[],"content":" 范型通配符 \u003c? extends T\u003e 子类限定通配符， \u003c? super T\u003e 超类限定通配符， \u003c?\u003e 无限定通配符， ","date":"2022-03-19","objectID":"/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/:2:0","series":[],"tags":[],"title":"Java中的范型","uri":"/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/#范型通配符"},{"categories":[],"content":" 范型的限制 范型不能用来实例化变量； 静态域或方法不能使用自己类型的范型（因为只有在创建对象后才知道范型的具体类型）； 范型不支持使用结构体，可以使用引用的包装类型替代，如Double,Integer,Long等； 范型不允许使用instanceof关键字判断类型； 类型擦除； 范型类不能继承/扩展（使用extends关键字）Expection、Throwable； 不能try-catch捕获范型对象； ","date":"2022-03-19","objectID":"/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/:3:0","series":[],"tags":[],"title":"Java中的范型","uri":"/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/#范型的限制"},{"categories":[],"content":" 传递流程 Activity的disPatchTouchEvent方法接受到事件，然后传递到PhoneWindow的disPatchTouchEvent，再从PhoneWindow传递到DecorView的disPatchTouchEvent。 然后事件会到达根ViewGroup的disPatchTouchEvent，在这里会首先调用onInterceptTouchEvent判断是否需要拦截。如果拦截，则调用自己的onTouchEvent处理；不拦截则会遍历子View进行处理。 事件到达子View，会经disPatchTouchEvent到达onTouchEvent，如果进行了处理，就返回true，表示事件已经消费掉，不会继续传递。 如果子View不处理并返回了false，事件会返回到父级ViewGroup的disPatchTouchEvent，然后直接到达ViewGroup的onTouchEvent。 如果再不处理，就会继续向上冒泡，直到Activity的onTouchEvent。 ","date":"2022-03-11","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:1:0","series":[],"tags":[],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/#传递流程"},{"categories":[],"content":" 需要注意 只有ViewGroup有#； 只有View的onTouchEvent是默认拦截的； 重写onTouchEvent会出现警报，表示可能会引起click事件失效，所以需要手动调用performClick方法，指定click事件的触发时机。 ","date":"2022-03-11","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:2:0","series":[],"tags":[],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/#需要注意"},{"categories":[],"content":"TODO ","date":"2022-03-10","objectID":"/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:0","series":[],"tags":[],"title":"启动流程","uri":"/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#"},{"categories":[],"content":" 按下电源键，首先从加载并运行BootLoader； BootLoader拉起linux内核； linux内核启动后会加载init.rc文件，并启动init进程。 init进程会启动属性服务（类似注册表），并启动Zygote进程。 Zygote进程会创建JVM并注册JNI，创建服务端Socket(用来接受AMS信号),启动SystemServer进程。 SystemServer会启动Binder线程池和SystemServiceManager及各种系统服务（如AMS,PMS等）。 通过反射调用SystemServer中的main方法，并且new了一个SystemServer并调用其run方法。 启动Launcher。 ","date":"2022-03-09","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:0","series":[],"tags":[],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#"},{"categories":["设计模式"],"content":" 懒汉式（非线程安全） /** * 懒汉式单例 * 特点：用时加载 */ public class Singleton implements Serializable { /** * 核心为静态变量 */ private static Singleton instance; /** * 私有构造方法 */ private Singleton() { } /** * 工厂方法 * @return */ private static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 比较容易忽略的就是构造方法私有。 ","date":"2022-02-24","objectID":"/%E5%8D%95%E4%BE%8B/:0:1","series":["设计模式"],"tags":[],"title":"单例","uri":"/%E5%8D%95%E4%BE%8B/#懒汉式非线程安全"},{"categories":["设计模式"],"content":" 懒汉式（线程安全） /** * 线程安全懒汉式单例 * 特点：用时加载，线程安全 */ public class Singleton implements Serializable { /** * 核心为静态变量 * 加volatile确保异步可见性 */ private static volatile Singleton instance; /** * 私有构造方法 */ private Singleton() { } /** * 工厂方法 * 加锁确保线程安全 * @return */ private static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这种方式把synchornized加在工厂方法上，导致每次调用工厂方法都会阻塞，从而效率低下。 ","date":"2022-02-24","objectID":"/%E5%8D%95%E4%BE%8B/:0:2","series":["设计模式"],"tags":[],"title":"单例","uri":"/%E5%8D%95%E4%BE%8B/#懒汉式线程安全"},{"categories":["设计模式"],"content":" 双重锁（DLC），线程安全 /** * 双重锁单例 * 线程安全 */ public class DlcSingleton { private static volatile DlcSingleton instance; private DlcSingleton() { } public static DlcSingleton getInstance() { if (instance == null) {// 避免阻塞，提高效率 synchronized (DlcSingleton.class) { if (instance == null) {//防止二次创建 instance = new DlcSingleton(); } } } return instance; } } 双重锁的特点就是在工厂方法中加入了同步代码块和双重if判断，使得线程安全。容易忘掉的是静态变量添加的volatile关键字。 考点： synchronized类锁，提供了原子性，是为了线程安全引入，避免多个线程调用工厂方法时，由于信息不同步导致重复创建。 volatile关键字，提供了可见性，由于加锁只能保证原子性，并不保证可见性，所以在并发场景下，一个线程创建了实例，但是对另一个线程不可见，导致另一个线程得到null，所以加volatile读写屏障以保证线程可见性。 同步块里面的if判空，用意与普通的单例中的if判断是一致的，是为了避免二次创建。 同步块外面的if判空，在前面说过，线程安全的单例模式的弊病就是每次调用工厂方法都会同步阻塞，降低了效率。在这里加入if判空，就是为了如果实例已经创建，那么就不会进入同步代码块，从而提高了效率。 ","date":"2022-02-24","objectID":"/%E5%8D%95%E4%BE%8B/:0:3","series":["设计模式"],"tags":[],"title":"单例","uri":"/%E5%8D%95%E4%BE%8B/#双重锁dlc线程安全"},{"categories":["设计模式"],"content":" 静态内部类懒汉式（线程安全） /** * 静态内部类懒汉式 */ public class InnerSingleton { /** * 私有构造方法 */ private InnerSingleton(){} /** * 静态内部类 */ private static class InnerSingletonHolder{ private static final InnerSingleton INSTANCE = new InnerSingleton(); } public static final InnerSingleton getInstance(){ return InnerSingletonHolder.INSTANCE; } } 主要是靠静态内部类持有静态实例。 初看上去写法很饿汉式很像，但是在使用时，加载InnerSingleton类型时，并不会同时加载其静态内部类，只有调用工厂方法时，才会加载其静态内部类，并同时初始化instance，所以这个也算是懒汉式。 classLoader加载内部静态类时，会直接初始化instance，所以也保证了线程安全。 静态内部类，不持有外部类的引用，它其实完全就是另一个独立的类。 ","date":"2022-02-24","objectID":"/%E5%8D%95%E4%BE%8B/:0:4","series":["设计模式"],"tags":[],"title":"单例","uri":"/%E5%8D%95%E4%BE%8B/#静态内部类懒汉式线程安全"},{"categories":["设计模式"],"content":" 饿汉式（线程安全） /** * 饿汉式单例 * 特点：用前加载，天生线程安全，不如懒汉式灵活 */ public class Singleton implements Serializable { /** * 核心为静态变量 * 加volatile确保异步可见性 */ private static final Singleton instance = new Singleton(); /** * 私有构造方法 */ private Singleton() { } /** * 工厂方法 * * @return */ private static Singleton getInstance() { return instance; } } ","date":"2022-02-24","objectID":"/%E5%8D%95%E4%BE%8B/:0:5","series":["设计模式"],"tags":[],"title":"单例","uri":"/%E5%8D%95%E4%BE%8B/#饿汉式线程安全"},{"categories":["设计模式"],"content":" 枚举饿汉式（线程安全） public enum SingletonEnum { INSTANCE; } 在java中，枚举就是一种特别的类，它具备class的一切特性，并且由于跟饿汉差不多，所以天然的线程安全。 ","date":"2022-02-24","objectID":"/%E5%8D%95%E4%BE%8B/:0:6","series":["设计模式"],"tags":[],"title":"单例","uri":"/%E5%8D%95%E4%BE%8B/#枚举饿汉式线程安全"},{"categories":[],"content":"用了Hugo这一段时间，一直搞不明白图片怎么存放比较好，也一直弄不清楚Leaf Bundle和Branch Bundle有什么区别，今天有点时间，终于搞清楚了，并且图片也成功在Github-pages上显示出来了，特此记录一下吧！ ","date":"2022-01-17","objectID":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/:0:0","series":[],"tags":[],"title":"Hugo的图片处理","uri":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/#"},{"categories":[],"content":" Hugo的图片存放方式Hugo的图片一般有两种存放方式： 放在static目录中成为静态资源，在引用时可以以当前目录地址直接引用。比如我在static中创建了一个images目录，把所有的图片都放在里面，然后可以这样引用： ![图片](/images/xxx.png) 这种方式的问题很大： 图片没有分门别类，全都放在一起，很难维护； 由于用的是编译后的相对位置，所以在编写文章时无法实时预览，很容易导致语法错误而难以排查。 利用Leaf Bundle存放。 好处是图片与文章在同一目录下，结构清晰利于维护，并且在编辑时所见即所得。 ","date":"2022-01-17","objectID":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/:0:1","series":[],"tags":[],"title":"Hugo的图片处理","uri":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/#hugo的图片存放方式"},{"categories":[],"content":" Page BundleHugo的PageBundle只有两种： 叶子节点，其所在目录中只能有一个index.md文件，用来写文章内容，其余文件都被认为是静态资源； 枝条节点，其所在目录中只能有一个_index.md文件，用以告诉Hugo这个文件夹是个目录，所在文件夹内可包函其他叶子节点或常规文章。 ","date":"2022-01-17","objectID":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/:0:2","series":[],"tags":[],"title":"Hugo的图片处理","uri":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/#page-bundle"},{"categories":[],"content":" 利用Leaf Bundle维护图片比如我的目录结构： ├─ content │ ├─ about.md │ └─ posts │ ├─ Technology │ │ ├─ Android │ │ │ ├─ Android应用启动流程 │ │ │ │ ├─ index.md │ │ │ │ └─ 启动流程.png │ │ │ ├─ _index.md │ │ ├─ _index.md 其中Technology目录中有_index.md，所以是枝条节点，里面又有枝条节点Android，再其中，Android应用启动流程只有一个index.md和一张图，是叶子节点。我们就在这个index.md中写内容，直接引用图片启动流程.png的相对地址就可以了，代码如下： ## 流程 ![](启动流程.png) 这样就可以使图片所见即所得的编写博客文章了。 ","date":"2022-01-17","objectID":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/:0:3","series":[],"tags":[],"title":"Hugo的图片处理","uri":"/hugo%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/#利用leaf-bundle维护图片"},{"categories":[],"content":"过年这几天鼓捣一下树莓派，结果各种麻烦，尤其是安装docker-compose，明明docker安装很顺畅，为啥这货就这么麻烦呢？ 结果反复尝试，终于找出了问题的关键。docker-compose的官网是通过从github下载安装的，具体指令是： sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 就是这个指令坑了我很久。 后来查到了用pip来安装的方法，单好不容易把pip安装上之后，还是不行。 最后看到了这篇文章，感谢原作者！ 我才发现，原来是我的url有问题，首先树莓派上的ubuntu-server应该安装aarch64类型的docker-compose，正确的指令如下： sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-linux-aarch64\" -o /usr/local/bin/docker-compose 看看，对比下来发现官网的url里面的${uname}只不过是个占位符而已。 最后更换了url地址之后完美解决。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85docker-compose/:0:0","series":[],"tags":[],"title":"树莓派安装docker-compose","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85docker-compose/#"},{"categories":[],"content":"过年这几天鼓捣一下树莓派，结果各种麻烦。。。尤其是在挂载exFat格式的移动硬盘的时候，明明临时挂载是没有问题的，但是一旦做了开机自动挂载的话，就连系统都启动不了了。经过不懈的百度，终于解决了问题，特此记录一下。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:0","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#"},{"categories":[],"content":" 创建挂载点首先要创建挂载点，其实就是创建个文件夹，移动硬盘会挂载到这个文件夹，比如我创建了一个/mnt/servicedisk。 sudo mkdir /mnt/servicedisk 然后再授权： sudo chmod 777 /mnt/servicedisk 目前了解到linux有两个目录比较适合挂载移动硬盘，一个是「media」，适合挂载外部多媒体驱动，一个是「mnt」，适合挂载外部储存设备。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:1","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#创建挂载点"},{"categories":[],"content":" 临时挂载硬盘为了测试硬盘是否可用，需要先临时挂载一下。 查询硬盘信息通过下面的命令查询当前的所有硬盘信息： sudo fdisk -l 返回信息如下： pi@raspberrypi:~ $ sudo fdisk -l Disk /dev/ram0: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram1: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram2: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram3: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram4: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram5: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram6: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram7: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram8: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram9: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram10: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram11: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram12: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram13: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram14: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram15: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/mmcblk0: 119.3 GiB, 128094044160 bytes, 250183680 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x9dddeedf Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/mmcblk0p2 532480 250183679 249651200 119G 83 Linux Disk /dev/sda: 465.76 GiB, 500107862016 bytes, 976773168 sectors Disk model: HDD Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2C9DFE05-186E-4911-B369-1CED62B9A27D Device Start End Sectors Size Type /d","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:2","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#临时挂载硬盘"},{"categories":[],"content":" 临时挂载硬盘为了测试硬盘是否可用，需要先临时挂载一下。 查询硬盘信息通过下面的命令查询当前的所有硬盘信息： sudo fdisk -l 返回信息如下： pi@raspberrypi:~ $ sudo fdisk -l Disk /dev/ram0: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram1: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram2: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram3: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram4: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram5: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram6: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram7: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram8: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram9: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram10: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram11: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram12: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram13: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram14: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram15: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/mmcblk0: 119.3 GiB, 128094044160 bytes, 250183680 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x9dddeedf Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/mmcblk0p2 532480 250183679 249651200 119G 83 Linux Disk /dev/sda: 465.76 GiB, 500107862016 bytes, 976773168 sectors Disk model: HDD Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2C9DFE05-186E-4911-B369-1CED62B9A27D Device Start End Sectors Size Type /d","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:2","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#查询硬盘信息"},{"categories":[],"content":" 临时挂载硬盘为了测试硬盘是否可用，需要先临时挂载一下。 查询硬盘信息通过下面的命令查询当前的所有硬盘信息： sudo fdisk -l 返回信息如下： pi@raspberrypi:~ $ sudo fdisk -l Disk /dev/ram0: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram1: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram2: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram3: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram4: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram5: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram6: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram7: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram8: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram9: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram10: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram11: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram12: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram13: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram14: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram15: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/mmcblk0: 119.3 GiB, 128094044160 bytes, 250183680 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x9dddeedf Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/mmcblk0p2 532480 250183679 249651200 119G 83 Linux Disk /dev/sda: 465.76 GiB, 500107862016 bytes, 976773168 sectors Disk model: HDD Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2C9DFE05-186E-4911-B369-1CED62B9A27D Device Start End Sectors Size Type /d","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:2","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#临时挂载"},{"categories":[],"content":" 临时挂载硬盘为了测试硬盘是否可用，需要先临时挂载一下。 查询硬盘信息通过下面的命令查询当前的所有硬盘信息： sudo fdisk -l 返回信息如下： pi@raspberrypi:~ $ sudo fdisk -l Disk /dev/ram0: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram1: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram2: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram3: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram4: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram5: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram6: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram7: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram8: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram9: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram10: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram11: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram12: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram13: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram14: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/ram15: 4 MiB, 4194304 bytes, 8192 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk /dev/mmcblk0: 119.3 GiB, 128094044160 bytes, 250183680 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x9dddeedf Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/mmcblk0p2 532480 250183679 249651200 119G 83 Linux Disk /dev/sda: 465.76 GiB, 500107862016 bytes, 976773168 sectors Disk model: HDD Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2C9DFE05-186E-4911-B369-1CED62B9A27D Device Start End Sectors Size Type /d","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:2","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#查询挂载情况"},{"categories":[],"content":" 开机自动挂载 查询硬盘身份信息 $ sudo blkid /dev/sda2 /dev/sda2: LABEL=\"servicedisk\" UUID=\"6201-451A\" BLOCK_SIZE=\"512\" TYPE=\"exfat\" PARTUUID=\"ae27284a-b254-4bde-8a55-7457c694a22a\" 修改系统配置文件 sudo nano /etc/fstab 打开后是这样子： PARTUUID=9dddeedf-01 /boot vfat defaults 0 2 PARTUUID=9dddeedf-02 / ext4 defaults,noatime 0 1 # 在最后添加自己的移动硬盘信息 PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000 0 0 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 然后control O保存,control x退出。 坑就在这里了，网上很多帖子是用UUID或者用LEBAL，然后后面的格式用exfat或者vfat，我实测下来都失败了，重启之后ssh都连不上了。所以**这里一定要用PARTUUID和auto，后面还要跟umask=0000，四个🥚表示所有用户都有读写运行权限。 测试一下最后还要测试一下，以免重启之后ssh连不上就悲剧了，只能再重新烧录系统了。（🤦‍♂️我就因为上一步没配置对导致烧录了N遍系统） sudo mount -a 重启这个就不用说了。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:3","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#开机自动挂载"},{"categories":[],"content":" 开机自动挂载 查询硬盘身份信息 $ sudo blkid /dev/sda2 /dev/sda2: LABEL=\"servicedisk\" UUID=\"6201-451A\" BLOCK_SIZE=\"512\" TYPE=\"exfat\" PARTUUID=\"ae27284a-b254-4bde-8a55-7457c694a22a\" 修改系统配置文件 sudo nano /etc/fstab 打开后是这样子： PARTUUID=9dddeedf-01 /boot vfat defaults 0 2 PARTUUID=9dddeedf-02 / ext4 defaults,noatime 0 1 # 在最后添加自己的移动硬盘信息 PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000 0 0 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 然后control O保存,control x退出。 坑就在这里了，网上很多帖子是用UUID或者用LEBAL，然后后面的格式用exfat或者vfat，我实测下来都失败了，重启之后ssh都连不上了。所以**这里一定要用PARTUUID和auto，后面还要跟umask=0000，四个🥚表示所有用户都有读写运行权限。 测试一下最后还要测试一下，以免重启之后ssh连不上就悲剧了，只能再重新烧录系统了。（🤦‍♂️我就因为上一步没配置对导致烧录了N遍系统） sudo mount -a 重启这个就不用说了。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:3","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#查询硬盘身份信息"},{"categories":[],"content":" 开机自动挂载 查询硬盘身份信息 $ sudo blkid /dev/sda2 /dev/sda2: LABEL=\"servicedisk\" UUID=\"6201-451A\" BLOCK_SIZE=\"512\" TYPE=\"exfat\" PARTUUID=\"ae27284a-b254-4bde-8a55-7457c694a22a\" 修改系统配置文件 sudo nano /etc/fstab 打开后是这样子： PARTUUID=9dddeedf-01 /boot vfat defaults 0 2 PARTUUID=9dddeedf-02 / ext4 defaults,noatime 0 1 # 在最后添加自己的移动硬盘信息 PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000 0 0 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 然后control O保存,control x退出。 坑就在这里了，网上很多帖子是用UUID或者用LEBAL，然后后面的格式用exfat或者vfat，我实测下来都失败了，重启之后ssh都连不上了。所以**这里一定要用PARTUUID和auto，后面还要跟umask=0000，四个🥚表示所有用户都有读写运行权限。 测试一下最后还要测试一下，以免重启之后ssh连不上就悲剧了，只能再重新烧录系统了。（🤦‍♂️我就因为上一步没配置对导致烧录了N遍系统） sudo mount -a 重启这个就不用说了。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:3","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#修改系统配置文件"},{"categories":[],"content":" 开机自动挂载 查询硬盘身份信息 $ sudo blkid /dev/sda2 /dev/sda2: LABEL=\"servicedisk\" UUID=\"6201-451A\" BLOCK_SIZE=\"512\" TYPE=\"exfat\" PARTUUID=\"ae27284a-b254-4bde-8a55-7457c694a22a\" 修改系统配置文件 sudo nano /etc/fstab 打开后是这样子： PARTUUID=9dddeedf-01 /boot vfat defaults 0 2 PARTUUID=9dddeedf-02 / ext4 defaults,noatime 0 1 # 在最后添加自己的移动硬盘信息 PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000 0 0 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 然后control O保存,control x退出。 坑就在这里了，网上很多帖子是用UUID或者用LEBAL，然后后面的格式用exfat或者vfat，我实测下来都失败了，重启之后ssh都连不上了。所以**这里一定要用PARTUUID和auto，后面还要跟umask=0000，四个🥚表示所有用户都有读写运行权限。 测试一下最后还要测试一下，以免重启之后ssh连不上就悲剧了，只能再重新烧录系统了。（🤦‍♂️我就因为上一步没配置对导致烧录了N遍系统） sudo mount -a 重启这个就不用说了。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:3","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#测试一下"},{"categories":[],"content":" 开机自动挂载 查询硬盘身份信息 $ sudo blkid /dev/sda2 /dev/sda2: LABEL=\"servicedisk\" UUID=\"6201-451A\" BLOCK_SIZE=\"512\" TYPE=\"exfat\" PARTUUID=\"ae27284a-b254-4bde-8a55-7457c694a22a\" 修改系统配置文件 sudo nano /etc/fstab 打开后是这样子： PARTUUID=9dddeedf-01 /boot vfat defaults 0 2 PARTUUID=9dddeedf-02 / ext4 defaults,noatime 0 1 # 在最后添加自己的移动硬盘信息 PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000 0 0 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 然后control O保存,control x退出。 坑就在这里了，网上很多帖子是用UUID或者用LEBAL，然后后面的格式用exfat或者vfat，我实测下来都失败了，重启之后ssh都连不上了。所以**这里一定要用PARTUUID和auto，后面还要跟umask=0000，四个🥚表示所有用户都有读写运行权限。 测试一下最后还要测试一下，以免重启之后ssh连不上就悲剧了，只能再重新烧录系统了。（🤦‍♂️我就因为上一步没配置对导致烧录了N遍系统） sudo mount -a 重启这个就不用说了。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:3","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#重启"},{"categories":[],"content":" 挂载到普通用户在linux上，移动硬盘会默认挂载到root，而且里面的所有文件都是归属到root的，不支持修改。 这就麻烦了，因为我们日常操作都是以普通用户身份进行的，甚至有些第三方软件禁止以root身份运行，比如我最近在搞的Gitea。 查询当前挂载到的用户 $ ls -l -rwxr-xr-x 1 root root 808 Feb 8 15:48 docker-compose.yml drwxr-xr-x 5 root root 131072 Feb 8 13:53 gitea drwxr-xr-x 2 root root 131072 Feb 8 15:48 mysql drwxr-xr-x 2 root root 131072 Feb 8 15:28 test 查看当前普通用户的身份信息 $id uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),107(render),109(netdev),995(docker),997(gpio),998(i2c),999(spi) 可以看到： 当前用户的uid是1000 当前用户的gid(用户组id)是1000 docker的用户组id是995 临时挂载首先卸载硬盘 sudo umount /dev/sda2 再重新挂载 sudo mount /dev/sda2 service -o uid=$id gid=995 然后再次ls -l查询挂载点，就发现已经挂载到普通用户了。 开机自动挂载到目标用户同理，开机自动挂载就是在之前的基础上添加两个参数： PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000,uid=1000,gid=995 0 0 配置完可以重启试一下，在树莓派64位系统上实测是成功的。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:4","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#挂载到普通用户"},{"categories":[],"content":" 挂载到普通用户在linux上，移动硬盘会默认挂载到root，而且里面的所有文件都是归属到root的，不支持修改。 这就麻烦了，因为我们日常操作都是以普通用户身份进行的，甚至有些第三方软件禁止以root身份运行，比如我最近在搞的Gitea。 查询当前挂载到的用户 $ ls -l -rwxr-xr-x 1 root root 808 Feb 8 15:48 docker-compose.yml drwxr-xr-x 5 root root 131072 Feb 8 13:53 gitea drwxr-xr-x 2 root root 131072 Feb 8 15:48 mysql drwxr-xr-x 2 root root 131072 Feb 8 15:28 test 查看当前普通用户的身份信息 $id uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),107(render),109(netdev),995(docker),997(gpio),998(i2c),999(spi) 可以看到： 当前用户的uid是1000 当前用户的gid(用户组id)是1000 docker的用户组id是995 临时挂载首先卸载硬盘 sudo umount /dev/sda2 再重新挂载 sudo mount /dev/sda2 service -o uid=$id gid=995 然后再次ls -l查询挂载点，就发现已经挂载到普通用户了。 开机自动挂载到目标用户同理，开机自动挂载就是在之前的基础上添加两个参数： PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000,uid=1000,gid=995 0 0 配置完可以重启试一下，在树莓派64位系统上实测是成功的。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:4","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#查询当前挂载到的用户"},{"categories":[],"content":" 挂载到普通用户在linux上，移动硬盘会默认挂载到root，而且里面的所有文件都是归属到root的，不支持修改。 这就麻烦了，因为我们日常操作都是以普通用户身份进行的，甚至有些第三方软件禁止以root身份运行，比如我最近在搞的Gitea。 查询当前挂载到的用户 $ ls -l -rwxr-xr-x 1 root root 808 Feb 8 15:48 docker-compose.yml drwxr-xr-x 5 root root 131072 Feb 8 13:53 gitea drwxr-xr-x 2 root root 131072 Feb 8 15:48 mysql drwxr-xr-x 2 root root 131072 Feb 8 15:28 test 查看当前普通用户的身份信息 $id uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),107(render),109(netdev),995(docker),997(gpio),998(i2c),999(spi) 可以看到： 当前用户的uid是1000 当前用户的gid(用户组id)是1000 docker的用户组id是995 临时挂载首先卸载硬盘 sudo umount /dev/sda2 再重新挂载 sudo mount /dev/sda2 service -o uid=$id gid=995 然后再次ls -l查询挂载点，就发现已经挂载到普通用户了。 开机自动挂载到目标用户同理，开机自动挂载就是在之前的基础上添加两个参数： PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000,uid=1000,gid=995 0 0 配置完可以重启试一下，在树莓派64位系统上实测是成功的。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:4","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#查看当前普通用户的身份信息"},{"categories":[],"content":" 挂载到普通用户在linux上，移动硬盘会默认挂载到root，而且里面的所有文件都是归属到root的，不支持修改。 这就麻烦了，因为我们日常操作都是以普通用户身份进行的，甚至有些第三方软件禁止以root身份运行，比如我最近在搞的Gitea。 查询当前挂载到的用户 $ ls -l -rwxr-xr-x 1 root root 808 Feb 8 15:48 docker-compose.yml drwxr-xr-x 5 root root 131072 Feb 8 13:53 gitea drwxr-xr-x 2 root root 131072 Feb 8 15:48 mysql drwxr-xr-x 2 root root 131072 Feb 8 15:28 test 查看当前普通用户的身份信息 $id uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),107(render),109(netdev),995(docker),997(gpio),998(i2c),999(spi) 可以看到： 当前用户的uid是1000 当前用户的gid(用户组id)是1000 docker的用户组id是995 临时挂载首先卸载硬盘 sudo umount /dev/sda2 再重新挂载 sudo mount /dev/sda2 service -o uid=$id gid=995 然后再次ls -l查询挂载点，就发现已经挂载到普通用户了。 开机自动挂载到目标用户同理，开机自动挂载就是在之前的基础上添加两个参数： PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000,uid=1000,gid=995 0 0 配置完可以重启试一下，在树莓派64位系统上实测是成功的。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:4","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#临时挂载-1"},{"categories":[],"content":" 挂载到普通用户在linux上，移动硬盘会默认挂载到root，而且里面的所有文件都是归属到root的，不支持修改。 这就麻烦了，因为我们日常操作都是以普通用户身份进行的，甚至有些第三方软件禁止以root身份运行，比如我最近在搞的Gitea。 查询当前挂载到的用户 $ ls -l -rwxr-xr-x 1 root root 808 Feb 8 15:48 docker-compose.yml drwxr-xr-x 5 root root 131072 Feb 8 13:53 gitea drwxr-xr-x 2 root root 131072 Feb 8 15:48 mysql drwxr-xr-x 2 root root 131072 Feb 8 15:28 test 查看当前普通用户的身份信息 $id uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),107(render),109(netdev),995(docker),997(gpio),998(i2c),999(spi) 可以看到： 当前用户的uid是1000 当前用户的gid(用户组id)是1000 docker的用户组id是995 临时挂载首先卸载硬盘 sudo umount /dev/sda2 再重新挂载 sudo mount /dev/sda2 service -o uid=$id gid=995 然后再次ls -l查询挂载点，就发现已经挂载到普通用户了。 开机自动挂载到目标用户同理，开机自动挂载就是在之前的基础上添加两个参数： PARTUUID=ae27284a-b254-4bde-8a55-7457c694a22a /mnt/servicedisk auto umask=0000,uid=1000,gid=995 0 0 配置完可以重启试一下，在树莓派64位系统上实测是成功的。 ","date":"2022-01-17","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/:0:4","series":[],"tags":[],"title":"树莓派挂载移动硬盘","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/#开机自动挂载到目标用户"},{"categories":[],"content":" WebView与原生对比差在哪里？这里引用百度APP图片来说明。 百度的开发人员将这一整个过程划分为了四个阶段，并统计出了各个阶段的平均耗时。 可以看到，在初始化组件阶段就花费了 260 ms，首次创建耗时均值为 500 ms，毫无疑问这是我们要优化的第一点。而最耗时的当属正文加载\u0026渲染和图片加载两个阶段。为什么会这么耗时呢，因为这两个阶段需要进行多次网络请求、JS 调用、IO 读写。所以这里也是我们需要优化的地方。 可以得出优化方向： WebView预创建和复用 渲染优化（JS、CSS、图片） 模板优化（拆分、预热、复用） ","date":"2022-01-06","objectID":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:1","series":[],"tags":[],"title":"WebView性能优化","uri":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#webview与原生对比差在哪里"},{"categories":[],"content":" WebView预创建和复用WebView 的创建是比较耗时的，首次创建耗时几百毫秒，因此预创建和复用尤为重要。 大致逻辑是先创建WebView并缓存起来，等到需要的时候直接取出来，代码如下： class WebViewManager private constructor() { // 为了阅读体验，省略部分代码 private val webViewCache: MutableList\u003cWebView\u003e = ArrayList(1) private fun create(context: Context): WebView { val webView = WebView(context) // ...... return webView } fun prepare(context: Context) { if (webViewCache.isEmpty()) { Looper.myQueue().addIdleHandler { webViewCache.add(create(MutableContextWrapper(context))) false } } } fun obtain(context: Context): WebView { if (webViewCache.isEmpty()) { webViewCache.add(create(MutableContextWrapper(context))) } val webView = webViewCache.removeFirst() val contextWrapper = webView.context as MutableContextWrapper contextWrapper.baseContext = context webView.clearHistory() webView.resumeTimers() return webView } fun recycle(webView: WebView) { try { webView.stopLoading() webView.loadDataWithBaseURL(null, \"\", \"text/html\", \"utf-8\", null) webView.clearHistory() webView.pauseTimers() webView.webChromeClient = null webView.webViewClient = null val parent = webView.parent if (parent != null) { (parent as ViewGroup).removeView(webView) } } catch (e: Exception) { e.printStackTrace() } finally { if (!webViewCache.contains(webView)) { webViewCache.add(webView) } } } fun destroy() { try { webViewCache.forEach { it.removeAllViews() it.destroy() webViewCache.remove(it) } } catch (e: Exception) { e.printStackTrace() } } } 这里需要注意以下几点： 预加载时机的选择 WebView 的创建是比较耗时的，为了使预加载不会影响到当前主线程任务，我们选择 IdleHandler 来执行预创建，以保证不会影响到当前主线程任务。详细请看 prepare(context: Context) 方法。 Context的选择 每个 WebView 需要和对应的 Activity Context 实例进行绑定，为了保证预加载的 WebView Context 和最终的 Context 之间的一致性，我们通过 MutableContextWrapper 来解决这个问题。MutableContextWrapper 允许外部替换它的 baseContext ，因此 prepare(context: Context)方法可以传 applicationContext 进行预创建，等到实际调用时再进行替换，详细请看 obtain(context: Context) 方法。 复用和销毁 在页面关闭前调用 recycle(webView: WebView) 进行回收，在应用退出前调用 destroy() 进行销毁。 复用WebView返回空白 在调用 recycle(webView: WebView) 进行回收时，我们会调用 loadDataWithBaseURL(null, “”, “text/html”, “utf-8”, null) 清除页面内容，导致复用时的加载栈底就是这个空白页面，所以我们需要在返回时对栈底进行判断，如果为空则直接返回，代码如下： fun canGoBack(): Boolean { val canBack = webView.canGoBack() if (canBack) webView.goBack() val backForwardList = webView.copyBackForwardList() val currentIndex = backForwardList.currentIndex if (currentIndex == 0) { val currentUrl = backForwardList.currentItem.url val currentHost = Uri.parse(currentUrl).host //栈底不是链接则直接返回 if (currentHost.isNullOrBlank()) return false } return canBack } ### 渲染优化（JS、CSS、图片） WebView 在加载内容的时候会进行多次网络请求、JS 调用、IO 读写。我们可以借由内核的 shouldInterceptRequest 回调，拦截资源请求由客户端进行下载，并以管道方式填充到内核的 WebResourceResponse中，这里引用百度APP图片来说明。 ![WebView渲染过程](WebView渲染过程.awebp) 预置离线包 精简并抽取公共的 JS 和 CSS 文件作为通用资源，将抽取的资源存放在 assets 下，再通过约定的规则去匹配，代码如下： ```kotlin webView.webViewClient = object : WebViewClient() { // 为了阅读体验，省略部分代码 override fun shouldInterceptRequest( view: WebView?, request: WebResourceRequest? ): WebResourceResponse? { if (view != null \u0026\u0026 request != null) { if(canAssetsResource(request)){ return assetsResourceRequest(view.context, request) } } return super.shouldInterceptRequest(view, request) } } private fun assetsResourceRequest( context: Context, webRequest: WebResourceRequest ): WebResourceResponse? { ... try { val url = webRequest.url.toString() val filenameIndex = url.lastIndexOf(\"/\") + 1 val filename = url.substring(filenameIndex) val suffixIndex = url.lastIndexOf(\".\") val suffix = url.substring(suffixIndex + 1) val webResourceResponse = WebResourceResponse() webResourceResponse.mimeType = getMimeTypeFromUrl(url) webResourceResponse.encoding = \"UTF-8\" webResourceResponse.data = context.assets.open(\"$suffix/$filename\") return webResourceResponse } catch (e: Exception) { e.printStackTrace() } return null } ","date":"2022-01-06","objectID":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:2","series":[],"tags":[],"title":"WebView性能优化","uri":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#webview预创建和复用"},{"categories":[],"content":" 接口更新缓存资源除了预置离线包外，我们还可以通过接口请求，获取最新的缓存资源，以及通过请求资源的类型自行缓存，代码如下： webView.webViewClient = object : WebViewClient() { ... override fun shouldInterceptRequest( view: WebView?, request: WebResourceRequest? ): WebResourceResponse? { if (view != null \u0026\u0026 request != null) { if(canCacheResource(request)){ return cacheResourceRequest(view.context, request) } } return super.shouldInterceptRequest(view, request) } } private fun canCacheResource(webRequest: WebResourceRequest): Boolean { // 为了阅读体验，省略部分代码 val url = webRequest.url.toString() val extension = getExtensionFromUrl(url) return extension == \"ico\" || extension == \"bmp\" || extension == \"gif\" || extension == \"jpeg\" || extension == \"jpg\" || extension == \"png\" || extension == \"svg\" || extension == \"webp\" || extension == \"css\" || extension == \"js\" || extension == \"json\" || extension == \"eot\" || extension == \"otf\" || extension == \"ttf\" || extension == \"woff\" } private fun cacheResourceRequest( context: Context, webRequest: WebResourceRequest ): WebResourceResponse? { ... try { val url = webRequest.url.toString() val cachePath = CacheUtils.getCacheDirPath(context, \"web_cache\") val filePathName = cachePath + File.separator + url.encodeUtf8().md5().hex() val file = File(filePathName) if (!file.exists() || !file.isFile) { runBlocking { // 开启网络请求下载资源 download(HttpRequest(url).apply { webRequest.requestHeaders.forEach { putHeader(it.key, it.value) } }, filePathName) } } if (file.exists() \u0026\u0026 file.isFile) { val webResourceResponse = WebResourceResponse() webResourceResponse.mimeType = getMimeTypeFromUrl(url) webResourceResponse.encoding = \"UTF-8\" webResourceResponse.data = file.inputStream() webResourceResponse.responseHeaders = mapOf(\"access-control-allow-origin\" to \"*\") return webResourceResponse } } catch (e: Exception) { e.printStackTrace() } return null } 我们通过canCacheResource(webRequest: WebResourceRequest)来判断是否是需要缓存的资源。 再根据URL去获取缓存中文件，否则开启网络请求下载资源，详细请看 cacheResourceRequest(context: Context, webRequest: WebResourceRequest) 。 这边仅对图片、字体、CSS、JS、JSON进行缓存，可根据项目实际情况缓存更多类型资源。 ","date":"2022-01-06","objectID":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:3","series":[],"tags":[],"title":"WebView性能优化","uri":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#接口更新缓存资源"},{"categories":[],"content":" 模板优化（拆分、预热、复用）关于模板，代码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003etitle\u003c/title\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"xxx.css\"\u003e \u003cscript\u003e function changeContent(data){ document.getElementById('content').innerHTML=data; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"content\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 客户端加载模板代码（温馨提示：上面只是例子，实际模板根据情况拆分），加载完成后再调用 JS 方法注入数据。 数据哪里来呢？这里以列表页跳转详情页举个例子，仅供参考： 列表页接口返回列表数据的时候带上详情内容，跳转详情页的时候带上内容数据。优点简单粗暴，缺点耗费流量。 当然还有其他方法这里不再多说，可根据自己的实际需求进行选择。 ","date":"2022-01-06","objectID":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:4","series":[],"tags":[],"title":"WebView性能优化","uri":"/webview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#模板优化拆分预热复用"},{"categories":["第三方框架"],"content":"未完待续。。。 在OkhttpClient对象中持有一个链接池ConnectionPool connectionPool，今天我就研究一下ok的链接复用机制。 ","date":"2021-10-29","objectID":"/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/:0:0","series":["okhttp"],"tags":["okhttp"],"title":"Okhttp的链接池","uri":"/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/#"},{"categories":["第三方框架"],"content":" ConnectionPool类主要用于管理和复用连接。 public final class ConnectionPool { // 当然离不开线程池，核心线程数为0，最大线程数无限大，包活时间为60秒，同步队列，最后是设为守护线程？ private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e(), Util.threadFactory(\"OkHttp ConnectionPool\", true)); // 最大闲置连接数 private final int maxIdleConnections; // 保活时间 private final long keepAliveDurationNs; private final Runnable cleanupRunnable = new Runnable() { @Override public void run() { while (true) { long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos \u003e 0) { long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) { try { ConnectionPool.this.wait(waitMillis, (int) waitNanos); } catch (InterruptedException ignored) { } } } } } }; private final Deque\u003cRealConnection\u003e connections = new ArrayDeque\u003c\u003e(); final RouteDatabase routeDatabase = new RouteDatabase(); boolean cleanupRunning; /** * Create a new connection pool with tuning parameters appropriate for a single-user application. * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity. */ public ConnectionPool() { this(5, 5, TimeUnit.MINUTES); } public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) { this.maxIdleConnections = maxIdleConnections; this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration); // Put a floor on the keep alive duration, otherwise cleanup will spin loop. if (keepAliveDuration \u003c= 0) { throw new IllegalArgumentException(\"keepAliveDuration \u003c= 0: \" + keepAliveDuration); } } // 返回闲置线程数 public synchronized int idleConnectionCount() { int total = 0; for (RealConnection connection : connections) { if (connection.allocations.isEmpty()) total++; } return total; } public synchronized int connectionCount() { return connections.size(); } /** * Returns a recycled connection to {@code address}, or null if no such connection exists. The * route is null if the address has not yet been routed. */ @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) { assert (Thread.holdsLock(this)); for (RealConnection connection : connections) { if (connection.isEligible(address, route)) { streamAllocation.acquire(connection, true); return connection; } } return null; } /** * Replaces the connection held by {@code streamAllocation} with a shared connection if possible. * This recovers when multiple multiplexed connections are created concurrently. */ @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) { assert (Thread.holdsLock(this)); for (RealConnection connection : connections) { if (connection.isEligible(address, null) \u0026\u0026 connection.isMultiplexed() \u0026\u0026 connection != streamAllocation.connection()) { return streamAllocation.releaseAndAcquire(connection); } } return null; } void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; executor.execute(cleanupRunnable); } connections.add(connection); } /** * Notify this pool that {@code connection} has become idle. Returns true if the connection has * been removed from the pool and should be closed. */ boolean connectionBecameIdle(RealConnection connection) { assert (Thread.holdsLock(this)); if (connection.noNewStreams || maxIdleConnections == 0) { connections.remove(connection); return true; } else { notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit. return false; } } /** Close and remove all idle connections in the pool. */ public void evictAll() { List\u003cRealConnection\u003e evictedConnections = new ArrayList\u003c\u003e(); synchronized (this) { for (Iterator\u003cRealConnection\u003e i = connections.iterator(); i.hasNext(); ) { RealConnection connection = i.next(); if (con","date":"2021-10-29","objectID":"/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"Okhttp的链接池","uri":"/okhttp%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B1%A0/#connectionpool类"},{"categories":["第三方框架"],"content":"TODO ","date":"2021-09-18","objectID":"/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/:0:0","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp的缓存机制","uri":"/okhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#"},{"categories":["第三方框架"],"content":"之前已经了解过，OkHttp默认添加CacheInterceptor来处理缓存，而后者是依靠DiskLruCache来实现硬盘缓存读写，所以我先去看了一下Android内置的LruCache原理，是依靠java的LinkedHashMap的LRU排序算法实现的，最后我准备详细看看DiskLruCache是怎么基于硬盘缓存实现LRU的。 ","date":"2021-09-16","objectID":"/disklrucache/:0:0","series":["okhttp"],"tags":["okhttp"],"title":"DiskLruCache","uri":"/disklrucache/#"},{"categories":["第三方框架"],"content":" 写在前面据说最早DiskLruCache并不是Android实现的，所以系统中并没有内置这个类，所以一般使用前先从github上下载，而OkHttp中更干脆，直接自己实现(mo gai)了一个，所以本文的DiskLruCache是位于okhttp3.internal.cache包下的。不过实现原理也都差不多。 ","date":"2021-09-16","objectID":"/disklrucache/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"DiskLruCache","uri":"/disklrucache/#写在前面"},{"categories":["第三方框架"],"content":" 静态创建方法 public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize) { // Use a single background thread to evict entries. // 创建了一个单线程的线程池 Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(), Util.threadFactory(\"OkHttp DiskLruCache\", true)); return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor); } 首先创建了一个单线程的线程池，核心线程数为0，最大线程数为1，活跃时间为1分钟，创建的线程是守护线程。 然后创建一个DiskLruCache，并传递了线程池。 ","date":"2021-09-16","objectID":"/disklrucache/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"DiskLruCache","uri":"/disklrucache/#静态创建方法"},{"categories":["第三方框架"],"content":" 构造方法 DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize, Executor executor) { this.fileSystem = fileSystem; this.directory = directory; this.appVersion = appVersion; this.journalFile = new File(directory, JOURNAL_FILE); this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP); this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP); this.valueCount = valueCount; this.maxSize = maxSize; this.executor = executor; } 这里创建了3个文件： journalFile：标准的journal文件 journalFileTmp journalFileBackup ","date":"2021-09-16","objectID":"/disklrucache/:0:3","series":["okhttp"],"tags":["okhttp"],"title":"DiskLruCache","uri":"/disklrucache/#构造方法"},{"categories":["第三方框架"],"content":" edit方法对应的是map的put方法。 // 看看，还是基于这玩意的「插入排序」实现的 final LinkedHashMap\u003cString, Entry\u003e lruEntries = new LinkedHashMap\u003c\u003e(0, 0.75f, true); // edit方法 synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException { // 首先初始化 initialize(); // 当前DiskLruCache的关闭检查，必须关闭之后才能edit。 checkNotClosed(); // key的安全检查 validateKey(key); // 查询到对应的entry Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER \u0026\u0026 (entry == null || entry.sequenceNumber != expectedSequenceNumber)) { return null; // Snapshot is stale. } if (entry != null \u0026\u0026 entry.currentEditor != null) { return null; // Another edit is in progress. } if (mostRecentTrimFailed || mostRecentRebuildFailed) { // The OS has become our enemy! If the trim job failed, it means we are storing more data than // requested by the user. Do not allow edits so we do not go over that limit any further. If // the journal rebuild failed, the journal writer will not be active, meaning we will not be // able to record the edit, causing file leaks. In both cases, we want to retry the clean up // so we can get out of this state! //异步执行 executor.execute(cleanupRunnable); return null; } // Flush the journal before creating files to prevent file leaks. journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\\n'); journalWriter.flush(); if (hasJournalErrors) { return null; // Don't edit; the journal can't be written. } if (entry == null) { entry = new Entry(key); lruEntries.put(key, entry); } Editor editor = new Editor(entry); entry.currentEditor = editor; return editor; } 先调用了初始化方法initialize，主要干了两件事情： 从备份中恢复； 通过okio，从文件中读取键值对到LinkedHashMap。 public synchronized void initialize() throws IOException { assert Thread.holdsLock(this); if (initialized) { return; // Already initialized. } // 从备份中恢复 if (fileSystem.exists(journalFileBackup)) { // If journal file also exists just delete backup file. if (fileSystem.exists(journalFile)) { fileSystem.delete(journalFileBackup); } else { fileSystem.rename(journalFileBackup, journalFile); } } // Prefer to pick up where we left off. if (fileSystem.exists(journalFile)) { try { // 读取杂志文件 readJournal(); processJournal(); initialized = true; return; } catch (IOException journalIsCorrupt) { Platform.get().log(WARN, \"DiskLruCache \" + directory + \" is corrupt: \" + journalIsCorrupt.getMessage() + \", removing\", journalIsCorrupt); } try { delete(); } finally { closed = false; } } rebuildJournal(); initialized = true; } ","date":"2021-09-16","objectID":"/disklrucache/:0:4","series":["okhttp"],"tags":["okhttp"],"title":"DiskLruCache","uri":"/disklrucache/#edit方法"},{"categories":["第三方框架"],"content":" 懒得看了找到一篇文章讲的不错： 感谢原作者 接下来想先去看看okio。 ","date":"2021-09-16","objectID":"/disklrucache/:0:5","series":["okhttp"],"tags":["okhttp"],"title":"DiskLruCache","uri":"/disklrucache/#懒得看了"},{"categories":[],"content":"LRU这个算法就是把最近一次使用时间离现在时间最远的数据删除掉，而实现LruCache将会频繁的执行插入、删除等操作，我们就会想到使用LinkedList，但是我们又要基于Key-Value来保存数据，这个时候我们就会想起HashMap，但是HashMap不能像linkedList那样保留数据的插入顺序，如果要使用HashMap的话可以使用它的一个子类LinkedHashMap。 ","date":"2021-09-15","objectID":"/lrucache/:0:0","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#"},{"categories":[],"content":" LinkedHashMap可理解为有序的HashMap。 构造方法 // 队首 private transient LinkedHashMapEntry\u003cK,V\u003e header; // 排序模式 private final boolean accessOrder; public class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e implements Map\u003cK,V\u003e { ... } 这货是继承自HashMap的，那么他就有HashMap的所有特性，包括线程不安全和翻倍扩容。 然后来看一下他内部的entry： 入口Entry /** * 继承自HashMap的Entry */ private static class LinkedHashMapEntry\u003cK,V\u003e extends HashMapEntry\u003cK,V\u003e { // 内部实现了自己的before和after，成了一个双向链表 LinkedHashMapEntry\u003cK,V\u003e before, after; ... } 可以看到，他内部的Entry同时具备双向链和单向链(继承了HashMap的entry内部的next字段)结构。 next是用于维护HashMap指定table位置上连接的Entry的顺序的； before、After是用于维护Entry插入的先后顺序的。 核心构造方法 // 排序模式 true-访问排序 false-插入排序 private final boolean accessOrder; public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 与HashMap的主要区别就是多了accessOrder属性，它的作用是选择排序模式： true 访问排序 false 插入排序 这里有个坑要注意的是，调用了父类的构造函数： public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003e MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity \u003c DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } threshold = initialCapacity; // 这个init方法好坑啊 init(); } void init() {} 其中调用了init方法，而HashMap中并没有实现这个方法，说明是专门用来给子类初始化的，于是我去看LinkedHashMap中的重写实现： @Override void init() { header = new LinkedHashMapEntry\u003c\u003e(-1, null, null, null); header.before = header.after = header; } 初始化了队首的entry，并且它的before和after都是它自身。 put方法LinkedHashMap并没有重写put方法，所以他是直接沿用了HashMap的put方法。 来回顾一下HashMap的put方法： public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); // 计算Key的Hash值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //找到key的下标位置 int i = indexFor(hash, table.length); //遍历单向链，插入到对应的hash位置 for (HashMapEntry\u003cK,V\u003e e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //没有对应则插到末尾 modCount++; addEntry(hash, key, value, i); return null; } 这里有一点要注意的是，LinkedHashMap大量运用了多态，所以在添加的时候调用的addEntry方法，实际上是LinkedHashMap已经重写过的： void addEntry(int hash, K key, V value, int bucketIndex) { LinkedHashMapEntry\u003cK,V\u003e eldest = header.after; // 如果after不是自己 if (eldest != header) { boolean removeEldest; size++; try { removeEldest = removeEldestEntry(eldest); } finally { size--; } if (removeEldest) { removeEntryForKey(eldest.key); } } super.addEntry(hash, key, value, bucketIndex); } 然后又调用父类的addEntry方法，而在其中再次调用自己的多态方法createEntry： void createEntry(int hash, K key, V value, int bucketIndex) { HashMapEntry\u003cK,V\u003e old = table[bucketIndex]; LinkedHashMapEntry\u003cK,V\u003e e = new LinkedHashMapEntry\u003c\u003e(hash, key, value, old); table[bucketIndex] = e; // 同时指定了after和before e.addBefore(header); size++; } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry\u003cK,V\u003e existingEntry) { // 插入到header之前 after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 创建了一个entry，插入到header与old之间，再把size+1，这样就形成了插入顺序。 get方法 public V get(Object key) { // 先通过key拿到entry LinkedHashMapEntry\u003cK,V\u003e e = (LinkedHashMapEntry\u003cK,V\u003e)getEntry(key); // 判空 if (e == null) return null; e.recordAccess(this); return e.value; } // 记录下访问操作 void recordAccess(HashMap\u003cK,V\u003e m) { LinkedHashMap\u003cK,V\u003e lm = (LinkedHashMap\u003cK,V\u003e)m; // 如果是访问排序，就把查到的entry排到首位 if (lm.accessOrder) { lm.modCount++; // 先移除目标entry自身 before.after = after; after.before = before; //插入到header之前 addBefore(lm.header); } } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry\u003cK,V\u003e existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 首先调用HashMap的getEntry方法，根据key查到entry，然后通过recordAccess方法把查到的entry调整到队首位置，让他最靠前！！！ LinkedHashMap的总结 原理：以HashMap来维护数据结构，以LinkedList来记录插入顺序； 插入和查询处理：以内部entry的addBefore方法提供lru算法，把当前的目标entry排到队首，实现「entry越长时间不操作，插入顺序就越靠后」； 核心容器：父类HashMap中的table三列表，和自己维护的header双向链。 ","date":"2021-09-15","objectID":"/lrucache/:0:1","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#linkedhashmap"},{"categories":[],"content":" LinkedHashMap可理解为有序的HashMap。 构造方法 // 队首 private transient LinkedHashMapEntry header; // 排序模式 private final boolean accessOrder; public class LinkedHashMap extends HashMap implements Map { ... } 这货是继承自HashMap的，那么他就有HashMap的所有特性，包括线程不安全和翻倍扩容。 然后来看一下他内部的entry： 入口Entry /** * 继承自HashMap的Entry */ private static class LinkedHashMapEntry extends HashMapEntry { // 内部实现了自己的before和after，成了一个双向链表 LinkedHashMapEntry before, after; ... } 可以看到，他内部的Entry同时具备双向链和单向链(继承了HashMap的entry内部的next字段)结构。 next是用于维护HashMap指定table位置上连接的Entry的顺序的； before、After是用于维护Entry插入的先后顺序的。 核心构造方法 // 排序模式 true-访问排序 false-插入排序 private final boolean accessOrder; public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 与HashMap的主要区别就是多了accessOrder属性，它的作用是选择排序模式： true 访问排序 false 插入排序 这里有个坑要注意的是，调用了父类的构造函数： public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003e MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity \u003c DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } threshold = initialCapacity; // 这个init方法好坑啊 init(); } void init() {} 其中调用了init方法，而HashMap中并没有实现这个方法，说明是专门用来给子类初始化的，于是我去看LinkedHashMap中的重写实现： @Override void init() { header = new LinkedHashMapEntry\u003c\u003e(-1, null, null, null); header.before = header.after = header; } 初始化了队首的entry，并且它的before和after都是它自身。 put方法LinkedHashMap并没有重写put方法，所以他是直接沿用了HashMap的put方法。 来回顾一下HashMap的put方法： public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); // 计算Key的Hash值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //找到key的下标位置 int i = indexFor(hash, table.length); //遍历单向链，插入到对应的hash位置 for (HashMapEntry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //没有对应则插到末尾 modCount++; addEntry(hash, key, value, i); return null; } 这里有一点要注意的是，LinkedHashMap大量运用了多态，所以在添加的时候调用的addEntry方法，实际上是LinkedHashMap已经重写过的： void addEntry(int hash, K key, V value, int bucketIndex) { LinkedHashMapEntry eldest = header.after; // 如果after不是自己 if (eldest != header) { boolean removeEldest; size++; try { removeEldest = removeEldestEntry(eldest); } finally { size--; } if (removeEldest) { removeEntryForKey(eldest.key); } } super.addEntry(hash, key, value, bucketIndex); } 然后又调用父类的addEntry方法，而在其中再次调用自己的多态方法createEntry： void createEntry(int hash, K key, V value, int bucketIndex) { HashMapEntry old = table[bucketIndex]; LinkedHashMapEntry e = new LinkedHashMapEntry\u003c\u003e(hash, key, value, old); table[bucketIndex] = e; // 同时指定了after和before e.addBefore(header); size++; } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { // 插入到header之前 after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 创建了一个entry，插入到header与old之间，再把size+1，这样就形成了插入顺序。 get方法 public V get(Object key) { // 先通过key拿到entry LinkedHashMapEntry e = (LinkedHashMapEntry)getEntry(key); // 判空 if (e == null) return null; e.recordAccess(this); return e.value; } // 记录下访问操作 void recordAccess(HashMap m) { LinkedHashMap lm = (LinkedHashMap)m; // 如果是访问排序，就把查到的entry排到首位 if (lm.accessOrder) { lm.modCount++; // 先移除目标entry自身 before.after = after; after.before = before; //插入到header之前 addBefore(lm.header); } } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 首先调用HashMap的getEntry方法，根据key查到entry，然后通过recordAccess方法把查到的entry调整到队首位置，让他最靠前！！！ LinkedHashMap的总结 原理：以HashMap来维护数据结构，以LinkedList来记录插入顺序； 插入和查询处理：以内部entry的addBefore方法提供lru算法，把当前的目标entry排到队首，实现「entry越长时间不操作，插入顺序就越靠后」； 核心容器：父类HashMap中的table三列表，和自己维护的header双向链。 ","date":"2021-09-15","objectID":"/lrucache/:0:1","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#构造方法"},{"categories":[],"content":" LinkedHashMap可理解为有序的HashMap。 构造方法 // 队首 private transient LinkedHashMapEntry header; // 排序模式 private final boolean accessOrder; public class LinkedHashMap extends HashMap implements Map { ... } 这货是继承自HashMap的，那么他就有HashMap的所有特性，包括线程不安全和翻倍扩容。 然后来看一下他内部的entry： 入口Entry /** * 继承自HashMap的Entry */ private static class LinkedHashMapEntry extends HashMapEntry { // 内部实现了自己的before和after，成了一个双向链表 LinkedHashMapEntry before, after; ... } 可以看到，他内部的Entry同时具备双向链和单向链(继承了HashMap的entry内部的next字段)结构。 next是用于维护HashMap指定table位置上连接的Entry的顺序的； before、After是用于维护Entry插入的先后顺序的。 核心构造方法 // 排序模式 true-访问排序 false-插入排序 private final boolean accessOrder; public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 与HashMap的主要区别就是多了accessOrder属性，它的作用是选择排序模式： true 访问排序 false 插入排序 这里有个坑要注意的是，调用了父类的构造函数： public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003e MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity \u003c DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } threshold = initialCapacity; // 这个init方法好坑啊 init(); } void init() {} 其中调用了init方法，而HashMap中并没有实现这个方法，说明是专门用来给子类初始化的，于是我去看LinkedHashMap中的重写实现： @Override void init() { header = new LinkedHashMapEntry\u003c\u003e(-1, null, null, null); header.before = header.after = header; } 初始化了队首的entry，并且它的before和after都是它自身。 put方法LinkedHashMap并没有重写put方法，所以他是直接沿用了HashMap的put方法。 来回顾一下HashMap的put方法： public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); // 计算Key的Hash值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //找到key的下标位置 int i = indexFor(hash, table.length); //遍历单向链，插入到对应的hash位置 for (HashMapEntry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //没有对应则插到末尾 modCount++; addEntry(hash, key, value, i); return null; } 这里有一点要注意的是，LinkedHashMap大量运用了多态，所以在添加的时候调用的addEntry方法，实际上是LinkedHashMap已经重写过的： void addEntry(int hash, K key, V value, int bucketIndex) { LinkedHashMapEntry eldest = header.after; // 如果after不是自己 if (eldest != header) { boolean removeEldest; size++; try { removeEldest = removeEldestEntry(eldest); } finally { size--; } if (removeEldest) { removeEntryForKey(eldest.key); } } super.addEntry(hash, key, value, bucketIndex); } 然后又调用父类的addEntry方法，而在其中再次调用自己的多态方法createEntry： void createEntry(int hash, K key, V value, int bucketIndex) { HashMapEntry old = table[bucketIndex]; LinkedHashMapEntry e = new LinkedHashMapEntry\u003c\u003e(hash, key, value, old); table[bucketIndex] = e; // 同时指定了after和before e.addBefore(header); size++; } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { // 插入到header之前 after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 创建了一个entry，插入到header与old之间，再把size+1，这样就形成了插入顺序。 get方法 public V get(Object key) { // 先通过key拿到entry LinkedHashMapEntry e = (LinkedHashMapEntry)getEntry(key); // 判空 if (e == null) return null; e.recordAccess(this); return e.value; } // 记录下访问操作 void recordAccess(HashMap m) { LinkedHashMap lm = (LinkedHashMap)m; // 如果是访问排序，就把查到的entry排到首位 if (lm.accessOrder) { lm.modCount++; // 先移除目标entry自身 before.after = after; after.before = before; //插入到header之前 addBefore(lm.header); } } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 首先调用HashMap的getEntry方法，根据key查到entry，然后通过recordAccess方法把查到的entry调整到队首位置，让他最靠前！！！ LinkedHashMap的总结 原理：以HashMap来维护数据结构，以LinkedList来记录插入顺序； 插入和查询处理：以内部entry的addBefore方法提供lru算法，把当前的目标entry排到队首，实现「entry越长时间不操作，插入顺序就越靠后」； 核心容器：父类HashMap中的table三列表，和自己维护的header双向链。 ","date":"2021-09-15","objectID":"/lrucache/:0:1","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#入口entry"},{"categories":[],"content":" LinkedHashMap可理解为有序的HashMap。 构造方法 // 队首 private transient LinkedHashMapEntry header; // 排序模式 private final boolean accessOrder; public class LinkedHashMap extends HashMap implements Map { ... } 这货是继承自HashMap的，那么他就有HashMap的所有特性，包括线程不安全和翻倍扩容。 然后来看一下他内部的entry： 入口Entry /** * 继承自HashMap的Entry */ private static class LinkedHashMapEntry extends HashMapEntry { // 内部实现了自己的before和after，成了一个双向链表 LinkedHashMapEntry before, after; ... } 可以看到，他内部的Entry同时具备双向链和单向链(继承了HashMap的entry内部的next字段)结构。 next是用于维护HashMap指定table位置上连接的Entry的顺序的； before、After是用于维护Entry插入的先后顺序的。 核心构造方法 // 排序模式 true-访问排序 false-插入排序 private final boolean accessOrder; public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 与HashMap的主要区别就是多了accessOrder属性，它的作用是选择排序模式： true 访问排序 false 插入排序 这里有个坑要注意的是，调用了父类的构造函数： public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003e MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity \u003c DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } threshold = initialCapacity; // 这个init方法好坑啊 init(); } void init() {} 其中调用了init方法，而HashMap中并没有实现这个方法，说明是专门用来给子类初始化的，于是我去看LinkedHashMap中的重写实现： @Override void init() { header = new LinkedHashMapEntry\u003c\u003e(-1, null, null, null); header.before = header.after = header; } 初始化了队首的entry，并且它的before和after都是它自身。 put方法LinkedHashMap并没有重写put方法，所以他是直接沿用了HashMap的put方法。 来回顾一下HashMap的put方法： public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); // 计算Key的Hash值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //找到key的下标位置 int i = indexFor(hash, table.length); //遍历单向链，插入到对应的hash位置 for (HashMapEntry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //没有对应则插到末尾 modCount++; addEntry(hash, key, value, i); return null; } 这里有一点要注意的是，LinkedHashMap大量运用了多态，所以在添加的时候调用的addEntry方法，实际上是LinkedHashMap已经重写过的： void addEntry(int hash, K key, V value, int bucketIndex) { LinkedHashMapEntry eldest = header.after; // 如果after不是自己 if (eldest != header) { boolean removeEldest; size++; try { removeEldest = removeEldestEntry(eldest); } finally { size--; } if (removeEldest) { removeEntryForKey(eldest.key); } } super.addEntry(hash, key, value, bucketIndex); } 然后又调用父类的addEntry方法，而在其中再次调用自己的多态方法createEntry： void createEntry(int hash, K key, V value, int bucketIndex) { HashMapEntry old = table[bucketIndex]; LinkedHashMapEntry e = new LinkedHashMapEntry\u003c\u003e(hash, key, value, old); table[bucketIndex] = e; // 同时指定了after和before e.addBefore(header); size++; } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { // 插入到header之前 after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 创建了一个entry，插入到header与old之间，再把size+1，这样就形成了插入顺序。 get方法 public V get(Object key) { // 先通过key拿到entry LinkedHashMapEntry e = (LinkedHashMapEntry)getEntry(key); // 判空 if (e == null) return null; e.recordAccess(this); return e.value; } // 记录下访问操作 void recordAccess(HashMap m) { LinkedHashMap lm = (LinkedHashMap)m; // 如果是访问排序，就把查到的entry排到首位 if (lm.accessOrder) { lm.modCount++; // 先移除目标entry自身 before.after = after; after.before = before; //插入到header之前 addBefore(lm.header); } } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 首先调用HashMap的getEntry方法，根据key查到entry，然后通过recordAccess方法把查到的entry调整到队首位置，让他最靠前！！！ LinkedHashMap的总结 原理：以HashMap来维护数据结构，以LinkedList来记录插入顺序； 插入和查询处理：以内部entry的addBefore方法提供lru算法，把当前的目标entry排到队首，实现「entry越长时间不操作，插入顺序就越靠后」； 核心容器：父类HashMap中的table三列表，和自己维护的header双向链。 ","date":"2021-09-15","objectID":"/lrucache/:0:1","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#核心构造方法"},{"categories":[],"content":" LinkedHashMap可理解为有序的HashMap。 构造方法 // 队首 private transient LinkedHashMapEntry header; // 排序模式 private final boolean accessOrder; public class LinkedHashMap extends HashMap implements Map { ... } 这货是继承自HashMap的，那么他就有HashMap的所有特性，包括线程不安全和翻倍扩容。 然后来看一下他内部的entry： 入口Entry /** * 继承自HashMap的Entry */ private static class LinkedHashMapEntry extends HashMapEntry { // 内部实现了自己的before和after，成了一个双向链表 LinkedHashMapEntry before, after; ... } 可以看到，他内部的Entry同时具备双向链和单向链(继承了HashMap的entry内部的next字段)结构。 next是用于维护HashMap指定table位置上连接的Entry的顺序的； before、After是用于维护Entry插入的先后顺序的。 核心构造方法 // 排序模式 true-访问排序 false-插入排序 private final boolean accessOrder; public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 与HashMap的主要区别就是多了accessOrder属性，它的作用是选择排序模式： true 访问排序 false 插入排序 这里有个坑要注意的是，调用了父类的构造函数： public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003e MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity \u003c DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } threshold = initialCapacity; // 这个init方法好坑啊 init(); } void init() {} 其中调用了init方法，而HashMap中并没有实现这个方法，说明是专门用来给子类初始化的，于是我去看LinkedHashMap中的重写实现： @Override void init() { header = new LinkedHashMapEntry\u003c\u003e(-1, null, null, null); header.before = header.after = header; } 初始化了队首的entry，并且它的before和after都是它自身。 put方法LinkedHashMap并没有重写put方法，所以他是直接沿用了HashMap的put方法。 来回顾一下HashMap的put方法： public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); // 计算Key的Hash值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //找到key的下标位置 int i = indexFor(hash, table.length); //遍历单向链，插入到对应的hash位置 for (HashMapEntry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //没有对应则插到末尾 modCount++; addEntry(hash, key, value, i); return null; } 这里有一点要注意的是，LinkedHashMap大量运用了多态，所以在添加的时候调用的addEntry方法，实际上是LinkedHashMap已经重写过的： void addEntry(int hash, K key, V value, int bucketIndex) { LinkedHashMapEntry eldest = header.after; // 如果after不是自己 if (eldest != header) { boolean removeEldest; size++; try { removeEldest = removeEldestEntry(eldest); } finally { size--; } if (removeEldest) { removeEntryForKey(eldest.key); } } super.addEntry(hash, key, value, bucketIndex); } 然后又调用父类的addEntry方法，而在其中再次调用自己的多态方法createEntry： void createEntry(int hash, K key, V value, int bucketIndex) { HashMapEntry old = table[bucketIndex]; LinkedHashMapEntry e = new LinkedHashMapEntry\u003c\u003e(hash, key, value, old); table[bucketIndex] = e; // 同时指定了after和before e.addBefore(header); size++; } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { // 插入到header之前 after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 创建了一个entry，插入到header与old之间，再把size+1，这样就形成了插入顺序。 get方法 public V get(Object key) { // 先通过key拿到entry LinkedHashMapEntry e = (LinkedHashMapEntry)getEntry(key); // 判空 if (e == null) return null; e.recordAccess(this); return e.value; } // 记录下访问操作 void recordAccess(HashMap m) { LinkedHashMap lm = (LinkedHashMap)m; // 如果是访问排序，就把查到的entry排到首位 if (lm.accessOrder) { lm.modCount++; // 先移除目标entry自身 before.after = after; after.before = before; //插入到header之前 addBefore(lm.header); } } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 首先调用HashMap的getEntry方法，根据key查到entry，然后通过recordAccess方法把查到的entry调整到队首位置，让他最靠前！！！ LinkedHashMap的总结 原理：以HashMap来维护数据结构，以LinkedList来记录插入顺序； 插入和查询处理：以内部entry的addBefore方法提供lru算法，把当前的目标entry排到队首，实现「entry越长时间不操作，插入顺序就越靠后」； 核心容器：父类HashMap中的table三列表，和自己维护的header双向链。 ","date":"2021-09-15","objectID":"/lrucache/:0:1","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#put方法"},{"categories":[],"content":" LinkedHashMap可理解为有序的HashMap。 构造方法 // 队首 private transient LinkedHashMapEntry header; // 排序模式 private final boolean accessOrder; public class LinkedHashMap extends HashMap implements Map { ... } 这货是继承自HashMap的，那么他就有HashMap的所有特性，包括线程不安全和翻倍扩容。 然后来看一下他内部的entry： 入口Entry /** * 继承自HashMap的Entry */ private static class LinkedHashMapEntry extends HashMapEntry { // 内部实现了自己的before和after，成了一个双向链表 LinkedHashMapEntry before, after; ... } 可以看到，他内部的Entry同时具备双向链和单向链(继承了HashMap的entry内部的next字段)结构。 next是用于维护HashMap指定table位置上连接的Entry的顺序的； before、After是用于维护Entry插入的先后顺序的。 核心构造方法 // 排序模式 true-访问排序 false-插入排序 private final boolean accessOrder; public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 与HashMap的主要区别就是多了accessOrder属性，它的作用是选择排序模式： true 访问排序 false 插入排序 这里有个坑要注意的是，调用了父类的构造函数： public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003e MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity \u003c DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } threshold = initialCapacity; // 这个init方法好坑啊 init(); } void init() {} 其中调用了init方法，而HashMap中并没有实现这个方法，说明是专门用来给子类初始化的，于是我去看LinkedHashMap中的重写实现： @Override void init() { header = new LinkedHashMapEntry\u003c\u003e(-1, null, null, null); header.before = header.after = header; } 初始化了队首的entry，并且它的before和after都是它自身。 put方法LinkedHashMap并没有重写put方法，所以他是直接沿用了HashMap的put方法。 来回顾一下HashMap的put方法： public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); // 计算Key的Hash值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //找到key的下标位置 int i = indexFor(hash, table.length); //遍历单向链，插入到对应的hash位置 for (HashMapEntry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //没有对应则插到末尾 modCount++; addEntry(hash, key, value, i); return null; } 这里有一点要注意的是，LinkedHashMap大量运用了多态，所以在添加的时候调用的addEntry方法，实际上是LinkedHashMap已经重写过的： void addEntry(int hash, K key, V value, int bucketIndex) { LinkedHashMapEntry eldest = header.after; // 如果after不是自己 if (eldest != header) { boolean removeEldest; size++; try { removeEldest = removeEldestEntry(eldest); } finally { size--; } if (removeEldest) { removeEntryForKey(eldest.key); } } super.addEntry(hash, key, value, bucketIndex); } 然后又调用父类的addEntry方法，而在其中再次调用自己的多态方法createEntry： void createEntry(int hash, K key, V value, int bucketIndex) { HashMapEntry old = table[bucketIndex]; LinkedHashMapEntry e = new LinkedHashMapEntry\u003c\u003e(hash, key, value, old); table[bucketIndex] = e; // 同时指定了after和before e.addBefore(header); size++; } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { // 插入到header之前 after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 创建了一个entry，插入到header与old之间，再把size+1，这样就形成了插入顺序。 get方法 public V get(Object key) { // 先通过key拿到entry LinkedHashMapEntry e = (LinkedHashMapEntry)getEntry(key); // 判空 if (e == null) return null; e.recordAccess(this); return e.value; } // 记录下访问操作 void recordAccess(HashMap m) { LinkedHashMap lm = (LinkedHashMap)m; // 如果是访问排序，就把查到的entry排到首位 if (lm.accessOrder) { lm.modCount++; // 先移除目标entry自身 before.after = after; after.before = before; //插入到header之前 addBefore(lm.header); } } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 首先调用HashMap的getEntry方法，根据key查到entry，然后通过recordAccess方法把查到的entry调整到队首位置，让他最靠前！！！ LinkedHashMap的总结 原理：以HashMap来维护数据结构，以LinkedList来记录插入顺序； 插入和查询处理：以内部entry的addBefore方法提供lru算法，把当前的目标entry排到队首，实现「entry越长时间不操作，插入顺序就越靠后」； 核心容器：父类HashMap中的table三列表，和自己维护的header双向链。 ","date":"2021-09-15","objectID":"/lrucache/:0:1","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#get方法"},{"categories":[],"content":" LinkedHashMap可理解为有序的HashMap。 构造方法 // 队首 private transient LinkedHashMapEntry header; // 排序模式 private final boolean accessOrder; public class LinkedHashMap extends HashMap implements Map { ... } 这货是继承自HashMap的，那么他就有HashMap的所有特性，包括线程不安全和翻倍扩容。 然后来看一下他内部的entry： 入口Entry /** * 继承自HashMap的Entry */ private static class LinkedHashMapEntry extends HashMapEntry { // 内部实现了自己的before和after，成了一个双向链表 LinkedHashMapEntry before, after; ... } 可以看到，他内部的Entry同时具备双向链和单向链(继承了HashMap的entry内部的next字段)结构。 next是用于维护HashMap指定table位置上连接的Entry的顺序的； before、After是用于维护Entry插入的先后顺序的。 核心构造方法 // 排序模式 true-访问排序 false-插入排序 private final boolean accessOrder; public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 与HashMap的主要区别就是多了accessOrder属性，它的作用是选择排序模式： true 访问排序 false 插入排序 这里有个坑要注意的是，调用了父类的构造函数： public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003e MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity \u003c DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } threshold = initialCapacity; // 这个init方法好坑啊 init(); } void init() {} 其中调用了init方法，而HashMap中并没有实现这个方法，说明是专门用来给子类初始化的，于是我去看LinkedHashMap中的重写实现： @Override void init() { header = new LinkedHashMapEntry\u003c\u003e(-1, null, null, null); header.before = header.after = header; } 初始化了队首的entry，并且它的before和after都是它自身。 put方法LinkedHashMap并没有重写put方法，所以他是直接沿用了HashMap的put方法。 来回顾一下HashMap的put方法： public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); // 计算Key的Hash值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //找到key的下标位置 int i = indexFor(hash, table.length); //遍历单向链，插入到对应的hash位置 for (HashMapEntry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //没有对应则插到末尾 modCount++; addEntry(hash, key, value, i); return null; } 这里有一点要注意的是，LinkedHashMap大量运用了多态，所以在添加的时候调用的addEntry方法，实际上是LinkedHashMap已经重写过的： void addEntry(int hash, K key, V value, int bucketIndex) { LinkedHashMapEntry eldest = header.after; // 如果after不是自己 if (eldest != header) { boolean removeEldest; size++; try { removeEldest = removeEldestEntry(eldest); } finally { size--; } if (removeEldest) { removeEntryForKey(eldest.key); } } super.addEntry(hash, key, value, bucketIndex); } 然后又调用父类的addEntry方法，而在其中再次调用自己的多态方法createEntry： void createEntry(int hash, K key, V value, int bucketIndex) { HashMapEntry old = table[bucketIndex]; LinkedHashMapEntry e = new LinkedHashMapEntry\u003c\u003e(hash, key, value, old); table[bucketIndex] = e; // 同时指定了after和before e.addBefore(header); size++; } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { // 插入到header之前 after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 创建了一个entry，插入到header与old之间，再把size+1，这样就形成了插入顺序。 get方法 public V get(Object key) { // 先通过key拿到entry LinkedHashMapEntry e = (LinkedHashMapEntry)getEntry(key); // 判空 if (e == null) return null; e.recordAccess(this); return e.value; } // 记录下访问操作 void recordAccess(HashMap m) { LinkedHashMap lm = (LinkedHashMap)m; // 如果是访问排序，就把查到的entry排到首位 if (lm.accessOrder) { lm.modCount++; // 先移除目标entry自身 before.after = after; after.before = before; //插入到header之前 addBefore(lm.header); } } // LRU算法，把当前entry插入到header队首之前，成为新的队首 private void addBefore(LinkedHashMapEntry existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 首先调用HashMap的getEntry方法，根据key查到entry，然后通过recordAccess方法把查到的entry调整到队首位置，让他最靠前！！！ LinkedHashMap的总结 原理：以HashMap来维护数据结构，以LinkedList来记录插入顺序； 插入和查询处理：以内部entry的addBefore方法提供lru算法，把当前的目标entry排到队首，实现「entry越长时间不操作，插入顺序就越靠后」； 核心容器：父类HashMap中的table三列表，和自己维护的header双向链。 ","date":"2021-09-15","objectID":"/lrucache/:0:1","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#linkedhashmap的总结"},{"categories":[],"content":" LruCache的实现 构造方法 private final LinkedHashMap\u003cK, V\u003e map; public LruCache(int maxSize) { if (maxSize \u003c= 0) { throw new IllegalArgumentException(\"maxSize \u003c= 0\"); } this.maxSize = maxSize; this.map = new LinkedHashMap\u003cK, V\u003e(0, 0.75f, true); } 设置了最大容量，并且初始化了一个LinkedHashMap。 put与get方法(基本可不看)put方法： public final V put(K key, V value) { V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); //实际上就是调用LinkedHashMap的put previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } // 回收机制在次 trimToSize(maxSize); return previous; } get方法： public final V get(K key) { V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { // 回收机制在次 trimToSize(maxSize); return createdValue; } } 用来回收的trimToSize方法 public void trimToSize(int maxSize) { // 永动机 while (true) { K key; V value; synchronized (this) { if (size \u003c= maxSize) { break; } // 拿到最老的entry Map.Entry\u003cK, V\u003e toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); // 移除最老的家伙 map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } // 单纯的回调 entryRemoved(true, key, value, null); } } 从linkedHashMap中，循环移除最老的entry，直到当前size小于maxSize。 ","date":"2021-09-15","objectID":"/lrucache/:0:2","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#lrucache的实现"},{"categories":[],"content":" LruCache的实现 构造方法 private final LinkedHashMap map; public LruCache(int maxSize) { if (maxSize \u003c= 0) { throw new IllegalArgumentException(\"maxSize \u003c= 0\"); } this.maxSize = maxSize; this.map = new LinkedHashMap(0, 0.75f, true); } 设置了最大容量，并且初始化了一个LinkedHashMap。 put与get方法(基本可不看)put方法： public final V put(K key, V value) { V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); //实际上就是调用LinkedHashMap的put previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } // 回收机制在次 trimToSize(maxSize); return previous; } get方法： public final V get(K key) { V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { // 回收机制在次 trimToSize(maxSize); return createdValue; } } 用来回收的trimToSize方法 public void trimToSize(int maxSize) { // 永动机 while (true) { K key; V value; synchronized (this) { if (size \u003c= maxSize) { break; } // 拿到最老的entry Map.Entry toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); // 移除最老的家伙 map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } // 单纯的回调 entryRemoved(true, key, value, null); } } 从linkedHashMap中，循环移除最老的entry，直到当前size小于maxSize。 ","date":"2021-09-15","objectID":"/lrucache/:0:2","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#构造方法-1"},{"categories":[],"content":" LruCache的实现 构造方法 private final LinkedHashMap map; public LruCache(int maxSize) { if (maxSize \u003c= 0) { throw new IllegalArgumentException(\"maxSize \u003c= 0\"); } this.maxSize = maxSize; this.map = new LinkedHashMap(0, 0.75f, true); } 设置了最大容量，并且初始化了一个LinkedHashMap。 put与get方法(基本可不看)put方法： public final V put(K key, V value) { V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); //实际上就是调用LinkedHashMap的put previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } // 回收机制在次 trimToSize(maxSize); return previous; } get方法： public final V get(K key) { V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { // 回收机制在次 trimToSize(maxSize); return createdValue; } } 用来回收的trimToSize方法 public void trimToSize(int maxSize) { // 永动机 while (true) { K key; V value; synchronized (this) { if (size \u003c= maxSize) { break; } // 拿到最老的entry Map.Entry toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); // 移除最老的家伙 map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } // 单纯的回调 entryRemoved(true, key, value, null); } } 从linkedHashMap中，循环移除最老的entry，直到当前size小于maxSize。 ","date":"2021-09-15","objectID":"/lrucache/:0:2","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#put与get方法基本可不看"},{"categories":[],"content":" LruCache的实现 构造方法 private final LinkedHashMap map; public LruCache(int maxSize) { if (maxSize \u003c= 0) { throw new IllegalArgumentException(\"maxSize \u003c= 0\"); } this.maxSize = maxSize; this.map = new LinkedHashMap(0, 0.75f, true); } 设置了最大容量，并且初始化了一个LinkedHashMap。 put与get方法(基本可不看)put方法： public final V put(K key, V value) { V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); //实际上就是调用LinkedHashMap的put previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } // 回收机制在次 trimToSize(maxSize); return previous; } get方法： public final V get(K key) { V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { // 回收机制在次 trimToSize(maxSize); return createdValue; } } 用来回收的trimToSize方法 public void trimToSize(int maxSize) { // 永动机 while (true) { K key; V value; synchronized (this) { if (size \u003c= maxSize) { break; } // 拿到最老的entry Map.Entry toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); // 移除最老的家伙 map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } // 单纯的回调 entryRemoved(true, key, value, null); } } 从linkedHashMap中，循环移除最老的entry，直到当前size小于maxSize。 ","date":"2021-09-15","objectID":"/lrucache/:0:2","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#用来回收的trimtosize方法"},{"categories":[],"content":" 总结LruCache的原理内部维护了一个LinkedHashMap，可以设置最大容量，每次put和get时，都会循环移除linkedHashMap的队尾，直到小于maxSize。 ","date":"2021-09-15","objectID":"/lrucache/:0:3","series":[],"tags":[],"title":"LruCache","uri":"/lrucache/#总结lrucache的原理"},{"categories":["第三方框架"],"content":" RealCall中的传值 ... interceptors.add(new BridgeInterceptor(client.cookieJar())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 ","date":"2021-09-07","objectID":"/bridgeinterceptor/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"BridgeInterceptor","uri":"/bridgeinterceptor/#realcall中的传值"},{"categories":["第三方框架"],"content":" 作用这个类的注释如下： Bridges from application code to network code. First it builds a network request from a user request. Then it proceeds to call the network. Finally it builds a user response from the network response. 意思是，在应用程序的code与网络连接的code之间桥接。先通过用户的request创建一个网络request。然后执行网络任务。最后从网络的response创建一个用户的响应response。 翻译完了类注释，再来看代码就很好理解了。 ","date":"2021-09-07","objectID":"/bridgeinterceptor/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"BridgeInterceptor","uri":"/bridgeinterceptor/#作用"},{"categories":["第三方框架"],"content":" BridgeInterceptor的处理过程 public final class BridgeInterceptor implements Interceptor { private final CookieJar cookieJar; public BridgeInterceptor(CookieJar cookieJar) { this.cookieJar = cookieJar; } @Override public Response intercept(Chain chain) throws IOException { //------------------request处理 // 从「拦截器管理器」中拿到所谓的用户request Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); // 各种桥接转换 if (body != null) { MediaType contentType = body.contentType(); if (contentType != null) { requestBuilder.header(\"Content-Type\", contentType.toString()); } long contentLength = body.contentLength(); if (contentLength != -1) { requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); } else { requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); } } if (userRequest.header(\"Host\") == null) { requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false)); } if (userRequest.header(\"Connection\") == null) { requestBuilder.header(\"Connection\", \"Keep-Alive\"); } // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null \u0026\u0026 userRequest.header(\"Range\") == null) { transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); } List\u003cCookie\u003e cookies = cookieJar.loadForRequest(userRequest.url()); // 附加cookie if (!cookies.isEmpty()) { requestBuilder.header(\"Cookie\", cookieHeader(cookies)); } // 附加OkHttp自己的UA if (userRequest.header(\"User-Agent\") == null) { requestBuilder.header(\"User-Agent\", Version.userAgent()); } //------------------response处理 Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip \u0026\u0026 \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) \u0026\u0026 HttpHeaders.hasBody(networkResponse)) { GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(\"Content-Type\"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); } return responseBuilder.build(); } /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */ private String cookieHeader(List\u003cCookie\u003e cookies) { StringBuilder cookieHeader = new StringBuilder(); for (int i = 0, size = cookies.size(); i \u003c size; i++) { if (i \u003e 0) { cookieHeader.append(\"; \"); } Cookie cookie = cookies.get(i); cookieHeader.append(cookie.name()).append('=').append(cookie.value()); } return cookieHeader.toString(); } } ","date":"2021-09-07","objectID":"/bridgeinterceptor/:0:3","series":["okhttp"],"tags":["okhttp"],"title":"BridgeInterceptor","uri":"/bridgeinterceptor/#bridgeinterceptor的处理过程"},{"categories":["第三方框架"],"content":" 总结看完之后，我的感想就是一定不要相信类注释。 这个拦截器确实是类注释描述的那样，把用户的请求转为网络请求，把网络响应转为用户响应，但是： 处理request过程中，附加了cookie和自己的UA； 处理response过程中，为response附加了请求中的url，以便于辨认。 ","date":"2021-09-07","objectID":"/bridgeinterceptor/:0:4","series":["okhttp"],"tags":["okhttp"],"title":"BridgeInterceptor","uri":"/bridgeinterceptor/#总结"},{"categories":["第三方框架"],"content":" RealCall中的传值 ... interceptors.add(new CacheInterceptor(client.internalCache())); ... RealCall在创建这个拦截器的时候只传递了一个cookieJar。 ","date":"2021-09-07","objectID":"/cacheinterceptor/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"CacheInterceptor","uri":"/cacheinterceptor/#realcall中的传值"},{"categories":["第三方框架"],"content":" 作用这个类的注释如下： Serves requests from the cache and writes responses to the cache. 就是从缓存中请求，并把响应写入缓存。 翻译完了类注释，再来看代码就很好理解了。 ","date":"2021-09-07","objectID":"/cacheinterceptor/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"CacheInterceptor","uri":"/cacheinterceptor/#作用"},{"categories":["第三方框架"],"content":" BridgeInterceptor的处理过程 public final class CacheInterceptor implements Interceptor { final InternalCache cache; public CacheInterceptor(InternalCache cache) { this.cache = cache; } @Override public Response intercept(Chain chain) throws IOException { Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) { cache.trackResponse(strategy); } if (cacheCandidate != null \u0026\u0026 cacheResponse == null) { closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. } // 如果没有权限，并且缓存不足，直接返回504 if (networkRequest == null \u0026\u0026 cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } // 如果不需要网络，并且已经缓存过请求，则直接从缓存中读取响应并返回 if (networkRequest == null) { return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); } //-------------response 处理过程 Response networkResponse = null; try { networkResponse = chain.proceed(networkRequest); } finally { if (networkResponse == null \u0026\u0026 cacheCandidate != null) { closeQuietly(cacheCandidate.body()); } } // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) { if (networkResponse.code() == HTTP_NOT_MODIFIED) { Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; } else { closeQuietly(cacheResponse.body()); } } Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) { if (HttpHeaders.hasBody(response) \u0026\u0026 CacheStrategy.isCacheable(response, networkRequest)) { // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); } if (HttpMethod.invalidatesCache(networkRequest.method())) { try { cache.remove(networkRequest); } catch (IOException ignored) { // The cache cannot be written. } } } return response; } private static Response stripBody(Response response) { return response != null \u0026\u0026 response.body() != null ? response.newBuilder().body(null).build() : response; } /** * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we * may never exhaust the source stream and therefore not complete the cached response. */ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response) throws IOException { // Some apps return a null body; for compatibility we treat that like a null cache request. if (cacheRequest == null) return response; Sink cacheBodyUnbuffered = cacheRequest.body(); if (cacheBodyUnbuffered == null) return response; final BufferedSource source = response.body().source(); final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered); Source cacheWritingSource = new Source() { boolean cacheRequestClosed; @Override public long read(Buffer sink, long byteCount) throws IOException { long bytesRead; try { bytesRead = source.read(sink, byteCount); } ca","date":"2021-09-07","objectID":"/cacheinterceptor/:0:3","series":["okhttp"],"tags":["okhttp"],"title":"CacheInterceptor","uri":"/cacheinterceptor/#bridgeinterceptor的处理过程"},{"categories":["第三方框架"],"content":" 缓存DiskLruCache public final class Cache implements Closeable, Flushable { final InternalCache internalCache = new InternalCache() { @Override public Response get(Request request) throws IOException { return Cache.this.get(request); } @Override public CacheRequest put(Response response) throws IOException { return Cache.this.put(response); } @Override public void remove(Request request) throws IOException { Cache.this.remove(request); } @Override public void update(Response cached, Response network) { Cache.this.update(cached, network); } @Override public void trackConditionalCacheHit() { Cache.this.trackConditionalCacheHit(); } @Override public void trackResponse(CacheStrategy cacheStrategy) { Cache.this.trackResponse(cacheStrategy); } }; /// 找到了，就是靠的这玩意 final DiskLruCache cache; DiskLruCache是硬盘缓存，对应的，还有一个LruCache是内存缓存缓存，接下来就需要去学习这两个缓存了。 ","date":"2021-09-07","objectID":"/cacheinterceptor/:0:4","series":["okhttp"],"tags":["okhttp"],"title":"CacheInterceptor","uri":"/cacheinterceptor/#缓存disklrucache"},{"categories":["第三方框架"],"content":" CallServerInterceptor负责实际与server交互（写读），并且完成了报文的封装与解析。 @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; // 用来编码http请求和解码http响应 HttpCodec httpCodec = realChain.httpStream(); // 此时应该为null StreamAllocation streamAllocation = realChain.streamAllocation(); // 此时应该为null RealConnection connection = (RealConnection) realChain.connection(); // 拿到request Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); // 调用状态监听器，并且传递AsyncCall对象 realChain.eventListener().requestHeadersStart(realChain.call()); // 执行写入 httpCodec.writeRequestHeaders(request); // 通知状态 realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; // 如果不是GET或HEAD请求，并且带有请求体 if (HttpMethod.permitsRequestBody(request.method()) \u0026\u0026 request.body() != null) { // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100 // Continue\" response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) { // 写入request完成 httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); // 开始读取response responseBuilder = httpCodec.readResponseHeaders(true); } if (responseBuilder == null) { // Write the request body if the \"Expect: 100-continue\" expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); } // 构建response Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (code == 100) { // server sent a 100-continue even though we did not request one. // try again to read the actual response // 100状态码，用来表示请求被正常接受，需进一步处理，需要客户端继续请求 responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); } realChain.eventListener() .responseHeadersEnd(realChain.call(), response); if (forWebSocket \u0026\u0026 code == 101) { // Connection is upgrading, but we need to ensure interceptors see a non-null response body. // 101状态码表示服务器已收到请求，但是需要客户端切换协议来进一步处理 response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) { streamAllocation.noNewStreams(); } // 204/205状态码表示服务器已成功处理请求，但是不会返回响应体。 if ((code == 204 || code == 205) \u0026\u0026 response.body().contentLength() \u003e 0) { throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); } return response; } ","date":"2021-09-07","objectID":"/callserverinterceptor/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"CallServerInterceptor","uri":"/callserverinterceptor/#callserverinterceptor"},{"categories":["第三方框架"],"content":" ConnectInterceptor 连接拦截器作为第二个实际生效的拦截器，ConnectInterceptor 的代码非常简单。 public final class ConnectInterceptor implements Interceptor { public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) { this.client = client; } @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // request的健康检查，其实就是不允许GET请求，看到这我挺纳闷 boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); // 复用/创建一个流 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); // 建立连接 RealConnection connection = streamAllocation.connection(); // 调用下一个拦截器 return realChain.proceed(request, streamAllocation, httpCodec, connection); } } ConnectInterceptor的作用正如她的命名，是选择并启动连接的。 ","date":"2021-09-07","objectID":"/connectinterceptor/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"ConnectInterceptor与StreamAllocation","uri":"/connectinterceptor/#connectinterceptor-连接拦截器"},{"categories":["第三方框架"],"content":" StreamAllocation 数据流分配器这玩意源码不复杂，是超级复杂😭。 初始化调用 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在RetryAndFollowUpInterceptor拦截时进行初始化的，传递了client的连接池，url，call，和eventListener。 源码 public final class StreamAllocation { // 地址 public final Address address; private RouteSelector.Selection routeSelection; private Route route; private final ConnectionPool connectionPool; public final Call call; public final EventListener eventListener; private final Object callStackTrace; // State guarded by connectionPool. private final RouteSelector routeSelector; private int refusedStreamCount; private RealConnection connection; private boolean reportedAcquired; private boolean released; private boolean canceled; private HttpCodec codec; // 在RetryAndFollowUpInterceptor中调用构造方法初始化 public StreamAllocation(ConnectionPool connectionPool, Address address, Call call, EventListener eventListener, Object callStackTrace) { this.connectionPool = connectionPool; this.address = address; this.call = call; this.eventListener = eventListener; this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener); this.callStackTrace = callStackTrace; } /** * 在ConnectInterceptor中调用 * 创建新的流，返回HttpCodec * 注意⚠️：doExtensiveHealthChecks 如果不是GET请求就是true */ public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) { int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try { // 找到一个健康的连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); // 初始化 HttpCodec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) { codec = resultCodec; return resultCodec; } } catch (IOException e) { throw new RouteException(e); } } /** * 找到一个健康的连接，如果没有就创建个健康的 */ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException { // 注意这个永动机 while (true) { // 从连接池中拿出一个连接 RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); // 所谓「健康」的连接，就是successCount为0 synchronized (connectionPool) { if (candidate.successCount == 0) { return candidate; } } // 如果没有健康的连接，就继续循环去等 if (!candidate.isHealthy(doExtensiveHealthChecks)) { noNewStreams(); continue; } return candidate; } } // 返回一个连接，优先返回连接池中已经存在的，没有则创建 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; //锁加到了连接池上 synchronized (connectionPool) { if (released) throw new IllegalStateException(\"released\"); if (codec != null) throw new IllegalStateException(\"codec != null\"); if (canceled) throw new IOException(\"Canceled\"); // 尝试使用已分配的连接。我们需要小心，因为我们的「已分配」连接可能已被限制创建新流。 releasedConnection = this.connection; // 关闭连接，回收socket toClose = releaseIfNoNewStreams(); // 复用this.connection if (this.connection != null) { result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // If the connection was never reported acquired, don't report it as released! releasedConnection = null; } if (result == null) { // 从连接池中拿出一个连接，这块有点麻烦，我记得Internal.instance是在client中初始化了一个匿名类，回头再看一下去 Inter","date":"2021-09-07","objectID":"/connectinterceptor/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"ConnectInterceptor与StreamAllocation","uri":"/connectinterceptor/#streamallocation-数据流分配器"},{"categories":["第三方框架"],"content":" StreamAllocation 数据流分配器这玩意源码不复杂，是超级复杂😭。 初始化调用 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在RetryAndFollowUpInterceptor拦截时进行初始化的，传递了client的连接池，url，call，和eventListener。 源码 public final class StreamAllocation { // 地址 public final Address address; private RouteSelector.Selection routeSelection; private Route route; private final ConnectionPool connectionPool; public final Call call; public final EventListener eventListener; private final Object callStackTrace; // State guarded by connectionPool. private final RouteSelector routeSelector; private int refusedStreamCount; private RealConnection connection; private boolean reportedAcquired; private boolean released; private boolean canceled; private HttpCodec codec; // 在RetryAndFollowUpInterceptor中调用构造方法初始化 public StreamAllocation(ConnectionPool connectionPool, Address address, Call call, EventListener eventListener, Object callStackTrace) { this.connectionPool = connectionPool; this.address = address; this.call = call; this.eventListener = eventListener; this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener); this.callStackTrace = callStackTrace; } /** * 在ConnectInterceptor中调用 * 创建新的流，返回HttpCodec * 注意⚠️：doExtensiveHealthChecks 如果不是GET请求就是true */ public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) { int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try { // 找到一个健康的连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); // 初始化 HttpCodec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) { codec = resultCodec; return resultCodec; } } catch (IOException e) { throw new RouteException(e); } } /** * 找到一个健康的连接，如果没有就创建个健康的 */ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException { // 注意这个永动机 while (true) { // 从连接池中拿出一个连接 RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); // 所谓「健康」的连接，就是successCount为0 synchronized (connectionPool) { if (candidate.successCount == 0) { return candidate; } } // 如果没有健康的连接，就继续循环去等 if (!candidate.isHealthy(doExtensiveHealthChecks)) { noNewStreams(); continue; } return candidate; } } // 返回一个连接，优先返回连接池中已经存在的，没有则创建 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; //锁加到了连接池上 synchronized (connectionPool) { if (released) throw new IllegalStateException(\"released\"); if (codec != null) throw new IllegalStateException(\"codec != null\"); if (canceled) throw new IOException(\"Canceled\"); // 尝试使用已分配的连接。我们需要小心，因为我们的「已分配」连接可能已被限制创建新流。 releasedConnection = this.connection; // 关闭连接，回收socket toClose = releaseIfNoNewStreams(); // 复用this.connection if (this.connection != null) { result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // If the connection was never reported acquired, don't report it as released! releasedConnection = null; } if (result == null) { // 从连接池中拿出一个连接，这块有点麻烦，我记得Internal.instance是在client中初始化了一个匿名类，回头再看一下去 Inter","date":"2021-09-07","objectID":"/connectinterceptor/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"ConnectInterceptor与StreamAllocation","uri":"/connectinterceptor/#初始化调用"},{"categories":["第三方框架"],"content":" StreamAllocation 数据流分配器这玩意源码不复杂，是超级复杂😭。 初始化调用 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在RetryAndFollowUpInterceptor拦截时进行初始化的，传递了client的连接池，url，call，和eventListener。 源码 public final class StreamAllocation { // 地址 public final Address address; private RouteSelector.Selection routeSelection; private Route route; private final ConnectionPool connectionPool; public final Call call; public final EventListener eventListener; private final Object callStackTrace; // State guarded by connectionPool. private final RouteSelector routeSelector; private int refusedStreamCount; private RealConnection connection; private boolean reportedAcquired; private boolean released; private boolean canceled; private HttpCodec codec; // 在RetryAndFollowUpInterceptor中调用构造方法初始化 public StreamAllocation(ConnectionPool connectionPool, Address address, Call call, EventListener eventListener, Object callStackTrace) { this.connectionPool = connectionPool; this.address = address; this.call = call; this.eventListener = eventListener; this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener); this.callStackTrace = callStackTrace; } /** * 在ConnectInterceptor中调用 * 创建新的流，返回HttpCodec * 注意⚠️：doExtensiveHealthChecks 如果不是GET请求就是true */ public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) { int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try { // 找到一个健康的连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); // 初始化 HttpCodec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) { codec = resultCodec; return resultCodec; } } catch (IOException e) { throw new RouteException(e); } } /** * 找到一个健康的连接，如果没有就创建个健康的 */ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException { // 注意这个永动机 while (true) { // 从连接池中拿出一个连接 RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); // 所谓「健康」的连接，就是successCount为0 synchronized (connectionPool) { if (candidate.successCount == 0) { return candidate; } } // 如果没有健康的连接，就继续循环去等 if (!candidate.isHealthy(doExtensiveHealthChecks)) { noNewStreams(); continue; } return candidate; } } // 返回一个连接，优先返回连接池中已经存在的，没有则创建 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; //锁加到了连接池上 synchronized (connectionPool) { if (released) throw new IllegalStateException(\"released\"); if (codec != null) throw new IllegalStateException(\"codec != null\"); if (canceled) throw new IOException(\"Canceled\"); // 尝试使用已分配的连接。我们需要小心，因为我们的「已分配」连接可能已被限制创建新流。 releasedConnection = this.connection; // 关闭连接，回收socket toClose = releaseIfNoNewStreams(); // 复用this.connection if (this.connection != null) { result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // If the connection was never reported acquired, don't report it as released! releasedConnection = null; } if (result == null) { // 从连接池中拿出一个连接，这块有点麻烦，我记得Internal.instance是在client中初始化了一个匿名类，回头再看一下去 Inter","date":"2021-09-07","objectID":"/connectinterceptor/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"ConnectInterceptor与StreamAllocation","uri":"/connectinterceptor/#源码"},{"categories":[],"content":"quarkus可以从.properties文件中读取配置。 ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:0:0","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#"},{"categories":[],"content":" 定义配置在.properties文件中定义配置： greeting.message = hello greeting.name = quarkus ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:0","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#定义配置"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#配置源"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#system-properties"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#environment-variables"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#env文件"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#applicationconfiguration文件"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#文件位置"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#文件内容"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#多环境配置"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#自定义环境配置"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#父配置"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#属性表达式"},{"categories":[],"content":" 配置源 (400) System properties (300) Environment variables (295) 当前工作目录中的.env文件 (260) Quarkus Application configuration file in $PWD/config/application.properties (250) Quarkus Application configuration file application.properties in classpath (100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath 最终的配置是上面这些源中配置的聚合，quarkus是从低序号到高序号进行merge，序号越高就越靠后加载，包证了系统属性的安全性，也意味着我们可以在高序号源中定义相同的配置来覆盖低序号源中的配置。 System properties系统属性可以在启动期间将配置传递给应用程序，比如： ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass or java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar Environment variables就是系统的环境变量。比如： export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/quarkus-app/quarkus-run.jar .env文件 QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 一般位于根目录中，并且不推荐加入VersionControl中。 ApplicationConfiguration文件 文件位置 一般位于src/main/resources/application.properties中 在测试系统中也可以有单独的配置文件src/test/resources/application.properties 也可以加载jar中的配置 文件内容： // 用户可以自定义配置 greeting.message=hello // 系统扩展也从这里加载配置 quarkus.http.port=9090 多环境配置quarkus默认有三个环境配置： dev 开发时激活（quarkus:dev） test 测试时激活 prod 默认配置 格式：%{profile-name}.config.name eg: quarkus.http.port=9090 %dev.quarkus.http.port=8181 一般情况下，端口号是9090，但是当处于dev环境时则是8181。如果dev环境没有设置值，则将使用默认值。 自定义环境配置 quarkus.http.port=9090 %custom.quarkus.http.port=9999 父配置可以通过quarkus.config.profile.parent设置一个父配置，如果在当前活跃的配置中找不到某个属性，就会去查找父配置： quarkus.profile=dev quarkus.config.profile.parent=common %common.quarkus.http.port=9090 %dev.quarkus.http.ssl-port=9443 quarkus.http.port=8080 quarkus.http.ssl-port=8443 解释：当前采用dev环境，父配置是common，quarkus.http.port会先查找dev环境，发现dev没有设置这一项，再去查找父配置，所以最后实际上会采用父配置的值9090;quarkus.http.ssl-port先去查找dev环境，找到了值9443，就不会再去查找父配置，所以最终值是9443。 属性表达式语法： ${ …​ } 一般使用 ${expression:value} 默认值方式 ${my.prop${compose}} 组合表达式 ${my.prop}${my.prop} 多表达式 ${quarkus.uuid} 生成UUID eg: remote.host=quarkus.io // 可以直接使用上面定义好的属性 callable.url=https://${remote.host}/ 索引属性 my.collection=dog,cat,turtle my.indexed.collection[0]=dog my.indexed.collection[1]=cat my.indexed.collection[2]=turtle ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#索引属性"},{"categories":[],"content":" 自带配置Quarkus自带的配置属性，其中带锁的是构建时配置，无法在运行时修改。 ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:1:2","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#自带配置"},{"categories":[],"content":" 读取配置信息","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:0","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#读取配置信息"},{"categories":[],"content":" 注入方式可以在resource中注入配置信息： @Path(\"/greeting\") public class GreetingResource { @ConfigProperty(name = \"greeting.message\") String message; /** * 默认值 */ @ConfigProperty(name = \"greeting.suffix\", defaultValue = \"!\") String suffix; /** * 可选方式，可以避免空指针 */ @ConfigProperty(name = \"greeting.name\") Optional\u003cString\u003e name; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return message + \" \" + name.orElse(\"world\") + suffix; } } ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#注入方式"},{"categories":[],"content":" 获取方式 @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { String message = ConfigProvider.getConfig().getValue(\"greeting.message\", String.class); Optional\u003cString\u003e name = ConfigProvider.getConfig().getOptionalValue(\"greeting.name\", String.class); return message + \" \" + name.get(); } ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:2","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#获取方式"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter\u003cString\u003e { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set\u003cEnvironment\u003e environments(); interface Environment { String name(); List\u003cApp\u003e apps(); interface App { String name(); List\u003cString\u003e services(); Optional\u003cList\u003cString\u003e\u003e databases(); } } } 映射Map配置： server.host=localhost server.port=8080 server.form.login-page=login.html server.form.error-page=error.html server.form.landing-page=index.html 映射： @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Map\u003cString, String\u003e form(); } 默认值 public interface Defaults { @WithDefault(\"foo\") String foo(); @WithDefault(\"bar\") String bar(); } 验证配置 @ConfigMapping(prefix = \"server\") interface Server { @Size(min = 2, max = 20) String host(); @Max(10000) int port(); } 需要quarkus-hibernate-validator扩展。 ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#装箱方式"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#嵌套方式"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#覆盖属性名"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#withname"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#withparent"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#驼峰命名策略"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#映射方法"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#映射集合"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#映射map"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#默认值"},{"categories":[],"content":" 装箱方式假设有配置： greeting.message = hello greeting.name = quarkus 我们可以使用@ConfigMapping把所有同一前缀的属性装箱成一个接口： // 支持逗号分隔多个 @ConfigMapping(prefix = \"greeting\") public interface Greeting { // 命名必须与属性一致 String name(); String message(); } 然后在调用时就可以直接注入实现类： @Path(\"/greeting\") public class GreetingResource { @Inject Greeting greeting; @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return greeting.message() + greeting.name(); } } 嵌套方式 @ConfigMapping(prefix = \"server\") public interface Server { String host(); int port(); Log log(); interface Log { boolean enabled(); String suffix(); boolean rotate(); } } 覆盖属性名 @WithName当我们的方法命名与配置文件中的属性名称不一致时，可以使用@WithName注解标明： 配置： server.name=localhost server.port=8080 映射： @ConfigMapping(prefix = \"server\") interface Server { @WithName(\"name\") String host(); int port(); } @WithParent组合方式。 server.host=localhost server.port=8080 server.name=konoha interface Server { @WithParentName ServerHostAndPort hostAndPort(); @WithParentName ServerInfo info(); } interface ServerHostAndPort { String host(); int port(); } interface ServerInfo { String name(); } 驼峰命名策略 server.the-host=localhost server.the-port=8080 用-来分隔单词，然后就可以使用驼峰方式命名的方法来映射： @ConfigMapping(prefix = \"server\") interface Server { String theHost(); int thePort(); } 映射方法配置： foo=foo 映射： @ConfigMapping public interface Converters { @WithConverter(FooBarConverter.class) String foo(); } public static class FooBarConverter implements Converter { @Override public String convert(final String value) { return \"bar\"; } } 当我们使用 foo()方法时，它并不会输出foo，而是输出bar。 映射集合配置： server.environments[0].name=dev server.environments[0].apps[0].name=rest server.environments[0].apps[0].services=bookstore,registration server.environments[0].apps[0].databases=pg,h2 server.environments[0].apps[1].name=batch server.environments[0].apps[1].services=stock,warehous 映射： @ConfigMapping(prefix = \"server\") public interface ServerCollections { Set environments(); interface Environment { String name(); List apps(); interface App { String name(); List services(); Optional","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:2:3","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#验证配置"},{"categories":[],"content":" 扩展配置一般情况下，我们在实际的工作中可能不止dev、test、prod三种环境，可能还需要更多的配置。 ","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:3:0","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#扩展配置"},{"categories":[],"content":" 自定义配置源 扩展ConfigSource package org.acme.config; public class InMemoryConfigSource implements ConfigSource { /** * 内存缓存 */ private static final Map\u003cString, String\u003e configuration = new HashMap\u003c\u003e(); static { configuration.put(\"my.prop\", \"1234\"); } /** * 定义加载序号 */ @Override public int getOrdinal() { return 275; } @Override public Set\u003cString\u003e getPropertyNames() { return configuration.keySet(); } @Override public String getValue(final String propertyName) { return configuration.get(propertyName); } /** * 返回该配置的名称 */ @Override public String getName() { return InMemoryConfigSource.class.getSimpleName(); } } 注册配置源接下来在META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource注册配置： org.acme.config.InMemoryConfigSource 初始化配置源当 Quarkus 应用程序启动时，可以初始化两次。一次用于静态初始化，第二次用于运行时初始化 静态初始化","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:3:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#自定义配置源"},{"categories":[],"content":" 自定义配置源 扩展ConfigSource package org.acme.config; public class InMemoryConfigSource implements ConfigSource { /** * 内存缓存 */ private static final Map configuration = new HashMap\u003c\u003e(); static { configuration.put(\"my.prop\", \"1234\"); } /** * 定义加载序号 */ @Override public int getOrdinal() { return 275; } @Override public Set getPropertyNames() { return configuration.keySet(); } @Override public String getValue(final String propertyName) { return configuration.get(propertyName); } /** * 返回该配置的名称 */ @Override public String getName() { return InMemoryConfigSource.class.getSimpleName(); } } 注册配置源接下来在META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource注册配置： org.acme.config.InMemoryConfigSource 初始化配置源当 Quarkus 应用程序启动时，可以初始化两次。一次用于静态初始化，第二次用于运行时初始化 静态初始化","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:3:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#扩展configsource"},{"categories":[],"content":" 自定义配置源 扩展ConfigSource package org.acme.config; public class InMemoryConfigSource implements ConfigSource { /** * 内存缓存 */ private static final Map configuration = new HashMap\u003c\u003e(); static { configuration.put(\"my.prop\", \"1234\"); } /** * 定义加载序号 */ @Override public int getOrdinal() { return 275; } @Override public Set getPropertyNames() { return configuration.keySet(); } @Override public String getValue(final String propertyName) { return configuration.get(propertyName); } /** * 返回该配置的名称 */ @Override public String getName() { return InMemoryConfigSource.class.getSimpleName(); } } 注册配置源接下来在META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource注册配置： org.acme.config.InMemoryConfigSource 初始化配置源当 Quarkus 应用程序启动时，可以初始化两次。一次用于静态初始化，第二次用于运行时初始化 静态初始化","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:3:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#注册配置源"},{"categories":[],"content":" 自定义配置源 扩展ConfigSource package org.acme.config; public class InMemoryConfigSource implements ConfigSource { /** * 内存缓存 */ private static final Map configuration = new HashMap\u003c\u003e(); static { configuration.put(\"my.prop\", \"1234\"); } /** * 定义加载序号 */ @Override public int getOrdinal() { return 275; } @Override public Set getPropertyNames() { return configuration.keySet(); } @Override public String getValue(final String propertyName) { return configuration.get(propertyName); } /** * 返回该配置的名称 */ @Override public String getName() { return InMemoryConfigSource.class.getSimpleName(); } } 注册配置源接下来在META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource注册配置： org.acme.config.InMemoryConfigSource 初始化配置源当 Quarkus 应用程序启动时，可以初始化两次。一次用于静态初始化，第二次用于运行时初始化 静态初始化","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:3:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#初始化配置源"},{"categories":[],"content":" 自定义配置源 扩展ConfigSource package org.acme.config; public class InMemoryConfigSource implements ConfigSource { /** * 内存缓存 */ private static final Map configuration = new HashMap\u003c\u003e(); static { configuration.put(\"my.prop\", \"1234\"); } /** * 定义加载序号 */ @Override public int getOrdinal() { return 275; } @Override public Set getPropertyNames() { return configuration.keySet(); } @Override public String getValue(final String propertyName) { return configuration.get(propertyName); } /** * 返回该配置的名称 */ @Override public String getName() { return InMemoryConfigSource.class.getSimpleName(); } } 注册配置源接下来在META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource注册配置： org.acme.config.InMemoryConfigSource 初始化配置源当 Quarkus 应用程序启动时，可以初始化两次。一次用于静态初始化，第二次用于运行时初始化 静态初始化","date":"2021-09-07","objectID":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/:3:1","series":["Quarkus"],"tags":[],"title":"Quarkus读取配置","uri":"/quarkus%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/#静态初始化"},{"categories":["第三方框架"],"content":" RealCall中的传值 private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } RealCall初始化时，会创建这个RetryAndFollowUpInterceptor拦截器，并且传递了OkHttpClient。 观察RealCall中的所有默认拦截器，RealCall对于这个拦截器的处理优先级是最高的，甚至在构造方法中就初始化了，而且在众多内置拦截器中，RealCall单只给RetryAndFollowUpInterceptor传递了OkhttpClient，可见这个拦截器的重要性！ ","date":"2021-09-07","objectID":"/retryandfollowupinterceptor/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"RetryAndFollowUpInterceptor","uri":"/retryandfollowupinterceptor/#realcall中的传值"},{"categories":["第三方框架"],"content":" RetryAndFollowUpInterceptor的处理过程 public final class RetryAndFollowUpInterceptor implements Interceptor { private static final int MAX_FOLLOW_UPS = 20; private final OkHttpClient client; private final boolean forWebSocket; private volatile StreamAllocation streamAllocation; private Object callStackTrace; private volatile boolean canceled; public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) { this.client = client; this.forWebSocket = forWebSocket; } // 取消，不需要看了 public void cancel() { canceled = true; StreamAllocation streamAllocation = this.streamAllocation; if (streamAllocation != null) streamAllocation.cancel(); } @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; // 重定向次数 int followUpCount = 0; // 前一个response Response priorResponse = null; // 又是个永动机 while (true) { Response response; boolean releaseConnection = true; try { // 调用下一个拦截器，最终获取到response response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; } catch (RouteException e) { //发现异常就重试 if (!recover(e.getLastConnectException(), streamAllocation, false, request)) { throw e.getLastConnectException(); } releaseConnection = false; continue; } catch (IOException e) { //发现异常就重试 ... continue; } finally { // 释放连接 if (releaseConnection) { streamAllocation.streamFailed(null); streamAllocation.release(); } } // 附加前一个response，这种都是没有body if (priorResponse != null) { response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null)//没有body .build()) .build(); } // 根据上一个response，生成重定向需要的request Request followUp = followUpRequest(response, streamAllocation.route()); // 如果不再需要重定向，就直接返回response了 if (followUp == null) { if (!forWebSocket) { streamAllocation.release(); } return response; } // 关闭 response的body closeQuietly(response.body()); // 如果重定向/重试次数大于20次就会报错 if (++followUpCount \u003e MAX_FOLLOW_UPS) { streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); } ... // 如果不是同一个主机地址，则连接不能复用，只能释放上一个，并且新建一个连接；否则将复用之前创建好的连接 if (!sameConnection(response, followUp.url())) { // 用request重建连接 streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; } request = followUp; priorResponse = response; } } // 拼装地址，包含主机、端口号、DNS等等 private Address createAddress(HttpUrl url) { SSLSocketFactory sslSocketFactory = null; HostnameVerifier hostnameVerifier = null; CertificatePinner certificatePinner = null; // 判断是否https if (url.isHttps()) { sslSocketFactory = client.sslSocketFactory(); hostnameVerifier = client.hostnameVerifier(); certificatePinner = client.certificatePinner(); } return new Address(url.host(), url.port(), client.dns(), client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(), client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector()); } // 尝试从与服务器通信失败中恢复（重试） private boolean recover(IOException e, StreamAllocation streamAllocation, boolean requestSendStarted, Request userRequest) { streamAllocation.streamFailed(e); // 重试 // return false - 应用层拒绝了重试,这是我们在初始化client时设置的 if (!client.retryOnConnectionFailure()) return false; ... // 如果有更多的路由，比如DNS返回了多个CDN的ip地址，就切换线路重试，否则取消。 if (!streamAllocation.hasMoreRoutes()) return false; ... return true; } // 判断连接是否可以恢复 private boolean isRecoverable(IOException e, boolean requestSendStarted) { ... } // 根据responseCode判断，如果response需要重定向，则创建一个重定向所需的request private Request followUpRequest(Response userResponse, Route rout","date":"2021-09-07","objectID":"/retryandfollowupinterceptor/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"RetryAndFollowUpInterceptor","uri":"/retryandfollowupinterceptor/#retryandfollowupinterceptor的处理过程"},{"categories":["第三方框架"],"content":" 总结RetryAndFollowUpInterceptor的职责： 提供了异常重试功能； 提供固定不超过20次重定向功能； 提供「取消请求」功能。 本来根据单一原则，不应该把三个功能耦合到一个拦截器，但是为什么JW大神还是如此来设计呢？ 而且我还有个疑问就是，重试次数竟然是固定不超过20次，不能由我们自己来设置。 ","date":"2021-09-07","objectID":"/retryandfollowupinterceptor/:0:3","series":["okhttp"],"tags":["okhttp"],"title":"RetryAndFollowUpInterceptor","uri":"/retryandfollowupinterceptor/#总结"},{"categories":["第三方框架"],"content":" 解决不能自定义重试次数的问题 方式一：自定义重试拦截器首先关闭OkHttp自带的重试机制 OkHttpClient.Builder() .retryOnConnectionFailure(false) .build() 然后自定义一个重试拦截器，如下： public class RetryIntercepter implements Interceptor { public int maxRetry;//最大重试次数 private int retryNum = 0;//假如设置为3次重试的话，则最大可能请求4次（默认1次+3次重试） public RetryIntercepter(int maxRetry) { this.maxRetry = maxRetry; } @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); System.out.println(\"retryNum=\" + retryNum); Response response = chain.proceed(request); while (!response.isSuccessful() \u0026\u0026 retryNum \u003c maxRetry) { retryNum++; System.out.println(\"retryNum=\" + retryNum); response = chain.proceed(request); } return response; } } 上面是我从网上找到的例子，其实他写的并不好，但是可以作为一个思路。 方式二 RxJava的retryWhen操作符","date":"2021-09-07","objectID":"/retryandfollowupinterceptor/:0:4","series":["okhttp"],"tags":["okhttp"],"title":"RetryAndFollowUpInterceptor","uri":"/retryandfollowupinterceptor/#解决不能自定义重试次数的问题"},{"categories":["第三方框架"],"content":" 解决不能自定义重试次数的问题 方式一：自定义重试拦截器首先关闭OkHttp自带的重试机制 OkHttpClient.Builder() .retryOnConnectionFailure(false) .build() 然后自定义一个重试拦截器，如下： public class RetryIntercepter implements Interceptor { public int maxRetry;//最大重试次数 private int retryNum = 0;//假如设置为3次重试的话，则最大可能请求4次（默认1次+3次重试） public RetryIntercepter(int maxRetry) { this.maxRetry = maxRetry; } @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); System.out.println(\"retryNum=\" + retryNum); Response response = chain.proceed(request); while (!response.isSuccessful() \u0026\u0026 retryNum \u003c maxRetry) { retryNum++; System.out.println(\"retryNum=\" + retryNum); response = chain.proceed(request); } return response; } } 上面是我从网上找到的例子，其实他写的并不好，但是可以作为一个思路。 方式二 RxJava的retryWhen操作符","date":"2021-09-07","objectID":"/retryandfollowupinterceptor/:0:4","series":["okhttp"],"tags":["okhttp"],"title":"RetryAndFollowUpInterceptor","uri":"/retryandfollowupinterceptor/#方式一自定义重试拦截器"},{"categories":["第三方框架"],"content":" 解决不能自定义重试次数的问题 方式一：自定义重试拦截器首先关闭OkHttp自带的重试机制 OkHttpClient.Builder() .retryOnConnectionFailure(false) .build() 然后自定义一个重试拦截器，如下： public class RetryIntercepter implements Interceptor { public int maxRetry;//最大重试次数 private int retryNum = 0;//假如设置为3次重试的话，则最大可能请求4次（默认1次+3次重试） public RetryIntercepter(int maxRetry) { this.maxRetry = maxRetry; } @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); System.out.println(\"retryNum=\" + retryNum); Response response = chain.proceed(request); while (!response.isSuccessful() \u0026\u0026 retryNum \u003c maxRetry) { retryNum++; System.out.println(\"retryNum=\" + retryNum); response = chain.proceed(request); } return response; } } 上面是我从网上找到的例子，其实他写的并不好，但是可以作为一个思路。 方式二 RxJava的retryWhen操作符","date":"2021-09-07","objectID":"/retryandfollowupinterceptor/:0:4","series":["okhttp"],"tags":["okhttp"],"title":"RetryAndFollowUpInterceptor","uri":"/retryandfollowupinterceptor/#方式二-rxjava的retrywhen操作符"},{"categories":["第三方框架"],"content":" 初始化调用 public final class RetryAndFollowUpInterceptor implements Interceptor { ... @Override public Response intercept(Chain chain) throws IOException { ... // 初始化数据流分配器 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),createAddress(request.url()), call, eventListener, callStackTrace); StreamAllocation是在RetryAndFollowUpInterceptor拦截时进行初始化的，传递了client的连接池，url，call，和eventListener。 ","date":"2021-09-07","objectID":"/streamallocation/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"StreamAllocation","uri":"/streamallocation/#初始化调用"},{"categories":["第三方框架"],"content":" 源码 public final class StreamAllocation { // 地址 public final Address address; private RouteSelector.Selection routeSelection; private Route route; private final ConnectionPool connectionPool; public final Call call; public final EventListener eventListener; private final Object callStackTrace; // State guarded by connectionPool. private final RouteSelector routeSelector; private int refusedStreamCount; private RealConnection connection; private boolean reportedAcquired; private boolean released; private boolean canceled; private HttpCodec codec; public StreamAllocation(ConnectionPool connectionPool, Address address, Call call, EventListener eventListener, Object callStackTrace) { this.connectionPool = connectionPool; this.address = address; this.call = call; this.eventListener = eventListener; this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener); this.callStackTrace = callStackTrace; } /** * 找到健康的连接，创建HttpCodec并返回 */ public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) { int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try { // 找到一个健康的连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); // 初始化 HttpCodec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) { codec = resultCodec; return resultCodec; } } catch (IOException e) { throw new RouteException(e); } } /** * 找到一个健康的连接，如果没有就创建个健康的 */ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException { // 注意这个死循环 while (true) { RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); synchronized (connectionPool) { if (candidate.successCount == 0) { return candidate; } } // Do a (potentially slow) check to confirm that the pooled connection is still good. If it // isn't, take it out of the pool and start again. // 如果没有健康的连接，就继续循环去等 if (!candidate.isHealthy(doExtensiveHealthChecks)) { noNewStreams(); continue; } return candidate; } } /** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. */ /** * 找到一个健康的连接，如果没有就创建个健康的 */ private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; //锁加到了连接池上 synchronized (connectionPool) { if (released) throw new IllegalStateException(\"released\"); if (codec != null) throw new IllegalStateException(\"codec != null\"); if (canceled) throw new IOException(\"Canceled\"); // Attempt to use an already-allocated connection. We need to be careful here because our // already-allocated connection may have been restricted from creating new streams. releasedConnection = this.connection; // 关闭连接，回收socket toClose = releaseIfNoNewStreams(); // 复用this.connection if (this.connection != null) { result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // If the connection was never reported acquired, don't report it as released! releasedConnection = null; } if (result == null) { // 从连接池中拿出一个连接 Internal.instance.get(connectionPool, address, this, null); if (connection != null) { foundPooledConnection = true; result = connection; } else { selectedRoute = route; } } } // 关闭Socket closeQuietly(toClose); if (releasedConnection != n","date":"2021-09-07","objectID":"/streamallocation/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"StreamAllocation","uri":"/streamallocation/#源码"},{"categories":["第三方框架"],"content":"回顾并且深入一下OkHttp（v3.10.0）的原理。 ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:0","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#"},{"categories":["第三方框架"],"content":" 用法 val client = OkHttpClient.Builder().build(); val request = Request.Builder() .url(\"https://wanandroid.com/wxarticle/chapters/json\") .get() .build() client.newCall(request).enqueue(responseCallback = object : Callback { override fun onFailure(call: Call, e: IOException) { val i = 0; } override fun onResponse(call: Call, response: Response) { val i = 0; } }) ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:1","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#用法"},{"categories":["第三方框架"],"content":" 构建OkHttpClient构造方法其实就是调用了建造者模式。 public Builder() { // 执行策略，同步or异步 dispatcher = new Dispatcher(); // 协议 protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; // 事件监听器 eventListenerFactory = EventListener.factory(EventListener.NONE); // 代理 proxySelector = ProxySelector.getDefault(); // cookie cookieJar = CookieJar.NO_COOKIES; // 套接字工厂 socketFactory = SocketFactory.getDefault(); // 域名验证 hostnameVerifier = OkHostnameVerifier.INSTANCE; // 证书 certificatePinner = CertificatePinner.DEFAULT; // 代理认证 proxyAuthenticator = Authenticator.NONE; // 用户身份认证 authenticator = Authenticator.NONE; // 初始化链接池 connectionPool = new ConnectionPool(); // DNS dns = Dns.SYSTEM; // followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; } OkHttpClient主要作用就是对网络请求进行配置。 Dispatcher 任务分发器，同步与异步有不同的分发机制 public final class Dispatcher { private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; // 线程池 private @Nullable ExecutorService executorService; // 准备队列，缓存了即将被执行的异步call private final Deque\u003cAsyncCall\u003e readyAsyncCalls = new ArrayDeque\u003c\u003e(); // 异步运行队列，缓存正在运行中，或者已经取消但是还没结束的call private final Deque\u003cAsyncCall\u003e runningAsyncCalls = new ArrayDeque\u003c\u003e(); // 同步运行队列 private final Deque\u003cRealCall\u003e runningSyncCalls = new ArrayDeque\u003c\u003e(); // 构造方法 public Dispatcher(ExecutorService executorService) { this.executorService = executorService; } public Dispatcher() { } // 默认的线程池 // 核心线程为0， // 最大线程数为无限大 // 保活时间为60秒 // public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e(), Util.threadFactory(\"OkHttp Dispatcher\", false)); } return executorService; } // 设置最大「并发」请求数 public synchronized void setMaxRequests(int maxRequests) { if (maxRequests \u003c 1) { throw new IllegalArgumentException(\"max \u003c 1: \" + maxRequests); } this.maxRequests = maxRequests; promoteCalls(); } public synchronized int getMaxRequests() { return maxRequests; } // 设置每个host的最大并发请求数 public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) { if (maxRequestsPerHost \u003c 1) { throw new IllegalArgumentException(\"max \u003c 1: \" + maxRequestsPerHost); } this.maxRequestsPerHost = maxRequestsPerHost; promoteCalls(); } public synchronized int getMaxRequestsPerHost() { return maxRequestsPerHost; } // 闲置时回调 // 当没有运行中的call时 // 同步与异步call 有不同的闲时判定 public synchronized void setIdleCallback(@Nullable Runnable idleCallback) { this.idleCallback = idleCallback; } // 同步执行 synchronized void executed(RealCall call) { // 添加进队列 runningSyncCalls.add(call); } // 异步执行 synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() \u003c maxRequests \u0026\u0026 runningCallsForHost(call) \u003c maxRequestsPerHost) { // 添加队列 runningAsyncCalls.add(call); // 线程池执行 executorService().execute(call); } else { readyAsyncCalls.add(call); } } } Dispatcher是策略执行器，核心是三条队列： // 准备队列，缓存了即将被执行的异步call private final Deque\u003cAsyncCall\u003e readyAsyncCalls = new ArrayDeque\u003c\u003e(); // 异步运行队列，缓存正在运行中，或者已经取消但是还没结束的call private final Deque\u003cAsyncCall\u003e runningAsyncCalls = new ArrayDeque\u003c\u003e(); // 同步运行队列 private final Deque\u003cRealCall\u003e runningSyncCalls = new ArrayDeque\u003c\u003e(); 同步：直接将call添加进了同步队列。 异步：判断当前运行中的请求数是否峰值，如果已经达到最大数，则将call放入等待队列；否则放入异步运行中队列，并且让线程池立即执行。 这里使用了ArrayDeque这个类，ArrayDeque是Java集合中双端队列的数组实现，相似的还有双端队列的链表实现（LinkedList）。它作为栈使用时比 Stack 类效率要高，作为队列使用时比LinkedList要快。 协议 Protocol public enum Protocol { // http 1.0 HTTP_1_0(\"http/1.0\"), // http1.1 HTTP_1_1(\"http/1.1\"), // 不认识这个 SPDY_3(\"spdy/3.1\"), // http2.0 HTTP_2(\"h2\"), // Http3.0,谷歌基于udp实现的quic协议，解决了头部阻塞和弱网环境下网络稳定问题 QUIC(\"quic\"); } ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#构建okhttpclient"},{"categories":["第三方框架"],"content":" 构建OkHttpClient构造方法其实就是调用了建造者模式。 public Builder() { // 执行策略，同步or异步 dispatcher = new Dispatcher(); // 协议 protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; // 事件监听器 eventListenerFactory = EventListener.factory(EventListener.NONE); // 代理 proxySelector = ProxySelector.getDefault(); // cookie cookieJar = CookieJar.NO_COOKIES; // 套接字工厂 socketFactory = SocketFactory.getDefault(); // 域名验证 hostnameVerifier = OkHostnameVerifier.INSTANCE; // 证书 certificatePinner = CertificatePinner.DEFAULT; // 代理认证 proxyAuthenticator = Authenticator.NONE; // 用户身份认证 authenticator = Authenticator.NONE; // 初始化链接池 connectionPool = new ConnectionPool(); // DNS dns = Dns.SYSTEM; // followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; } OkHttpClient主要作用就是对网络请求进行配置。 Dispatcher 任务分发器，同步与异步有不同的分发机制 public final class Dispatcher { private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; // 线程池 private @Nullable ExecutorService executorService; // 准备队列，缓存了即将被执行的异步call private final Deque readyAsyncCalls = new ArrayDeque\u003c\u003e(); // 异步运行队列，缓存正在运行中，或者已经取消但是还没结束的call private final Deque runningAsyncCalls = new ArrayDeque\u003c\u003e(); // 同步运行队列 private final Deque runningSyncCalls = new ArrayDeque\u003c\u003e(); // 构造方法 public Dispatcher(ExecutorService executorService) { this.executorService = executorService; } public Dispatcher() { } // 默认的线程池 // 核心线程为0， // 最大线程数为无限大 // 保活时间为60秒 // public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(\"OkHttp Dispatcher\", false)); } return executorService; } // 设置最大「并发」请求数 public synchronized void setMaxRequests(int maxRequests) { if (maxRequests \u003c 1) { throw new IllegalArgumentException(\"max \u003c 1: \" + maxRequests); } this.maxRequests = maxRequests; promoteCalls(); } public synchronized int getMaxRequests() { return maxRequests; } // 设置每个host的最大并发请求数 public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) { if (maxRequestsPerHost \u003c 1) { throw new IllegalArgumentException(\"max \u003c 1: \" + maxRequestsPerHost); } this.maxRequestsPerHost = maxRequestsPerHost; promoteCalls(); } public synchronized int getMaxRequestsPerHost() { return maxRequestsPerHost; } // 闲置时回调 // 当没有运行中的call时 // 同步与异步call 有不同的闲时判定 public synchronized void setIdleCallback(@Nullable Runnable idleCallback) { this.idleCallback = idleCallback; } // 同步执行 synchronized void executed(RealCall call) { // 添加进队列 runningSyncCalls.add(call); } // 异步执行 synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() \u003c maxRequests \u0026\u0026 runningCallsForHost(call) \u003c maxRequestsPerHost) { // 添加队列 runningAsyncCalls.add(call); // 线程池执行 executorService().execute(call); } else { readyAsyncCalls.add(call); } } } Dispatcher是策略执行器，核心是三条队列： // 准备队列，缓存了即将被执行的异步call private final Deque readyAsyncCalls = new ArrayDeque\u003c\u003e(); // 异步运行队列，缓存正在运行中，或者已经取消但是还没结束的call private final Deque runningAsyncCalls = new ArrayDeque\u003c\u003e(); // 同步运行队列 private final Deque runningSyncCalls = new ArrayDeque\u003c\u003e(); 同步：直接将call添加进了同步队列。 异步：判断当前运行中的请求数是否峰值，如果已经达到最大数，则将call放入等待队列；否则放入异步运行中队列，并且让线程池立即执行。 这里使用了ArrayDeque这个类，ArrayDeque是Java集合中双端队列的数组实现，相似的还有双端队列的链表实现（LinkedList）。它作为栈使用时比 Stack 类效率要高，作为队列使用时比LinkedList要快。 协议 Protocol public enum Protocol { // http 1.0 HTTP_1_0(\"http/1.0\"), // http1.1 HTTP_1_1(\"http/1.1\"), // 不认识这个 SPDY_3(\"spdy/3.1\"), // http2.0 HTTP_2(\"h2\"), // Http3.0,谷歌基于udp实现的quic协议，解决了头部阻塞和弱网环境下网络稳定问题 QUIC(\"quic\"); } ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#dispatcher-任务分发器同步与异步有不同的分发机制"},{"categories":["第三方框架"],"content":" 构建OkHttpClient构造方法其实就是调用了建造者模式。 public Builder() { // 执行策略，同步or异步 dispatcher = new Dispatcher(); // 协议 protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; // 事件监听器 eventListenerFactory = EventListener.factory(EventListener.NONE); // 代理 proxySelector = ProxySelector.getDefault(); // cookie cookieJar = CookieJar.NO_COOKIES; // 套接字工厂 socketFactory = SocketFactory.getDefault(); // 域名验证 hostnameVerifier = OkHostnameVerifier.INSTANCE; // 证书 certificatePinner = CertificatePinner.DEFAULT; // 代理认证 proxyAuthenticator = Authenticator.NONE; // 用户身份认证 authenticator = Authenticator.NONE; // 初始化链接池 connectionPool = new ConnectionPool(); // DNS dns = Dns.SYSTEM; // followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; } OkHttpClient主要作用就是对网络请求进行配置。 Dispatcher 任务分发器，同步与异步有不同的分发机制 public final class Dispatcher { private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; // 线程池 private @Nullable ExecutorService executorService; // 准备队列，缓存了即将被执行的异步call private final Deque readyAsyncCalls = new ArrayDeque\u003c\u003e(); // 异步运行队列，缓存正在运行中，或者已经取消但是还没结束的call private final Deque runningAsyncCalls = new ArrayDeque\u003c\u003e(); // 同步运行队列 private final Deque runningSyncCalls = new ArrayDeque\u003c\u003e(); // 构造方法 public Dispatcher(ExecutorService executorService) { this.executorService = executorService; } public Dispatcher() { } // 默认的线程池 // 核心线程为0， // 最大线程数为无限大 // 保活时间为60秒 // public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(\"OkHttp Dispatcher\", false)); } return executorService; } // 设置最大「并发」请求数 public synchronized void setMaxRequests(int maxRequests) { if (maxRequests \u003c 1) { throw new IllegalArgumentException(\"max \u003c 1: \" + maxRequests); } this.maxRequests = maxRequests; promoteCalls(); } public synchronized int getMaxRequests() { return maxRequests; } // 设置每个host的最大并发请求数 public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) { if (maxRequestsPerHost \u003c 1) { throw new IllegalArgumentException(\"max \u003c 1: \" + maxRequestsPerHost); } this.maxRequestsPerHost = maxRequestsPerHost; promoteCalls(); } public synchronized int getMaxRequestsPerHost() { return maxRequestsPerHost; } // 闲置时回调 // 当没有运行中的call时 // 同步与异步call 有不同的闲时判定 public synchronized void setIdleCallback(@Nullable Runnable idleCallback) { this.idleCallback = idleCallback; } // 同步执行 synchronized void executed(RealCall call) { // 添加进队列 runningSyncCalls.add(call); } // 异步执行 synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() \u003c maxRequests \u0026\u0026 runningCallsForHost(call) \u003c maxRequestsPerHost) { // 添加队列 runningAsyncCalls.add(call); // 线程池执行 executorService().execute(call); } else { readyAsyncCalls.add(call); } } } Dispatcher是策略执行器，核心是三条队列： // 准备队列，缓存了即将被执行的异步call private final Deque readyAsyncCalls = new ArrayDeque\u003c\u003e(); // 异步运行队列，缓存正在运行中，或者已经取消但是还没结束的call private final Deque runningAsyncCalls = new ArrayDeque\u003c\u003e(); // 同步运行队列 private final Deque runningSyncCalls = new ArrayDeque\u003c\u003e(); 同步：直接将call添加进了同步队列。 异步：判断当前运行中的请求数是否峰值，如果已经达到最大数，则将call放入等待队列；否则放入异步运行中队列，并且让线程池立即执行。 这里使用了ArrayDeque这个类，ArrayDeque是Java集合中双端队列的数组实现，相似的还有双端队列的链表实现（LinkedList）。它作为栈使用时比 Stack 类效率要高，作为队列使用时比LinkedList要快。 协议 Protocol public enum Protocol { // http 1.0 HTTP_1_0(\"http/1.0\"), // http1.1 HTTP_1_1(\"http/1.1\"), // 不认识这个 SPDY_3(\"spdy/3.1\"), // http2.0 HTTP_2(\"h2\"), // Http3.0,谷歌基于udp实现的quic协议，解决了头部阻塞和弱网环境下网络稳定问题 QUIC(\"quic\"); } ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:2","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#协议-protocol"},{"categories":["第三方框架"],"content":" RequestRequest是个最终类，只是用来表示请求所需的信息： public final class Request { final HttpUrl url; final String method; final Headers headers; final @Nullable RequestBody body; final Object tag; private volatile CacheControl cacheControl; // Lazily initialized. ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:3","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#request"},{"categories":["第三方框架"],"content":" Response public final class Response implements Closeable { final Request request; final Protocol protocol; final int code; final String message; // 握手 final @Nullable Handshake handshake; final Headers headers; final @Nullable ResponseBody body; final @Nullable Response networkResponse; final @Nullable Response cacheResponse; final @Nullable Response priorResponse; final long sentRequestAtMillis; final long receivedResponseAtMillis; private volatile CacheControl cacheControl; ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:4","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#response"},{"categories":["第三方框架"],"content":" Call 表示请求的行为过程 Call接口 public interface Call extends Cloneable { // 返回Request Request request(); // 同步执行，可直接返回Response Response execute() throws IOException; // 异步执行，需要传递回调 void enqueue(Callback responseCallback); // 取消 void cancel(); boolean isExecuted(); boolean isCanceled(); // 克隆 Call clone(); // 工厂 interface Factory { Call newCall(Request request); } } Call接口主要是定义了请求的行为，包含同步请求的行为和异步请求的行为，他的实现类是RealCall。 RealCall final class RealCall implements Call { final OkHttpClient client; final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor; // 状态监听器 private EventListener eventListener; final Request originalRequest; final boolean forWebSocket; private boolean executed; private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } // 同步执行 @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); eventListener.callStart(this); try { client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } // 异步执行 @Override public void enqueue(Callback responseCallback) { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); } @Override public void cancel() { retryAndFollowUpInterceptor.cancel(); } @Override public synchronized boolean isExecuted() { return executed; } @Override public boolean isCanceled() { return retryAndFollowUpInterceptor.isCanceled(); } @SuppressWarnings(\"CloneDoesntCallSuperClone\") // We are a final type \u0026 this saves clearing state. @Override public RealCall clone() { return RealCall.newRealCall(client, originalRequest, forWebSocket); } StreamAllocation streamAllocation() { return retryAndFollowUpInterceptor.streamAllocation(); } final class AsyncCall extends NamedRunnable { private final Callback responseCallback; AsyncCall(Callback responseCallback) { super(\"OkHttp %s\", redactedUrl()); this.responseCallback = responseCallback; } String host() { return originalRequest.url().host(); } Request request() { return originalRequest; } RealCall get() { return RealCall.this; } @Override protected void execute() { boolean signalledCallback = false; try { Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) { signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); } else { signalledCallback = true; responseCallback.onResponse(RealCall.this, response); } } catch (IOException e) { if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); } else { eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); } } finally { client.dispatcher().finished(this); } } } String redactedUrl() { return originalRequest.url().redact(); } // 从OkhttpClient中拿出各种所需的拦截器给自己 // 最后调用chain.proceed(originalRequest)来处理请求 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List\u003cInterceptor\u003e interceptors = new ArrayList\u003c\u003e(); interceptors.addAll(client.interceptors()); interceptors.add(ret","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:5","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#call-表示请求的行为过程"},{"categories":["第三方框架"],"content":" Call 表示请求的行为过程 Call接口 public interface Call extends Cloneable { // 返回Request Request request(); // 同步执行，可直接返回Response Response execute() throws IOException; // 异步执行，需要传递回调 void enqueue(Callback responseCallback); // 取消 void cancel(); boolean isExecuted(); boolean isCanceled(); // 克隆 Call clone(); // 工厂 interface Factory { Call newCall(Request request); } } Call接口主要是定义了请求的行为，包含同步请求的行为和异步请求的行为，他的实现类是RealCall。 RealCall final class RealCall implements Call { final OkHttpClient client; final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor; // 状态监听器 private EventListener eventListener; final Request originalRequest; final boolean forWebSocket; private boolean executed; private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } // 同步执行 @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); eventListener.callStart(this); try { client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } // 异步执行 @Override public void enqueue(Callback responseCallback) { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); } @Override public void cancel() { retryAndFollowUpInterceptor.cancel(); } @Override public synchronized boolean isExecuted() { return executed; } @Override public boolean isCanceled() { return retryAndFollowUpInterceptor.isCanceled(); } @SuppressWarnings(\"CloneDoesntCallSuperClone\") // We are a final type \u0026 this saves clearing state. @Override public RealCall clone() { return RealCall.newRealCall(client, originalRequest, forWebSocket); } StreamAllocation streamAllocation() { return retryAndFollowUpInterceptor.streamAllocation(); } final class AsyncCall extends NamedRunnable { private final Callback responseCallback; AsyncCall(Callback responseCallback) { super(\"OkHttp %s\", redactedUrl()); this.responseCallback = responseCallback; } String host() { return originalRequest.url().host(); } Request request() { return originalRequest; } RealCall get() { return RealCall.this; } @Override protected void execute() { boolean signalledCallback = false; try { Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) { signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); } else { signalledCallback = true; responseCallback.onResponse(RealCall.this, response); } } catch (IOException e) { if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); } else { eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); } } finally { client.dispatcher().finished(this); } } } String redactedUrl() { return originalRequest.url().redact(); } // 从OkhttpClient中拿出各种所需的拦截器给自己 // 最后调用chain.proceed(originalRequest)来处理请求 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List interceptors = new ArrayList\u003c\u003e(); interceptors.addAll(client.interceptors()); interceptors.add(ret","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:5","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#call接口"},{"categories":["第三方框架"],"content":" Call 表示请求的行为过程 Call接口 public interface Call extends Cloneable { // 返回Request Request request(); // 同步执行，可直接返回Response Response execute() throws IOException; // 异步执行，需要传递回调 void enqueue(Callback responseCallback); // 取消 void cancel(); boolean isExecuted(); boolean isCanceled(); // 克隆 Call clone(); // 工厂 interface Factory { Call newCall(Request request); } } Call接口主要是定义了请求的行为，包含同步请求的行为和异步请求的行为，他的实现类是RealCall。 RealCall final class RealCall implements Call { final OkHttpClient client; final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor; // 状态监听器 private EventListener eventListener; final Request originalRequest; final boolean forWebSocket; private boolean executed; private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } // 同步执行 @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); eventListener.callStart(this); try { client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } // 异步执行 @Override public void enqueue(Callback responseCallback) { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); } @Override public void cancel() { retryAndFollowUpInterceptor.cancel(); } @Override public synchronized boolean isExecuted() { return executed; } @Override public boolean isCanceled() { return retryAndFollowUpInterceptor.isCanceled(); } @SuppressWarnings(\"CloneDoesntCallSuperClone\") // We are a final type \u0026 this saves clearing state. @Override public RealCall clone() { return RealCall.newRealCall(client, originalRequest, forWebSocket); } StreamAllocation streamAllocation() { return retryAndFollowUpInterceptor.streamAllocation(); } final class AsyncCall extends NamedRunnable { private final Callback responseCallback; AsyncCall(Callback responseCallback) { super(\"OkHttp %s\", redactedUrl()); this.responseCallback = responseCallback; } String host() { return originalRequest.url().host(); } Request request() { return originalRequest; } RealCall get() { return RealCall.this; } @Override protected void execute() { boolean signalledCallback = false; try { Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) { signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); } else { signalledCallback = true; responseCallback.onResponse(RealCall.this, response); } } catch (IOException e) { if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); } else { eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); } } finally { client.dispatcher().finished(this); } } } String redactedUrl() { return originalRequest.url().redact(); } // 从OkhttpClient中拿出各种所需的拦截器给自己 // 最后调用chain.proceed(originalRequest)来处理请求 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List interceptors = new ArrayList\u003c\u003e(); interceptors.addAll(client.interceptors()); interceptors.add(ret","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:5","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#realcall"},{"categories":["第三方框架"],"content":" 拦截器 负责将Request处理为Response public interface Interceptor { // 拦截回调方法 Response intercept(Chain chain) throws IOException; // 拦截器子类：拦截器链式管理器，实现类是RealInterceptorChain interface Chain { Request request(); Response proceed(Request request) throws IOException; @Nullable Connection connection(); Call call(); int connectTimeoutMillis(); Chain withConnectTimeout(int timeout, TimeUnit unit); int readTimeoutMillis(); Chain withReadTimeout(int timeout, TimeUnit unit); int writeTimeoutMillis(); Chain withWriteTimeout(int timeout, TimeUnit unit); } } ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:6","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#拦截器-负责将request处理为response"},{"categories":["第三方框架"],"content":" 拦截器管理器(拦截器链) 看到这，我就觉得JW大神写的代码是真牛逼啊，不服都不行，层次分明，各层都符合六大原则，看的太爽了。 public final class RealInterceptorChain implements Interceptor.Chain { private final List\u003cInterceptor\u003e interceptors; private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; // 一开始为0 private final int index; private final Request request; private final Call call; private final EventListener eventListener; private final int connectTimeout; private final int readTimeout; private final int writeTimeout; // 初始为0 private int calls; // 注意看这个构造方法 private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; // 直接初始化了一个重试拦截器 this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); } static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,RealConnection connection) throws IOException { if (index \u003e= interceptors.size()) throw new AssertionError(); calls++; // 注意这里的index+1 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); return response; } } 这个东西其实应该叫做「真正的拦截器链」，而我为了明确其作用，叫做「拦截器管理器」。 作用就是让队列中的拦截器one by one的处理请求，上一个拦截器负责处理下一个拦截器的返回结果，所以调用是从ArrayList的首个元素开始向下遍历到队尾，再逐渐pop回来。 我们把每一个RealInterceptorChain看作链条中的一环，每一环的processd()方法中，通过指定index+1来创建下一环，之后通过index拿到对应的拦截器，靠拦截器去处理下一环，如此递归调用，最后层层返回response。 这样做的好处是什么呢，当然是贴合http的请求过程。但是问题也很明显，方法调用层级过深，并且request的处理逻辑会与response的逻辑处理耦合在一起，变得密不可分。 其实以前用OK的时候就有这个感觉了，并且后来写Flutter的时候用到了dio框架，它的拦截器把request、response、error分开处理，结构更加的清晰。 那么我觉得，对于自身的interceptors来说，最后添加的拦截器是最先处理response的，也就是建立连接的始作俑者。 interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } // CallServerInterceptor拦截器用来建立连接 interceptors.add(new CallServerInterceptor(forWebSocket)); 然而在CallServerInterceptor中我找不到任何建立连接的代码。通过观察，我发现这个retryAndFollowUpInterceptor很有意思，于是接下来要去看看它是做什么用的。 ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:7","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#拦截器管理器拦截器链"},{"categories":["第三方框架"],"content":" 事件监听器eventListener public abstract class EventListener { /// 空的监听器 public static final EventListener NONE = new EventListener() { }; /// 静态工厂方法 static EventListener.Factory factory(final EventListener listener) { return new EventListener.Factory() { // 我就不明白，这里传了个Call根本就没用上 public EventListener create(Call call) { return listener; } }; } // 当call被execute或者enqueue时回调，但是此时可能request还没有执行 public void callStart(Call call) { } //当调用 Dns.lookup(String)时回调，可能回调多次 public void dnsStart(Call call, String domainName) { } //当dnsStart之后回调 public void dnsEnd(Call call, String domainName, List\u003cInetAddress\u003e inetAddressList) { } //当Socket链接建立后回调 public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) { } //当加密（TSL）链接开始时调用， public void secureConnectStart(Call call) { } // 加密结束后调用 public void secureConnectEnd(Call call, @Nullable Handshake handshake) { } //Socket尝试建立连接之后调用 public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol) { } // 链接失败 public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol, IOException ioe) { } // 链接建立后回调 public void connectionAcquired(Call call, Connection connection) { } // 链接释放后回调 public void connectionReleased(Call call, Connection connection) { } // 请求head开始 public void requestHeadersStart(Call call) { } // 请求head结束 public void requestHeadersEnd(Call call, Request request) { } // 请求body开始 public void requestBodyStart(Call call) { } /// 请求body结束 public void requestBodyEnd(Call call, long byteCount) { } // 响应head开始 public void responseHeadersStart(Call call) { } // 响应head结束 public void responseHeadersEnd(Call call, Response response) { } // 响应body开始 public void responseBodyStart(Call call) { } // 响应body结束 public void responseBodyEnd(Call call, long byteCount) { } // call完成 public void callEnd(Call call) { } // call 失败 public void callFailed(Call call, IOException ioe) { } public interface Factory { EventListener create(Call call); } } 事件监听器，用来侦听一次请求中经历的各种状态。 ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:8","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#事件监听器eventlistener"},{"categories":["第三方框架"],"content":" NamedRunnable public abstract class NamedRunnable implements Runnable { protected final String name; public NamedRunnable(String format, Object... args) { this.name = Util.format(format, args); } @Override public final void run() { String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try { execute(); } finally { Thread.currentThread().setName(oldName); } } protected abstract void execute(); } ","date":"2021-09-07","objectID":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:9","series":["okhttp"],"tags":["okhttp"],"title":"OkHttp3解读","uri":"/okhttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/#namedrunnable"},{"categories":[],"content":" 概述概念：超文本传输协议。依赖传输层中的TCP协议，数据链路层中的IP协议，但自己本身位于应用层。 默认端口号：80。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:1","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#概述"},{"categories":[],"content":" URL统一资源标识符。 http://host[\":\"port][abs_path] ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:2","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#url"},{"categories":[],"content":" 特点 无连接：每次连接只处理一个请求，服务器处理完请求后立即开始挥手，以最快的速度断开连接以节省资源； 媒体独立：通过指定MIME-type，可以传输任何类型的数据； 无状态：对于事务的处理没有记忆功能，不能持久化，所以需要其他技术手段来储存信息，如cookie; 明文传输。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:3","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#特点"},{"categories":[],"content":" 请求结构 回车符与换行符 回车符\\r：告诉打字机把打印头定位到左边界； 换行符\\n：告诉打字机把纸下移一行。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:4","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#请求结构"},{"categories":[],"content":" 请求结构 回车符与换行符 回车符\\r：告诉打字机把打印头定位到左边界； 换行符\\n：告诉打字机把纸下移一行。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:4","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#回车符与换行符"},{"categories":[],"content":" 响应结构 HTTP/1.1 200 OK/r/n Date: Sat, 31 Dec 2005 23:59:59 GMT/r/n Content-Type: text/html;charset=ISO-8859-1/r/n Content-Length: 122/r/n /r/n \u003chtml\u003e \u003c/html\u003e ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:5","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#响应结构"},{"categories":[],"content":" 请求类型 类型 作用 OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*‘的请求来测试服务器的功能性。 HEAD 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET 向特定的资源发出请求。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除 Request-URI 所标识的资源。 content/posts/Technology/网络协议/HTTP协议 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:6","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#请求类型"},{"categories":[],"content":" 状态码 系列 系列描述 1** 信息，服务器收到请求，需要请求者继续执行操作。 2** 成功，操作被成功接收并处理。 3** 重定向，需要进一步的操作以完成请求。 4** 客户端错误，请求包含语法错误或无法完成请求。 5** 服务器错误，服务器在处理请求的过程中发生了错误。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:7","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#状态码"},{"categories":[],"content":" 版本更迭 0.9仅支持GET请求，仅能访问html资源。 1.0 必须在请求行中标明版本号http/1.0; 增加了POST和HEAD请求方法； 增加了Content-Type多媒体类型支持； 增加了客户端cache的支持； 请求必须包函头信息； 增加状态码支持； 增加用户鉴权； 每次Tcontent/posts/Technology/网络协议/HTTP协议会关闭，如果再次请求则需要重新建立TCP连接，开销大效率低。 1.1 引入持久连接； 加入NIO机制，允许在同一个TCP连接中同时发送多个请求，增加了并发性，提高效率； 分块传输数据； 增加PUT、PATCH、OPTIONS、DELETE请求； 请求头中增加Host字段； 支持断点续传（RANGE:bytes）。 Http1.1中虽然复用了TCP连接，并且客户端可以同时发送请求，但是服务端还是按队列顺序来处理，假设前面请求的处理时间过长，导致后面有很多的请求排队等待，会造成「头部阻塞」问题。 由于Http是无状态连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。 多路复用带来一个严重问题，即重要的请求可能一直被阻塞。 2.0 增加双工模式，客户端和服务器都可以同时处理多个请求，解决头部问题； 增加服务器主动推送能力。 3.0(Quick UDP Internet Connections)3.0基于UDP实现，原理当然就是通过短报文解决各种疑难杂症： TCP建立连接时间长； 头部阻塞； 弱网环境，断线。。。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:8","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#版本更迭"},{"categories":[],"content":" 版本更迭 0.9仅支持GET请求，仅能访问html资源。 1.0 必须在请求行中标明版本号http/1.0; 增加了POST和HEAD请求方法； 增加了Content-Type多媒体类型支持； 增加了客户端cache的支持； 请求必须包函头信息； 增加状态码支持； 增加用户鉴权； 每次Tcontent/posts/Technology/网络协议/HTTP协议会关闭，如果再次请求则需要重新建立TCP连接，开销大效率低。 1.1 引入持久连接； 加入NIO机制，允许在同一个TCP连接中同时发送多个请求，增加了并发性，提高效率； 分块传输数据； 增加PUT、PATCH、OPTIONS、DELETE请求； 请求头中增加Host字段； 支持断点续传（RANGE:bytes）。 Http1.1中虽然复用了TCP连接，并且客户端可以同时发送请求，但是服务端还是按队列顺序来处理，假设前面请求的处理时间过长，导致后面有很多的请求排队等待，会造成「头部阻塞」问题。 由于Http是无状态连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。 多路复用带来一个严重问题，即重要的请求可能一直被阻塞。 2.0 增加双工模式，客户端和服务器都可以同时处理多个请求，解决头部问题； 增加服务器主动推送能力。 3.0(Quick UDP Internet Connections)3.0基于UDP实现，原理当然就是通过短报文解决各种疑难杂症： TCP建立连接时间长； 头部阻塞； 弱网环境，断线。。。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:8","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#09"},{"categories":[],"content":" 版本更迭 0.9仅支持GET请求，仅能访问html资源。 1.0 必须在请求行中标明版本号http/1.0; 增加了POST和HEAD请求方法； 增加了Content-Type多媒体类型支持； 增加了客户端cache的支持； 请求必须包函头信息； 增加状态码支持； 增加用户鉴权； 每次Tcontent/posts/Technology/网络协议/HTTP协议会关闭，如果再次请求则需要重新建立TCP连接，开销大效率低。 1.1 引入持久连接； 加入NIO机制，允许在同一个TCP连接中同时发送多个请求，增加了并发性，提高效率； 分块传输数据； 增加PUT、PATCH、OPTIONS、DELETE请求； 请求头中增加Host字段； 支持断点续传（RANGE:bytes）。 Http1.1中虽然复用了TCP连接，并且客户端可以同时发送请求，但是服务端还是按队列顺序来处理，假设前面请求的处理时间过长，导致后面有很多的请求排队等待，会造成「头部阻塞」问题。 由于Http是无状态连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。 多路复用带来一个严重问题，即重要的请求可能一直被阻塞。 2.0 增加双工模式，客户端和服务器都可以同时处理多个请求，解决头部问题； 增加服务器主动推送能力。 3.0(Quick UDP Internet Connections)3.0基于UDP实现，原理当然就是通过短报文解决各种疑难杂症： TCP建立连接时间长； 头部阻塞； 弱网环境，断线。。。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:8","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#10"},{"categories":[],"content":" 版本更迭 0.9仅支持GET请求，仅能访问html资源。 1.0 必须在请求行中标明版本号http/1.0; 增加了POST和HEAD请求方法； 增加了Content-Type多媒体类型支持； 增加了客户端cache的支持； 请求必须包函头信息； 增加状态码支持； 增加用户鉴权； 每次Tcontent/posts/Technology/网络协议/HTTP协议会关闭，如果再次请求则需要重新建立TCP连接，开销大效率低。 1.1 引入持久连接； 加入NIO机制，允许在同一个TCP连接中同时发送多个请求，增加了并发性，提高效率； 分块传输数据； 增加PUT、PATCH、OPTIONS、DELETE请求； 请求头中增加Host字段； 支持断点续传（RANGE:bytes）。 Http1.1中虽然复用了TCP连接，并且客户端可以同时发送请求，但是服务端还是按队列顺序来处理，假设前面请求的处理时间过长，导致后面有很多的请求排队等待，会造成「头部阻塞」问题。 由于Http是无状态连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。 多路复用带来一个严重问题，即重要的请求可能一直被阻塞。 2.0 增加双工模式，客户端和服务器都可以同时处理多个请求，解决头部问题； 增加服务器主动推送能力。 3.0(Quick UDP Internet Connections)3.0基于UDP实现，原理当然就是通过短报文解决各种疑难杂症： TCP建立连接时间长； 头部阻塞； 弱网环境，断线。。。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:8","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#11"},{"categories":[],"content":" 版本更迭 0.9仅支持GET请求，仅能访问html资源。 1.0 必须在请求行中标明版本号http/1.0; 增加了POST和HEAD请求方法； 增加了Content-Type多媒体类型支持； 增加了客户端cache的支持； 请求必须包函头信息； 增加状态码支持； 增加用户鉴权； 每次Tcontent/posts/Technology/网络协议/HTTP协议会关闭，如果再次请求则需要重新建立TCP连接，开销大效率低。 1.1 引入持久连接； 加入NIO机制，允许在同一个TCP连接中同时发送多个请求，增加了并发性，提高效率； 分块传输数据； 增加PUT、PATCH、OPTIONS、DELETE请求； 请求头中增加Host字段； 支持断点续传（RANGE:bytes）。 Http1.1中虽然复用了TCP连接，并且客户端可以同时发送请求，但是服务端还是按队列顺序来处理，假设前面请求的处理时间过长，导致后面有很多的请求排队等待，会造成「头部阻塞」问题。 由于Http是无状态连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。 多路复用带来一个严重问题，即重要的请求可能一直被阻塞。 2.0 增加双工模式，客户端和服务器都可以同时处理多个请求，解决头部问题； 增加服务器主动推送能力。 3.0(Quick UDP Internet Connections)3.0基于UDP实现，原理当然就是通过短报文解决各种疑难杂症： TCP建立连接时间长； 头部阻塞； 弱网环境，断线。。。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:8","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#20"},{"categories":[],"content":" 版本更迭 0.9仅支持GET请求，仅能访问html资源。 1.0 必须在请求行中标明版本号http/1.0; 增加了POST和HEAD请求方法； 增加了Content-Type多媒体类型支持； 增加了客户端cache的支持； 请求必须包函头信息； 增加状态码支持； 增加用户鉴权； 每次Tcontent/posts/Technology/网络协议/HTTP协议会关闭，如果再次请求则需要重新建立TCP连接，开销大效率低。 1.1 引入持久连接； 加入NIO机制，允许在同一个TCP连接中同时发送多个请求，增加了并发性，提高效率； 分块传输数据； 增加PUT、PATCH、OPTIONS、DELETE请求； 请求头中增加Host字段； 支持断点续传（RANGE:bytes）。 Http1.1中虽然复用了TCP连接，并且客户端可以同时发送请求，但是服务端还是按队列顺序来处理，假设前面请求的处理时间过长，导致后面有很多的请求排队等待，会造成「头部阻塞」问题。 由于Http是无状态连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。 多路复用带来一个严重问题，即重要的请求可能一直被阻塞。 2.0 增加双工模式，客户端和服务器都可以同时处理多个请求，解决头部问题； 增加服务器主动推送能力。 3.0(Quick UDP Internet Connections)3.0基于UDP实现，原理当然就是通过短报文解决各种疑难杂症： TCP建立连接时间长； 头部阻塞； 弱网环境，断线。。。 ","date":"2021-08-31","objectID":"/http%E5%8D%8F%E8%AE%AE/:0:8","series":["网络协议"],"tags":[],"title":"HTTP协议","uri":"/http%E5%8D%8F%E8%AE%AE/#30quick-udp-internet-connections"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#物理层"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#数据链路层"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#网络层"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#传输层"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#会话层"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#表示层"},{"categories":[],"content":" 物理层作用：定义一些电器、机械、过程和规范，如集线器； 设备：集线器。 数据链路层作用：负责把物理层的比特流封装成帧数据传递给上一层，也支持逆向。 设备：交换机通过MAC地址转发数据，逻辑链路控制。 网络层作用：定义一个逻辑的殉职，选择最佳路径传输，路由数据包。 典型协议：IP。 设备：路由器。 传输层作用：提供可靠和尽力而为的传输。 协议：TCP，UDP 负责网络传输和会话的建立。 会话层作用：控制会话，建立管理终止应用程序会话。 协议：SQL、JSP 负责会话建立； 表示层作用：格式化数据。 协议：json、png、wav 应用层网络传输的应用程序，如Http。 ","date":"2021-08-23","objectID":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/:0:0","series":["网络协议"],"tags":[],"title":"七层协议","uri":"/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/#应用层"},{"categories":[],"content":" 概念 屏幕尺寸屏幕对角线的长度，单位是英寸。 1英寸 = 2.54厘米。 屏幕分辨率屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。 屏幕像素密度屏幕像素密度是指每英寸上的像素点数，单位是dpi。 密度类型 匹配分辨率 像素密度 ldpi 240*320 120 mdpi 320*480 160 hdpi 480*800 240 xhdpi 720*1280 320 xxhdpi 1080*1920 480 ","date":"2021-08-10","objectID":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/:0:1","series":[],"tags":["Android"],"title":"Android屏幕适配","uri":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/#概念"},{"categories":[],"content":" 概念 屏幕尺寸屏幕对角线的长度，单位是英寸。 1英寸 = 2.54厘米。 屏幕分辨率屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。 屏幕像素密度屏幕像素密度是指每英寸上的像素点数，单位是dpi。 密度类型 匹配分辨率 像素密度 ldpi 240*320 120 mdpi 320*480 160 hdpi 480*800 240 xhdpi 720*1280 320 xxhdpi 1080*1920 480 ","date":"2021-08-10","objectID":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/:0:1","series":[],"tags":["Android"],"title":"Android屏幕适配","uri":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/#屏幕尺寸"},{"categories":[],"content":" 概念 屏幕尺寸屏幕对角线的长度，单位是英寸。 1英寸 = 2.54厘米。 屏幕分辨率屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。 屏幕像素密度屏幕像素密度是指每英寸上的像素点数，单位是dpi。 密度类型 匹配分辨率 像素密度 ldpi 240*320 120 mdpi 320*480 160 hdpi 480*800 240 xhdpi 720*1280 320 xxhdpi 1080*1920 480 ","date":"2021-08-10","objectID":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/:0:1","series":[],"tags":["Android"],"title":"Android屏幕适配","uri":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/#屏幕分辨率"},{"categories":[],"content":" 概念 屏幕尺寸屏幕对角线的长度，单位是英寸。 1英寸 = 2.54厘米。 屏幕分辨率屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。 屏幕像素密度屏幕像素密度是指每英寸上的像素点数，单位是dpi。 密度类型 匹配分辨率 像素密度 ldpi 240*320 120 mdpi 320*480 160 hdpi 480*800 240 xhdpi 720*1280 320 xxhdpi 1080*1920 480 ","date":"2021-08-10","objectID":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/:0:1","series":[],"tags":["Android"],"title":"Android屏幕适配","uri":"/android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/#屏幕像素密度"},{"categories":[],"content":" 概述ActivityManagerService诞生自SystemServer，主要负责四大组件的启动、切换、调度以及应用进程的管理和调度工作。 主要分为: 服务代理：由ActivityManagerProxy实现，用于与Server端提供的系统服务进行IPC； 服务中枢：ActivityManagerNative继承自Binder并实现IActivityManager，它提供了服务接口和Binder接口的相互转化功能，并在内部存储服务代理对像，并提供了getDefault方法返回服务代理； Client：由ActivityManager封装一部分服务接口供Client调用。ActivityManager内部通过调用ActivityManagerNative的getDefault方法，可以得到一ActivityManagerProxy对像的引用，进而通过该代理对像调用远程服务的方法； Server: 由ActivityManagerService实现，提供Server端的系统服务。 实际上他就是个Binder,可以用来IPC ","date":"2021-08-09","objectID":"/ams/:0:1","series":["AndroidFramework"],"tags":["Android"],"title":"AMS","uri":"/ams/#概述"},{"categories":[],"content":" Hook点binder天然带有调用者的身份信息uid和进程信息pid 。 ","date":"2021-08-09","objectID":"/ams/:0:2","series":["AndroidFramework"],"tags":["Android"],"title":"AMS","uri":"/ams/#hook点"},{"categories":[],"content":"TODO ","date":"2021-08-09","objectID":"/android%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:0","series":["AndroidFramework"],"tags":[],"title":"Android虚拟机","uri":"/android%E8%99%9A%E6%8B%9F%E6%9C%BA/#"},{"categories":[],"content":"Crash（应用崩溃）是由于代码异常而导致 App 非正常退出，导致应用程序无法继续使用，所有工作都停止的现象。发生 Crash 后需要重新启动应用（有些情况会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 Crash 发生，特别是在 Android 系统中，系统碎片化严重、各 ROM 之间的差异，甚至系统Bug，都可能会导致Crash的发生。在 Android 应用中发生的 Crash 有两种类型，Java 层的 Crash 和 Native 层 Crash。这两种Crash 的监控和获取堆栈信息有所不同。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:0","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#"},{"categories":[],"content":" 什么是崩溃未处理的异常或信号导致的意外退出，会使 Android 应用崩溃。 当应用崩溃时，Android 会终止应用的进程并显示一个对话框，告知用户应用已停止。 使用 Java 编写的应用会在抛出未处理的异常（由 Throwable 类表示）时崩溃。使用原生代码语言编写的应用，会在执行过程中遇到未处理的信号（如 SIGSEGV）时崩溃。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#什么是崩溃"},{"categories":[],"content":" Java Crash 监控我们可以通过Thread.setDefaultUncaughtExceptionHandler方法来设置线程的默认异常处理器。 public class App extends Application { @Override public void onCreate() { super.onCreate(); Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExcetionHandler()); } public static class MyUncaughtExcetionHandler implements Thread.UncaughtExceptionHandler { @Override public void uncaughtException(@NonNull Thread t, @NonNull Throwable e) { } } } Thread的默认UncaughtExceptionHandler，是RuntimeInit#KillApplicationHandler，功能就是杀掉程序，所以我们不更改的话，程序就会弹窗并退出。 测试行为测试方式，我在UI里面定义了一个按钮，点击后会触发一个未捕获的NPE： public void test(View v) { String content = null; content.length(); } 实测点击程序崩溃。 当设置了Thread.setDefaultUncaughtExceptionHandler之后，再次点击按钮触发NPE，可以拦截到未捕获异常，而且程序没有崩溃。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#java-crash-监控"},{"categories":[],"content":" Java Crash 监控我们可以通过Thread.setDefaultUncaughtExceptionHandler方法来设置线程的默认异常处理器。 public class App extends Application { @Override public void onCreate() { super.onCreate(); Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExcetionHandler()); } public static class MyUncaughtExcetionHandler implements Thread.UncaughtExceptionHandler { @Override public void uncaughtException(@NonNull Thread t, @NonNull Throwable e) { } } } Thread的默认UncaughtExceptionHandler，是RuntimeInit#KillApplicationHandler，功能就是杀掉程序，所以我们不更改的话，程序就会弹窗并退出。 测试行为测试方式，我在UI里面定义了一个按钮，点击后会触发一个未捕获的NPE： public void test(View v) { String content = null; content.length(); } 实测点击程序崩溃。 当设置了Thread.setDefaultUncaughtExceptionHandler之后，再次点击按钮触发NPE，可以拦截到未捕获异常，而且程序没有崩溃。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#测试行为"},{"categories":[],"content":" NDK Crash 监控 Linux信号机制linux信号机制是IPC的一种方式，同时也负责监控系统异常及中断。 当程序发生运行异常时，linux内核将会产生错误信号并通知当前进程，当前进程在收到该错误信号后，可以又三种处理方式： 忽略信号； 捕捉信号并执行信号处理逻辑； 执行信号的默认操作（记录信息，然后终止进程）。 crash信号 信号 描述 SIGSEGV 内存引用无效 SIGBUS 访问内存对象的未定义部分 SIGFPE 算术运算错误（0做除数） SIGILL 非法指令，如执行垃圾或特权指令 SIGSYS 糟糕的系统调用 SIGXCPU 超过CPU时限 SIGFSZ 超出文件大小限制 一般的出现崩溃信号，Android系统默认缺省操作是直接退出我们的程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（signal），即对该信号的默认处理动作进行修改。因此NDK Crash的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数从而捕获NDK Crash。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#ndk-crash-监控"},{"categories":[],"content":" NDK Crash 监控 Linux信号机制linux信号机制是IPC的一种方式，同时也负责监控系统异常及中断。 当程序发生运行异常时，linux内核将会产生错误信号并通知当前进程，当前进程在收到该错误信号后，可以又三种处理方式： 忽略信号； 捕捉信号并执行信号处理逻辑； 执行信号的默认操作（记录信息，然后终止进程）。 crash信号 信号 描述 SIGSEGV 内存引用无效 SIGBUS 访问内存对象的未定义部分 SIGFPE 算术运算错误（0做除数） SIGILL 非法指令，如执行垃圾或特权指令 SIGSYS 糟糕的系统调用 SIGXCPU 超过CPU时限 SIGFSZ 超出文件大小限制 一般的出现崩溃信号，Android系统默认缺省操作是直接退出我们的程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（signal），即对该信号的默认处理动作进行修改。因此NDK Crash的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数从而捕获NDK Crash。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#linux信号机制"},{"categories":[],"content":" NDK Crash 监控 Linux信号机制linux信号机制是IPC的一种方式，同时也负责监控系统异常及中断。 当程序发生运行异常时，linux内核将会产生错误信号并通知当前进程，当前进程在收到该错误信号后，可以又三种处理方式： 忽略信号； 捕捉信号并执行信号处理逻辑； 执行信号的默认操作（记录信息，然后终止进程）。 crash信号 信号 描述 SIGSEGV 内存引用无效 SIGBUS 访问内存对象的未定义部分 SIGFPE 算术运算错误（0做除数） SIGILL 非法指令，如执行垃圾或特权指令 SIGSYS 糟糕的系统调用 SIGXCPU 超过CPU时限 SIGFSZ 超出文件大小限制 一般的出现崩溃信号，Android系统默认缺省操作是直接退出我们的程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（signal），即对该信号的默认处理动作进行修改。因此NDK Crash的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数从而捕获NDK Crash。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#crash信号"},{"categories":[],"content":" 墓碑文件Android本机程序本质上就是一个Linux程序，当它在执行时发生严重错误，也会导致程序崩溃，然后产 生一个记录崩溃的现场信息的文件，而这个文件在Android系统中就是 tombstones 墓碑文件。位于~/data/tombstones/下。普通应用没有读取权限。 ","date":"2021-08-09","objectID":"/crash%E7%9B%91%E6%8E%A7/:0:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Crash监控","uri":"/crash%E7%9B%91%E6%8E%A7/#墓碑文件"},{"categories":[],"content":" APK文件的构成 META-INF/：包含CERT.SF和CERT.RSA签名文件，和MANIFEST.MF清单文件； assets/：不需编译的资源文件； res/：包含需要编译到resource.arsc，但还未编译的资源； lib/：包含特定于处理器软件层的已编译代码armeabi等； resource.arsc：包含已编译的资源； classes.dex：我们的代码； AndroidManifest.xml：核心Android清单文件。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#apk文件的构成"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含\u003cresources\u003e的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cresources xmlns:tools=\"http://schemas.android.com/tools\" tools:keep=\"@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*\" tools:discard=\"@layout/unused2\" /\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 \u003capplication android:name=\"io.flutter.app.FlutterApplication\" android:extractNativeLibs=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:networkSecurityConfig=\"@xml/network_security_config\" android:requestLegacyExternalStorage=\"true\" android:usesCleartextTraffic=\"true\"\u003e 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#瘦身方法"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#移除未使用资源"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#如何保护必须资源"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#启用资源缩减"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#指定本地化语言"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#指定需要的动态库so"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#图片瘦身"},{"categories":[],"content":" 瘦身方法 移除未使用资源可以通过IDE提供的建议，和lint检查工具检测出未使用的资源、无用的import、字段、方法、类，然后删掉。 如何保护必须资源lint 工具不会扫描 assets/ 文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。 那么有些资源暂时用不到，我们又需要保留的，可以通过创建一个包含的xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e tools:keep 指定每个要保留的资源； tools:discard 指定要舍弃的资源； 这两个属性都接受逗号分隔符和*号通配符。 启用资源缩减 minifyEnabled，开启代码混淆； shrinkResources，开启资源缩减。 指定本地化语言如果使用了包含了语言的库（如AppCompat），那么打包的时候会把所有已翻译的语言的字符串都打包进去。 所以我们可以指定需要的语言来缩减apk体积： android { defaultConfig { ... resConfigs \"zh-rCN\" } } 指定需要的动态库so android{ defaultConfig{ ndk{ abiFilters \"armeabi-v7a\" } } } armeabi-v7a兼容arm64架构，但是不如arm64的so性能高。我们可以配合productFlavor和flavorDimensions来分别针对arm和arm64设备来打包。 图片瘦身可以使用webp替代png和jpg，可以使用VectorDrawable矢量图替代应用图标。 可以通过ImageView的tint属性前台改色，达到复用图片的目的。 开启本地库压缩 当android:extractNativeLibs = true时，gradle打包会对工程中的so进行压缩，使最终生成的apk体积变小。但用户在安装过程中，系统会对so库解压，从而造成apk安装时间变长。 ","date":"2021-08-09","objectID":"/apk%E7%98%A6%E8%BA%AB/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"APK瘦身","uri":"/apk%E7%98%A6%E8%BA%AB/#开启本地库压缩"},{"categories":[],"content":" 网络连接流程DNS解析-\u003eIP-\u003eSocket(TCP/IP)-\u003e服务端 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#网络连接流程"},{"categories":[],"content":" 网络连接提速 直接使用IP地址，省掉DNS解析过程； 复用连接或者使用同一条长连接； 压缩数据，减小数据传输量。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#网络连接提速"},{"categories":[],"content":" DNS解析域名流程 先从本地缓存中查找域名； 查不到会从就近的其他DNS服务器查询； 再查不到会去主域名服务器查询； 这个查询过程是相当漫长的，而且每一级都有缓存，缓存有过期限制，一旦过期就要重新去查。 DNS的缺点 解析流程漫长，耗时多； 由于缓存时限过长，域名不能即时更新； 由于缓存时限过短影响请求速度； 解析过程不受控制，不能保证解析到最快的IP（最近的不一定最快）； 一次请求只能解析一个域名； 容易遭到中间人攻击或被运营商劫持。 HTTPDNS就是自己在服务器上做域名解析，通过HTTP请求后台拿到域名对应的IP地址。 HTTPDNS的优势 直接通过IP地址请求，不存在domain解析，避免被劫持； 解析过程由自己控制，可以确保解析到最快的IP地址； 一次请求可解析多个域名。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#dns解析域名流程"},{"categories":[],"content":" DNS解析域名流程 先从本地缓存中查找域名； 查不到会从就近的其他DNS服务器查询； 再查不到会去主域名服务器查询； 这个查询过程是相当漫长的，而且每一级都有缓存，缓存有过期限制，一旦过期就要重新去查。 DNS的缺点 解析流程漫长，耗时多； 由于缓存时限过长，域名不能即时更新； 由于缓存时限过短影响请求速度； 解析过程不受控制，不能保证解析到最快的IP（最近的不一定最快）； 一次请求只能解析一个域名； 容易遭到中间人攻击或被运营商劫持。 HTTPDNS就是自己在服务器上做域名解析，通过HTTP请求后台拿到域名对应的IP地址。 HTTPDNS的优势 直接通过IP地址请求，不存在domain解析，避免被劫持； 解析过程由自己控制，可以确保解析到最快的IP地址； 一次请求可解析多个域名。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#dns的缺点"},{"categories":[],"content":" DNS解析域名流程 先从本地缓存中查找域名； 查不到会从就近的其他DNS服务器查询； 再查不到会去主域名服务器查询； 这个查询过程是相当漫长的，而且每一级都有缓存，缓存有过期限制，一旦过期就要重新去查。 DNS的缺点 解析流程漫长，耗时多； 由于缓存时限过长，域名不能即时更新； 由于缓存时限过短影响请求速度； 解析过程不受控制，不能保证解析到最快的IP（最近的不一定最快）； 一次请求只能解析一个域名； 容易遭到中间人攻击或被运营商劫持。 HTTPDNS就是自己在服务器上做域名解析，通过HTTP请求后台拿到域名对应的IP地址。 HTTPDNS的优势 直接通过IP地址请求，不存在domain解析，避免被劫持； 解析过程由自己控制，可以确保解析到最快的IP地址； 一次请求可解析多个域名。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#httpdns"},{"categories":[],"content":" DNS解析域名流程 先从本地缓存中查找域名； 查不到会从就近的其他DNS服务器查询； 再查不到会去主域名服务器查询； 这个查询过程是相当漫长的，而且每一级都有缓存，缓存有过期限制，一旦过期就要重新去查。 DNS的缺点 解析流程漫长，耗时多； 由于缓存时限过长，域名不能即时更新； 由于缓存时限过短影响请求速度； 解析过程不受控制，不能保证解析到最快的IP（最近的不一定最快）； 一次请求只能解析一个域名； 容易遭到中间人攻击或被运营商劫持。 HTTPDNS就是自己在服务器上做域名解析，通过HTTP请求后台拿到域名对应的IP地址。 HTTPDNS的优势 直接通过IP地址请求，不存在domain解析，避免被劫持； 解析过程由自己控制，可以确保解析到最快的IP地址； 一次请求可解析多个域名。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#httpdns的优势"},{"categories":[],"content":" 连接优化 keep-alivehttp协议中存在keep-alive（就在请求头里），在HTTP1.1开始默认开启，一定程度上缓解了每次请求都要三次握手建立连接的耗时。 原理是请求完成之后不释放连接，而且放到连接池中缓存。 但是，开启keep-alive的连接一次性只能发送一个请求，在上一个请求处理完成之前，无法接受新的请求。若同时发起多个请求，会发生： 若串行发送请求，可以以阻塞队列的方式复用同一个连接，但是速度很慢； 若并行发送请求，每个请求都要进程三次握手建立新连接的过程。 问题解决http2提出了多路复用来解决并行请求的问题。 http2中，也是复用连接，但是一条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行。 原理是把连接传输的数据都打包成一个个的stream，每个stream都具有标识，stream的发送和接受可以是乱序的，也不存在阻塞的问题，接收端根据标识来区分请求，再进行数据拼接，得到最终数据。 OkHttp默认会开启keep-alive，并且在Okhttp3以上也支持了Http2。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#连接优化"},{"categories":[],"content":" 连接优化 keep-alivehttp协议中存在keep-alive（就在请求头里），在HTTP1.1开始默认开启，一定程度上缓解了每次请求都要三次握手建立连接的耗时。 原理是请求完成之后不释放连接，而且放到连接池中缓存。 但是，开启keep-alive的连接一次性只能发送一个请求，在上一个请求处理完成之前，无法接受新的请求。若同时发起多个请求，会发生： 若串行发送请求，可以以阻塞队列的方式复用同一个连接，但是速度很慢； 若并行发送请求，每个请求都要进程三次握手建立新连接的过程。 问题解决http2提出了多路复用来解决并行请求的问题。 http2中，也是复用连接，但是一条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行。 原理是把连接传输的数据都打包成一个个的stream，每个stream都具有标识，stream的发送和接受可以是乱序的，也不存在阻塞的问题，接收端根据标识来区分请求，再进行数据拼接，得到最终数据。 OkHttp默认会开启keep-alive，并且在Okhttp3以上也支持了Http2。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#keep-alive"},{"categories":[],"content":" 连接优化 keep-alivehttp协议中存在keep-alive（就在请求头里），在HTTP1.1开始默认开启，一定程度上缓解了每次请求都要三次握手建立连接的耗时。 原理是请求完成之后不释放连接，而且放到连接池中缓存。 但是，开启keep-alive的连接一次性只能发送一个请求，在上一个请求处理完成之前，无法接受新的请求。若同时发起多个请求，会发生： 若串行发送请求，可以以阻塞队列的方式复用同一个连接，但是速度很慢； 若并行发送请求，每个请求都要进程三次握手建立新连接的过程。 问题解决http2提出了多路复用来解决并行请求的问题。 http2中，也是复用连接，但是一条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行。 原理是把连接传输的数据都打包成一个个的stream，每个stream都具有标识，stream的发送和接受可以是乱序的，也不存在阻塞的问题，接收端根据标识来区分请求，再进行数据拼接，得到最终数据。 OkHttp默认会开启keep-alive，并且在Okhttp3以上也支持了Http2。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#问题解决"},{"categories":[],"content":" 数据压缩 选择序列化方式 json protobuf 请求体压缩采用gzip对body进行压缩。 OkHttp的BridgeInterceptor这个拦截器会默认开启gzip解压支持： boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null \u0026\u0026 userRequest.header(\"Range\") == null) { transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); } 压缩之后会在Header中添加Content-Encodin:gzip。 其他 webp代替png和jpg； 2/3G网络下让服务器下发低清图片； 缓存。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#数据压缩"},{"categories":[],"content":" 数据压缩 选择序列化方式 json protobuf 请求体压缩采用gzip对body进行压缩。 OkHttp的BridgeInterceptor这个拦截器会默认开启gzip解压支持： boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null \u0026\u0026 userRequest.header(\"Range\") == null) { transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); } 压缩之后会在Header中添加Content-Encodin:gzip。 其他 webp代替png和jpg； 2/3G网络下让服务器下发低清图片； 缓存。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#选择序列化方式"},{"categories":[],"content":" 数据压缩 选择序列化方式 json protobuf 请求体压缩采用gzip对body进行压缩。 OkHttp的BridgeInterceptor这个拦截器会默认开启gzip解压支持： boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null \u0026\u0026 userRequest.header(\"Range\") == null) { transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); } 压缩之后会在Header中添加Content-Encodin:gzip。 其他 webp代替png和jpg； 2/3G网络下让服务器下发低清图片； 缓存。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#请求体压缩"},{"categories":[],"content":" 数据压缩 选择序列化方式 json protobuf 请求体压缩采用gzip对body进行压缩。 OkHttp的BridgeInterceptor这个拦截器会默认开启gzip解压支持： boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null \u0026\u0026 userRequest.header(\"Range\") == null) { transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); } 压缩之后会在Header中添加Content-Encodin:gzip。 其他 webp代替png和jpg； 2/3G网络下让服务器下发低清图片； 缓存。 ","date":"2021-08-06","objectID":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/:0:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"网络优化","uri":"/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/#其他"},{"categories":[],"content":" 电量优化方法 减少不必要的操作，例如缓存数据，而不每次都请求数据 延迟操作，等设备满电或充电时再执行。 合并操作，批处理，减少设备处于活动状态的时间。 ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:1:0","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#电量优化方法"},{"categories":[],"content":" Doze打盹模式Android6.0推出。 针对整个系统。 如果设备未充电，屏幕熄灭，让设备在一段时间后发生间歇性打盹-苏醒，打盹时阻塞所有任务，等苏醒时一并处理，且打盹时间会越来越长。 影响范围： 暂停网络 忽略PowerManager. WakeLock唤醒； 延迟AlarmManager. 不执行WIFI扫描； 不执行账号同步 不执行JobScheduler。 如果需要与网络建立持久性链接，应可能使用Firebase云消息传递FCM（以前叫GCM）。 ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:0","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#doze打盹模式"},{"categories":[],"content":" Doze机制下的闹钟处理 setAndAlarmWhileIdle()一次性闹钟； setExactAndAllowWhileIdle()高精度一次性闹钟； setAlarmClock设置的闹钟可以正常触发，出发前系统会退出低电耗模式。 ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#doze机制下的闹钟处理"},{"categories":[],"content":" Doze测试 启动Doze # 启动Doze adb shell dumpsys deviceidle enable # 强制启动Doze并关闭屏幕 adb shell dumpsys deviceidle force-idle 敲完命令后，必须要关闭屏幕才能真正进入Doze模式。 退出Doze # 关闭Doze adb shell dumpsys deviceidle disable # 退出Doze adb shell dumpsys deviceidle unforce 重置设备 # 重置电池设置 adb shell dumpsys battery reset 查看Doze白名单 adb shell dumpsys deviceidle whitelist ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#doze测试"},{"categories":[],"content":" Doze测试 启动Doze # 启动Doze adb shell dumpsys deviceidle enable # 强制启动Doze并关闭屏幕 adb shell dumpsys deviceidle force-idle 敲完命令后，必须要关闭屏幕才能真正进入Doze模式。 退出Doze # 关闭Doze adb shell dumpsys deviceidle disable # 退出Doze adb shell dumpsys deviceidle unforce 重置设备 # 重置电池设置 adb shell dumpsys battery reset 查看Doze白名单 adb shell dumpsys deviceidle whitelist ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#启动doze"},{"categories":[],"content":" Doze测试 启动Doze # 启动Doze adb shell dumpsys deviceidle enable # 强制启动Doze并关闭屏幕 adb shell dumpsys deviceidle force-idle 敲完命令后，必须要关闭屏幕才能真正进入Doze模式。 退出Doze # 关闭Doze adb shell dumpsys deviceidle disable # 退出Doze adb shell dumpsys deviceidle unforce 重置设备 # 重置电池设置 adb shell dumpsys battery reset 查看Doze白名单 adb shell dumpsys deviceidle whitelist ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#退出doze"},{"categories":[],"content":" Doze测试 启动Doze # 启动Doze adb shell dumpsys deviceidle enable # 强制启动Doze并关闭屏幕 adb shell dumpsys deviceidle force-idle 敲完命令后，必须要关闭屏幕才能真正进入Doze模式。 退出Doze # 关闭Doze adb shell dumpsys deviceidle disable # 退出Doze adb shell dumpsys deviceidle unforce 重置设备 # 重置电池设置 adb shell dumpsys battery reset 查看Doze白名单 adb shell dumpsys deviceidle whitelist ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#重置设备"},{"categories":[],"content":" Doze测试 启动Doze # 启动Doze adb shell dumpsys deviceidle enable # 强制启动Doze并关闭屏幕 adb shell dumpsys deviceidle force-idle 敲完命令后，必须要关闭屏幕才能真正进入Doze模式。 退出Doze # 关闭Doze adb shell dumpsys deviceidle disable # 退出Doze adb shell dumpsys deviceidle unforce 重置设备 # 重置电池设置 adb shell dumpsys battery reset 查看Doze白名单 adb shell dumpsys deviceidle whitelist ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#查看doze白名单"},{"categories":[],"content":" StandBy待机模式针对特定应用。 应用待机模式会延迟用户近期未与之交互的应用的后台网络活动。 当用户很长时间没有与应用交互，并且，应用没有一下表现，则系统会使其进入空闲状态： 用户明确的启动应用； 有前台（活动或服务）进程在运行； 应用生成了通知。 当插入电源时，系统会从待机状态释放应用，如果设备长时间处于闲置状态，系统会允许限制的应用访问网络，频率大概一天一次。 ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#standby待机模式"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： \u003c!-- 必须声明权限 --\u003e \u003cuses-permission android:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\" /\u003e Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#电池优化白名单"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#检查是否在白名单内"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#跳转系统电池优化页面"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#申请加入白名单"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#standby模式测试"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#断开充电"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#启停standby"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#查看是否处于standby"},{"categories":[],"content":" 电池优化白名单在低电耗模式和应用待机模式期间，列入白名单的应用可以使用网络并保留部分唤醒锁定。不过，列入白名单的应用仍会受到其他限制，就像其他应用一样。例如，列入白名单的应用的作业和同步会延迟（在6.0及以下的设备上），并且其常规 AlarmManager 闹钟不会触发。 简言之，just agree but not easy。仅仅同意使用网络和cpu唤醒，但是仍旧有限制，不保证你用的舒服。 检查是否在白名单内 PowerManager.isIgnoringBatteryOptimizations() 跳转系统电池优化页面 startActivity(new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)); 申请加入白名单权限： REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 。 该权限可以触发一个系统对话框，让用户直接将该应用添加到白名单，无需跳转到设置页面： Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\"+getPackageName())); startActivity(intent); StandBy模式测试 断开充电 adb shell dumpsys battery unplug 启停Standby adb shell am set-inactive \u003c包名\u003e true/false 查看是否处于Standby adb shell am get-inactive \u003c包名\u003e 重置电池设置 adb shell dumpsys battery reset ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#重置电池设置"},{"categories":[],"content":" 监控电池状态通过系统广播Intent.ACTION_BATTERY_CHANGED，可以监控到电池是否在充电，是否充满，用USB还是用充电器： IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); Intent batteryStatus = registerReceiver(null, ifilter); // 是否正在充电 int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1); boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL; // 什么方式充电？ int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1); //usb boolean usbCharge = chargePlug == BatteryManager.BATTERY_PLUGGED_USB; //充电器 boolean acCharge = chargePlug == BatteryManager.BATTERY_PLUGGED_AC; Log.e(TAG, \"isCharging: \" + isCharging + \" usbCharge: \" + usbCharge + \" acCharge:\" + acCharge); 系统广播 Intent. ACTION_POWER_CONNECTED 和 Intent. ACTION_POWER_DISCONNECTED 可以监控到电池状态的变化： /注册广播 IntentFilter ifilter = new IntentFilter(); //充电状态 ifilter.addAction(Intent.ACTION_POWER_CONNECTED); ifilter.addAction(Intent.ACTION_POWER_DISCONNECTED); //电量显著变化 ifilter.addAction(Intent.ACTION_BATTERY_LOW); //电量不足 ifilter.addAction(Intent.ACTION_BATTERY_OKAY); //电量从低变回高 powerConnectionReceiver = new PowerConnectionReceiver(); registerReceiver(powerConnectionReceiver, ifilter); public class PowerConnectionReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (intent.getAction().equals(Intent.ACTION_POWER_CONNECTED)) { Toast.makeText(context, \"充电状态：CONNECTED\", Toast.LENGTH_SHORT).show(); } else if (intent.getAction().equals(Intent.ACTION_POWER_DISCONNECTED)) { Toast.makeText(context, \"充电状态：DISCONNECTED\", Toast.LENGTH_SHORT).show(); } else if (intent.getAction().equals(Intent.ACTION_BATTERY_LOW)) { Toast.makeText(context, \"电量过低\", Toast.LENGTH_SHORT).show(); } else if (intent.getAction().equals(Intent.ACTION_BATTERY_OKAY)) { Toast.makeText(context, \"电量从低变回高\", Toast.LENGTH_SHORT).show(); } } } ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#监控电池状态"},{"categories":[],"content":" WorkManagerWorkManager可以根据电池状态调度后台任务。 ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:6","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#workmanager"},{"categories":[],"content":" Battery Historian工具Battery Historian是一个可以了解设备随时间的耗电情况的工具 。在系统级别，该工具以 HTML 的形式可视化来 自系统日志的电源相关事件。在具体应用级别，该工具可提供各种数据，帮助您识别耗电的应用行为： 过于频繁的触发唤醒提醒（至少每10秒一次）； 持续保留GPS锁定； 至少每30秒调度一次作业； 至少每30秒调度一次同步； 使用手机无线装置的频率高于预期。 依赖GO、Python和Git，拉倒吧~ ","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:7","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#battery-historian工具"},{"categories":[],"content":" Profile工具","date":"2021-08-06","objectID":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/:2:8","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"电量优化","uri":"/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/#profile工具"},{"categories":[],"content":" ANR的概念是指应用程序未响应。 由 ActivityManager 和 WindowManager 两个系统服务进行监视的。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#anr的概念"},{"categories":[],"content":" ANR产生场景 主线程耗时操作 SP 序列化 并发造成死锁，block了主线程 系统资源耗尽 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#anr产生场景"},{"categories":[],"content":" 行为 前台产生ANR弹框询问用户是否等待； 后台产生的ANR直接崩溃。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#行为"},{"categories":[],"content":" 时限 场景 时常 前台服务 20S 后台服务 200S 前台广播 10S 后台广播 60S ContentProvider 10S 输入事件 5S ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#时限"},{"categories":[],"content":" ANR的错误日志 2021-08-04 14:07:55.885 4563-4574/com.vee.myapplication I/e.myapplicatio: Thread[7,tid=4574,WaitingInMainSignalCatcherLoop,Thread*=0x7250d39c00,peer=0x167402a0,\"Signal Catcher\"]: reacting to signal 3 2021-08-04 14:07:56.015 4563-4574/com.vee.myapplication I/e.myapplicatio: Wrote stack traces to tombstoned 2021-08-04 14:08:07.027 4563-4563/com.vee.myapplication I/Choreographer: Skipped 1202 frames! The application may be doing too much work on its main thread. 最重要的一句话The application may be doing too much work on its main thread. ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#anr的错误日志"},{"categories":[],"content":" ANR的错误日志 2021-08-04 14:07:55.885 4563-4574/com.vee.myapplication I/e.myapplicatio: Thread[7,tid=4574,WaitingInMainSignalCatcherLoop,Thread*=0x7250d39c00,peer=0x167402a0,\"Signal Catcher\"]: reacting to signal 3 2021-08-04 14:07:56.015 4563-4574/com.vee.myapplication I/e.myapplicatio: Wrote stack traces to tombstoned 2021-08-04 14:08:07.027 4563-4563/com.vee.myapplication I/Choreographer: Skipped 1202 frames! The application may be doing too much work on its main thread. 最重要的一句话The application may be doing too much work on its main thread. ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#最重要的一句话"},{"categories":[],"content":" trace文件位置： data/anr/traces_*.txt 找到firstPid，即发生ANR的进程id。 trace包含ANR的时间点和CPU使用率、主线程状态、其他线程状态等重要信息。 但是5.0之后会被selinux挡住，获取不到。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:6","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#trace文件"},{"categories":[],"content":" 墓碑文件看log中间的一条 Wrote stack traces to tombstoned ，意思已经把对战追踪写入了墓碑文件。墓碑文件没有读写权限。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:7","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#墓碑文件"},{"categories":[],"content":" 线上监控线上监控的难点就在于，前台发生的ANR没有崩溃 FileObserver此方案基本不能用了。 原理是监控 /data/anr 文件夹的变化，然后判断pid。 BlockCanary由于Android是基于消息驱动的，在Loop.loop()方法中： public static void loop(){ ... for(;;){ Message msg = queue.next(); if(logging != null){ logging.print(\"\u003e\u003e\u003e\u003eDispatching to\"+msg.target+msg.what); } msg.target.dispatchMessage(msg); } } 根据 queue.next() 与 msg.target.dispatchMessage(msg) 的时间差来判断是否发生ANR，做法是自定义一个looging传进去： Looper.getMainLooper.setMessageLogging(myLogging); 通过重写 print 方法加入我们自己的逻辑。 问题：logging有可能被改成null，反而造成NPE问题。 SafeLooper反射hook主线程的looper，接管功能，插入时间差判断，但反射导致大量性能损耗。 仿WatchDog启动一个守护线程，先向主线程发送一个消息，再通过 handler.postDelay() 休眠，而delay时间就是ANR的阈值，delay到期后判断主线程是否确实收到消息。 微信的解决方案腾讯Matrix for Android对ANR监控的原理 看完这篇文章，让我深深的认识到了什么是差距，什么是价值。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:8","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#线上监控"},{"categories":[],"content":" 线上监控线上监控的难点就在于，前台发生的ANR没有崩溃 FileObserver此方案基本不能用了。 原理是监控 /data/anr 文件夹的变化，然后判断pid。 BlockCanary由于Android是基于消息驱动的，在Loop.loop()方法中： public static void loop(){ ... for(;;){ Message msg = queue.next(); if(logging != null){ logging.print(\"\u003e\u003e\u003e\u003eDispatching to\"+msg.target+msg.what); } msg.target.dispatchMessage(msg); } } 根据 queue.next() 与 msg.target.dispatchMessage(msg) 的时间差来判断是否发生ANR，做法是自定义一个looging传进去： Looper.getMainLooper.setMessageLogging(myLogging); 通过重写 print 方法加入我们自己的逻辑。 问题：logging有可能被改成null，反而造成NPE问题。 SafeLooper反射hook主线程的looper，接管功能，插入时间差判断，但反射导致大量性能损耗。 仿WatchDog启动一个守护线程，先向主线程发送一个消息，再通过 handler.postDelay() 休眠，而delay时间就是ANR的阈值，delay到期后判断主线程是否确实收到消息。 微信的解决方案腾讯Matrix for Android对ANR监控的原理 看完这篇文章，让我深深的认识到了什么是差距，什么是价值。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:8","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#fileobserver"},{"categories":[],"content":" 线上监控线上监控的难点就在于，前台发生的ANR没有崩溃 FileObserver此方案基本不能用了。 原理是监控 /data/anr 文件夹的变化，然后判断pid。 BlockCanary由于Android是基于消息驱动的，在Loop.loop()方法中： public static void loop(){ ... for(;;){ Message msg = queue.next(); if(logging != null){ logging.print(\"\u003e\u003e\u003e\u003eDispatching to\"+msg.target+msg.what); } msg.target.dispatchMessage(msg); } } 根据 queue.next() 与 msg.target.dispatchMessage(msg) 的时间差来判断是否发生ANR，做法是自定义一个looging传进去： Looper.getMainLooper.setMessageLogging(myLogging); 通过重写 print 方法加入我们自己的逻辑。 问题：logging有可能被改成null，反而造成NPE问题。 SafeLooper反射hook主线程的looper，接管功能，插入时间差判断，但反射导致大量性能损耗。 仿WatchDog启动一个守护线程，先向主线程发送一个消息，再通过 handler.postDelay() 休眠，而delay时间就是ANR的阈值，delay到期后判断主线程是否确实收到消息。 微信的解决方案腾讯Matrix for Android对ANR监控的原理 看完这篇文章，让我深深的认识到了什么是差距，什么是价值。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:8","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#blockcanary"},{"categories":[],"content":" 线上监控线上监控的难点就在于，前台发生的ANR没有崩溃 FileObserver此方案基本不能用了。 原理是监控 /data/anr 文件夹的变化，然后判断pid。 BlockCanary由于Android是基于消息驱动的，在Loop.loop()方法中： public static void loop(){ ... for(;;){ Message msg = queue.next(); if(logging != null){ logging.print(\"\u003e\u003e\u003e\u003eDispatching to\"+msg.target+msg.what); } msg.target.dispatchMessage(msg); } } 根据 queue.next() 与 msg.target.dispatchMessage(msg) 的时间差来判断是否发生ANR，做法是自定义一个looging传进去： Looper.getMainLooper.setMessageLogging(myLogging); 通过重写 print 方法加入我们自己的逻辑。 问题：logging有可能被改成null，反而造成NPE问题。 SafeLooper反射hook主线程的looper，接管功能，插入时间差判断，但反射导致大量性能损耗。 仿WatchDog启动一个守护线程，先向主线程发送一个消息，再通过 handler.postDelay() 休眠，而delay时间就是ANR的阈值，delay到期后判断主线程是否确实收到消息。 微信的解决方案腾讯Matrix for Android对ANR监控的原理 看完这篇文章，让我深深的认识到了什么是差距，什么是价值。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:8","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#safelooper"},{"categories":[],"content":" 线上监控线上监控的难点就在于，前台发生的ANR没有崩溃 FileObserver此方案基本不能用了。 原理是监控 /data/anr 文件夹的变化，然后判断pid。 BlockCanary由于Android是基于消息驱动的，在Loop.loop()方法中： public static void loop(){ ... for(;;){ Message msg = queue.next(); if(logging != null){ logging.print(\"\u003e\u003e\u003e\u003eDispatching to\"+msg.target+msg.what); } msg.target.dispatchMessage(msg); } } 根据 queue.next() 与 msg.target.dispatchMessage(msg) 的时间差来判断是否发生ANR，做法是自定义一个looging传进去： Looper.getMainLooper.setMessageLogging(myLogging); 通过重写 print 方法加入我们自己的逻辑。 问题：logging有可能被改成null，反而造成NPE问题。 SafeLooper反射hook主线程的looper，接管功能，插入时间差判断，但反射导致大量性能损耗。 仿WatchDog启动一个守护线程，先向主线程发送一个消息，再通过 handler.postDelay() 休眠，而delay时间就是ANR的阈值，delay到期后判断主线程是否确实收到消息。 微信的解决方案腾讯Matrix for Android对ANR监控的原理 看完这篇文章，让我深深的认识到了什么是差距，什么是价值。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:8","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#仿watchdog"},{"categories":[],"content":" 线上监控线上监控的难点就在于，前台发生的ANR没有崩溃 FileObserver此方案基本不能用了。 原理是监控 /data/anr 文件夹的变化，然后判断pid。 BlockCanary由于Android是基于消息驱动的，在Loop.loop()方法中： public static void loop(){ ... for(;;){ Message msg = queue.next(); if(logging != null){ logging.print(\"\u003e\u003e\u003e\u003eDispatching to\"+msg.target+msg.what); } msg.target.dispatchMessage(msg); } } 根据 queue.next() 与 msg.target.dispatchMessage(msg) 的时间差来判断是否发生ANR，做法是自定义一个looging传进去： Looper.getMainLooper.setMessageLogging(myLogging); 通过重写 print 方法加入我们自己的逻辑。 问题：logging有可能被改成null，反而造成NPE问题。 SafeLooper反射hook主线程的looper，接管功能，插入时间差判断，但反射导致大量性能损耗。 仿WatchDog启动一个守护线程，先向主线程发送一个消息，再通过 handler.postDelay() 休眠，而delay时间就是ANR的阈值，delay到期后判断主线程是否确实收到消息。 微信的解决方案腾讯Matrix for Android对ANR监控的原理 看完这篇文章，让我深深的认识到了什么是差距，什么是价值。 ","date":"2021-08-04","objectID":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:8","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"ANR问题解决","uri":"/anr%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#微信的解决方案"},{"categories":[],"content":" SystraceSystrace 是Android平台提供的一款工具，用于记录短期内的设备活动。该工具会生成一份报告，其中汇总了Android 内核中的数据，例如 CPU 调度程序、磁盘活动和应用线程。Systrace主要用来分析绘制性能方面的问题。在发生卡顿时，通过这份报告可以知道当前整个系统所处的状态，从而帮助开发者更直观的分析系统瓶颈，改进性能。 需要安装Python，好吧，滚！ ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#systrace"},{"categories":[],"content":" 过度渲染 布局层级优化开发者工具中开启页面过度绘制监控，在屏幕上用颜色冷暖色调来监控绘制次数。 使用Layout Inspector工具可以直观的检查布局层级。 ConstraintLayout减少嵌套； merge标签重用父级布局； ViewStub懒加载不需要立即显示的视图元素。 背景优化去除不必要的背景，比如部分Activity、fragment中存在背景图片，但是并不可见，就需要移除。 减少alpha的使用对于不透明的View，只需要绘制一次即可，但是如果这个View设置了Alpha，则至少需要两次绘制。 解决方法是减少透明View的使用，或者直接使用ARGB替代。 复杂页面异步处理需要用到AsyncLayoutInflater类： dependencies { implementation \"androidx.asynclayoutinflater:asynclayoutinflater:1.0.0\" } 使用： new AsyncLayoutInflater(this) .inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() { @Override public void onInflateFinished(@NonNull View view, int resid, @Nullable ViewGroup parent) { setContentView(view); //...... } }); GC优化由于Java的回收机制是stop the world，所以一旦发生GC就会挂起所有的线程，包括主线程，这就造成了UI的卡顿。为避免这种情况，需要尽可能少的发生GC，那么就要禁止在循环或者递归中创建无用的临时变量。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#过度渲染"},{"categories":[],"content":" 过度渲染 布局层级优化开发者工具中开启页面过度绘制监控，在屏幕上用颜色冷暖色调来监控绘制次数。 使用Layout Inspector工具可以直观的检查布局层级。 ConstraintLayout减少嵌套； merge标签重用父级布局； ViewStub懒加载不需要立即显示的视图元素。 背景优化去除不必要的背景，比如部分Activity、fragment中存在背景图片，但是并不可见，就需要移除。 减少alpha的使用对于不透明的View，只需要绘制一次即可，但是如果这个View设置了Alpha，则至少需要两次绘制。 解决方法是减少透明View的使用，或者直接使用ARGB替代。 复杂页面异步处理需要用到AsyncLayoutInflater类： dependencies { implementation \"androidx.asynclayoutinflater:asynclayoutinflater:1.0.0\" } 使用： new AsyncLayoutInflater(this) .inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() { @Override public void onInflateFinished(@NonNull View view, int resid, @Nullable ViewGroup parent) { setContentView(view); //...... } }); GC优化由于Java的回收机制是stop the world，所以一旦发生GC就会挂起所有的线程，包括主线程，这就造成了UI的卡顿。为避免这种情况，需要尽可能少的发生GC，那么就要禁止在循环或者递归中创建无用的临时变量。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#布局层级优化"},{"categories":[],"content":" 过度渲染 布局层级优化开发者工具中开启页面过度绘制监控，在屏幕上用颜色冷暖色调来监控绘制次数。 使用Layout Inspector工具可以直观的检查布局层级。 ConstraintLayout减少嵌套； merge标签重用父级布局； ViewStub懒加载不需要立即显示的视图元素。 背景优化去除不必要的背景，比如部分Activity、fragment中存在背景图片，但是并不可见，就需要移除。 减少alpha的使用对于不透明的View，只需要绘制一次即可，但是如果这个View设置了Alpha，则至少需要两次绘制。 解决方法是减少透明View的使用，或者直接使用ARGB替代。 复杂页面异步处理需要用到AsyncLayoutInflater类： dependencies { implementation \"androidx.asynclayoutinflater:asynclayoutinflater:1.0.0\" } 使用： new AsyncLayoutInflater(this) .inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() { @Override public void onInflateFinished(@NonNull View view, int resid, @Nullable ViewGroup parent) { setContentView(view); //...... } }); GC优化由于Java的回收机制是stop the world，所以一旦发生GC就会挂起所有的线程，包括主线程，这就造成了UI的卡顿。为避免这种情况，需要尽可能少的发生GC，那么就要禁止在循环或者递归中创建无用的临时变量。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#背景优化"},{"categories":[],"content":" 过度渲染 布局层级优化开发者工具中开启页面过度绘制监控，在屏幕上用颜色冷暖色调来监控绘制次数。 使用Layout Inspector工具可以直观的检查布局层级。 ConstraintLayout减少嵌套； merge标签重用父级布局； ViewStub懒加载不需要立即显示的视图元素。 背景优化去除不必要的背景，比如部分Activity、fragment中存在背景图片，但是并不可见，就需要移除。 减少alpha的使用对于不透明的View，只需要绘制一次即可，但是如果这个View设置了Alpha，则至少需要两次绘制。 解决方法是减少透明View的使用，或者直接使用ARGB替代。 复杂页面异步处理需要用到AsyncLayoutInflater类： dependencies { implementation \"androidx.asynclayoutinflater:asynclayoutinflater:1.0.0\" } 使用： new AsyncLayoutInflater(this) .inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() { @Override public void onInflateFinished(@NonNull View view, int resid, @Nullable ViewGroup parent) { setContentView(view); //...... } }); GC优化由于Java的回收机制是stop the world，所以一旦发生GC就会挂起所有的线程，包括主线程，这就造成了UI的卡顿。为避免这种情况，需要尽可能少的发生GC，那么就要禁止在循环或者递归中创建无用的临时变量。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#减少alpha的使用"},{"categories":[],"content":" 过度渲染 布局层级优化开发者工具中开启页面过度绘制监控，在屏幕上用颜色冷暖色调来监控绘制次数。 使用Layout Inspector工具可以直观的检查布局层级。 ConstraintLayout减少嵌套； merge标签重用父级布局； ViewStub懒加载不需要立即显示的视图元素。 背景优化去除不必要的背景，比如部分Activity、fragment中存在背景图片，但是并不可见，就需要移除。 减少alpha的使用对于不透明的View，只需要绘制一次即可，但是如果这个View设置了Alpha，则至少需要两次绘制。 解决方法是减少透明View的使用，或者直接使用ARGB替代。 复杂页面异步处理需要用到AsyncLayoutInflater类： dependencies { implementation \"androidx.asynclayoutinflater:asynclayoutinflater:1.0.0\" } 使用： new AsyncLayoutInflater(this) .inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() { @Override public void onInflateFinished(@NonNull View view, int resid, @Nullable ViewGroup parent) { setContentView(view); //...... } }); GC优化由于Java的回收机制是stop the world，所以一旦发生GC就会挂起所有的线程，包括主线程，这就造成了UI的卡顿。为避免这种情况，需要尽可能少的发生GC，那么就要禁止在循环或者递归中创建无用的临时变量。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#复杂页面异步处理"},{"categories":[],"content":" 过度渲染 布局层级优化开发者工具中开启页面过度绘制监控，在屏幕上用颜色冷暖色调来监控绘制次数。 使用Layout Inspector工具可以直观的检查布局层级。 ConstraintLayout减少嵌套； merge标签重用父级布局； ViewStub懒加载不需要立即显示的视图元素。 背景优化去除不必要的背景，比如部分Activity、fragment中存在背景图片，但是并不可见，就需要移除。 减少alpha的使用对于不透明的View，只需要绘制一次即可，但是如果这个View设置了Alpha，则至少需要两次绘制。 解决方法是减少透明View的使用，或者直接使用ARGB替代。 复杂页面异步处理需要用到AsyncLayoutInflater类： dependencies { implementation \"androidx.asynclayoutinflater:asynclayoutinflater:1.0.0\" } 使用： new AsyncLayoutInflater(this) .inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() { @Override public void onInflateFinished(@NonNull View view, int resid, @Nullable ViewGroup parent) { setContentView(view); //...... } }); GC优化由于Java的回收机制是stop the world，所以一旦发生GC就会挂起所有的线程，包括主线程，这就造成了UI的卡顿。为避免这种情况，需要尽可能少的发生GC，那么就要禁止在循环或者递归中创建无用的临时变量。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#gc优化"},{"categories":[],"content":" 大招系统在渲染页面前做了三件事： 读取layout.xml 递归解析xml 层层反射生成对象 解决方式： 利用编译时注解处理器，通过java文件生成器（JavaPoet）在编译时生成布局的ViewGroup类，注入到Activity中。 缺点：不能使用merge标签，因为只有在运行时才知道父级使用什么布局。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#大招"},{"categories":[],"content":" 自定义View优化 Draw方法中尽量不要创建对象。 ","date":"2021-08-04","objectID":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/:0:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"UI卡顿与布局优化","uri":"/ui%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#自定义view优化"},{"categories":[],"content":" 回顾启动流程 点击App图标； Launcher进程通过Binder向SystemServer进程发起startActivity请求； SystemServer收到请求后向zygote发起创建进程请求； zygote收到请求fork自己创建新的子进程（App进程）； App进程通过binder向SystemServer进程发起attachApplication请求； SystemServer收到请求后，进行一系列操作后，通过Binder向App进程发送scheduleLauncherActivity请求； App进程收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息； 主线程收到消息后，通过反射创建目标Activity，并调用onCreate方法。 ","date":"2021-08-03","objectID":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Android启动优化","uri":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/#回顾启动流程"},{"categories":[],"content":" 应用启动状态 冷启动：是指应用从头开始启动，系统进程在冷启动后才创建应用进程； 热启动：系统的所有工作就是将Activity带到前台，不需要重新创建、加载和绘制； 温启动： 短时间内重启应用，进程可能未被销毁，直接继续运行，但是需要重走生命周期。 我们一般针对冷启动进行优化。 ","date":"2021-08-03","objectID":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Android启动优化","uri":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/#应用启动状态"},{"categories":[],"content":" 应用启动时间是指从点击到launcher，经过Application到第一个Activity加载渲染完毕的总时间。 所以优化的点有两个： Application的处理速度 MainActivity的加载速度 ","date":"2021-08-03","objectID":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/:0:3","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Android启动优化","uri":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/#应用启动时间"},{"categories":[],"content":" 统计启动时间 通过logcat中对display关键字检索，在启动后有个Displayed+包名+时间段； ActivityManager: Displayed com.android.myexample/.StartupTiming: +3s534ms 通过adb命令： adb shell am start -S -W [packageName]/{activityName} 输出： ThisTime: 415 # 启动所有Activity的耗时 TotalTime: 415 # 表示冷启动的耗时，不包括前一个Activity的pause耗时 WaitTime: 437 #总的耗时，包括前一个Activity的pause耗时和新Activity的启动耗时 通过Profile工具中的CPU性能剖析器。 Call Chart 倒火焰图； flame Chart 火焰图； TopDown 详情试图。 Debug-API： Debug.startMethodTracing() Debug.stopMethodTracing() 通过配置严苛模式 ","date":"2021-08-03","objectID":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/:0:4","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Android启动优化","uri":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/#统计启动时间"},{"categories":[],"content":" 黑白屏处理为MainActivity自定义一个style，设置背景图，如下： \u003cstyle name=\"Theme.App.NoActionBar.Launcher\"\u003e \u003citem name=\"android:windowBackground\"\u003e@drawable/header\u003c/item\u003e \u003c/style\u003e 然后在MainActivity的onCreate方法中把主题再设置回去： class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { setTheme(R.style.Theme_App_NoActionBar) super.onCreate(savedInstanceState) setContent { NewsStory() } } } AsyncLayoutInflater异步加载 ","date":"2021-08-03","objectID":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/:0:5","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"Android启动优化","uri":"/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/#黑白屏处理"},{"categories":[],"content":" Java对象的生命周期 创建 为对象分配内存空间，从父到子依次调用构造函数，构造对象。 应用 对象至少被一个强引用持有。 不可见 当没有强引用时，对象不可见。 不可达 GC开始做可达性分析。 收集 对象被标记不可达对象，等待GC回收。 终结 回收对象，重新分配内存空间。 ","date":"2021-08-03","objectID":"/oom%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"OOM与内存优化","uri":"/oom%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#java对象的生命周期"},{"categories":[],"content":" Java对象的内存布局 对象头 实例数据 对齐填充（非必须） ","date":"2021-08-03","objectID":"/oom%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"OOM与内存优化","uri":"/oom%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#java对象的内存布局"},{"categories":[],"content":" ArrayList性能优化ArrayList由数组构成，在数据结构中叫做“顺序表”或者“线性表”。ArrayList的性能消耗主要在扩容和元素位移上。 增删操作带来的性能损耗性能优化的点，就在add(T t)方法。 add方法在调用时，使用System.arrayCopy()方法，其内部是遍历数组，更改下标，达到后移的效果，这种位移十分消耗性能。 所以ArrayList的add和remove方法非常消耗性能。 解决办法一： 尽量不要调用add(int index,T t)从中间插入，而是从最后add，那么就只有数组扩容，不需要位移。 解决方案二： 用LinkedList替换提高增删效率。在查询之前，转换为ArrayList。 解决方案三： 用Hashmap来替换，hashmap的特点就是增删快，查询也快。 初始化时提高效率因为ArrayList每次扩容固定10个，所以在创建ArrayList时可以设置默认长度为10，以提高第一add操作时的性能消耗。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#arraylist性能优化"},{"categories":[],"content":" ArrayList性能优化ArrayList由数组构成，在数据结构中叫做“顺序表”或者“线性表”。ArrayList的性能消耗主要在扩容和元素位移上。 增删操作带来的性能损耗性能优化的点，就在add(T t)方法。 add方法在调用时，使用System.arrayCopy()方法，其内部是遍历数组，更改下标，达到后移的效果，这种位移十分消耗性能。 所以ArrayList的add和remove方法非常消耗性能。 解决办法一： 尽量不要调用add(int index,T t)从中间插入，而是从最后add，那么就只有数组扩容，不需要位移。 解决方案二： 用LinkedList替换提高增删效率。在查询之前，转换为ArrayList。 解决方案三： 用Hashmap来替换，hashmap的特点就是增删快，查询也快。 初始化时提高效率因为ArrayList每次扩容固定10个，所以在创建ArrayList时可以设置默认长度为10，以提高第一add操作时的性能消耗。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#增删操作带来的性能损耗"},{"categories":[],"content":" ArrayList性能优化ArrayList由数组构成，在数据结构中叫做“顺序表”或者“线性表”。ArrayList的性能消耗主要在扩容和元素位移上。 增删操作带来的性能损耗性能优化的点，就在add(T t)方法。 add方法在调用时，使用System.arrayCopy()方法，其内部是遍历数组，更改下标，达到后移的效果，这种位移十分消耗性能。 所以ArrayList的add和remove方法非常消耗性能。 解决办法一： 尽量不要调用add(int index,T t)从中间插入，而是从最后add，那么就只有数组扩容，不需要位移。 解决方案二： 用LinkedList替换提高增删效率。在查询之前，转换为ArrayList。 解决方案三： 用Hashmap来替换，hashmap的特点就是增删快，查询也快。 初始化时提高效率因为ArrayList每次扩容固定10个，所以在创建ArrayList时可以设置默认长度为10，以提高第一add操作时的性能消耗。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:1","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#初始化时提高效率"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray\u003cint,Object\u003e原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#hashmap性能优化"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#实现"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#怎么解决哈希碰撞"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#大数据量查询优化"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#扩容带来的性能消耗"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#为什么要再put时初始化哈希表"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#为什么一定保证是2的次幂"},{"categories":[],"content":" HashMap性能优化 实现 JDK1.7：数组+链表 JDK1.8：数组+链表+红黑树 怎么解决哈希碰撞使用链表结构来解决哈希碰撞。当出现哈希碰撞时，两个node通过Key取模运算出的index是一样的，就出现了哈希碰撞。此时HashMap会跟进今后顺序，把所有index一致的节点都放到同一个index的链表上，当查询时如果查到对应的index，会继续遍历链表去查找指定的key。 大数据量查询优化当链表长度过长时，性能将明显下降，所以JDK1.8采用红黑树降低了查询时间。 解决方法：重写key的hashCode降低hash冲突概率。 扩容带来的性能消耗如果发生扩容，数组长度会变大，然后会把所有节点重新计算hash值，再重新分布储存。这带来的性能损失是非常大的，所以我们应该尽量避免扩容。 解决方案一： 预估最大容量，阈值=预估值/0.75+1，加1是因为预估值/0.75有可能就是阈值，所以加1主动让他扩容，阔完再用。 为什么要再Put时初始化哈希表避免在全局使用时造成内存浪费，所以采用了一个懒加载策略。 为什么一定保证是2的次幂 SpaceArray原理双数组模型，二分查找。 ","date":"2021-08-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/:0:2","series":["Android性能优化"],"tags":["Android","性能优化"],"title":"数据结构优化","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/#spacearrayintobject原理"},{"categories":[],"content":"xxxx什么垃圾玩意儿，看的头疼","date":"2021-07-28","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"categories":[],"content":" 概述 启动电源时，芯片先从固定位置加载BootLoader并执行； BootLoader拉起linux内核； linux内核启动后加载init.rc并启动init进程； init进程中初始化并启动属性服务并启动Zygote进程； Zygote负责创建JVM，注册JNI，创建服务端Socket，最后启动SystemServer； SS中创建Binder线程池，并启动系统服务，包括AMS和PMS； PMS负责安装APK，AMS则启动Launcher。 ","date":"2021-07-28","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:1","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#概述"},{"categories":[],"content":" 内核空间流程 按下开机键。 加载启动引导程序bootloader到内存并执行。 拉起linux内核，设置缓存，加载驱动. ","date":"2021-07-28","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:2","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#内核空间流程"},{"categories":[],"content":" 用户空间流程 内核启动后，启动init进程(pid=1)调用init的入口main函数。 创建和挂载文件目录。 初始化并启动【属性服务】。 注册子进程信号处理函数，用来处理进程终止信号，防止僵尸进程。 解析init.rc文件，并启动Zygote。 根据不同系统读取不同的init。zygotexx.rc启动zygote进程（孵化器）。 启动SystemServer 创建launcher ","date":"2021-07-28","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:3","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#用户空间流程"},{"categories":[],"content":" Zygote启动流程 创建JVM; 通过JNI调用ZygoteInit这个类的main函数，开始**进入java框架层*(´▽`ʃ♡ƪ)； 创建一个Socket服务端； fork出SystemServer进程（该进程中启动系统服务）； 调用zygote.runSelectLoop死循环，开始监听AMS的请求。 ","date":"2021-07-28","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:4","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#zygote启动流程"},{"categories":[],"content":" SystemServer的处理过程SystemServer 进程用来创建系统服务，如AMS、WMS和PMS等，他的处理过程为： 启动Binder线程池； 创建SystemServerManager，用于对系统服务创建、启动和生命周期管理； 启动系统服务。 这里提取一个关键点：SystemServerManager是用来管理系统服务的。 ","date":"2021-07-28","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:5","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#systemserver的处理过程"},{"categories":[],"content":" Launcher启动过程 SystemServer启动时会同时启动AMS和PackageManagerService； 而PMS启动后会安装APK； AMS会调起Launcher； Launcher在onCreate中渲染应用图标； ","date":"2021-07-28","objectID":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:0:6","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统启动流程","uri":"/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#launcher启动过程"},{"categories":[],"content":"在Android中，启动一个程序，分为【进程启动】和【Activity启动两部分】。","date":"2021-07-27","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","series":["AndroidFramework"],"tags":["Android"],"title":"Android应用启动过程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":[],"content":" 流程图 点击桌面App图标，Launcher通过Binder对AMS发起startActivity请求； AMS接收到请求后，通过Socket向zygote进程发送创建进程的请求； Zygote进程fork自己搞出App进程； App进程，通过Binder向AMS发起attachApplication请求； AMS收到请求后，进行一系列准备工作后，通过binder向App进程发送scheduleLaunchActivity请求； App进程的ApplicationThread收到请求后，通过handler向ActivityThread发送LAUNCH_ACTIVITY消息； ActivityThread收到消息后，通过反射机制创建目标Activity，并回调Activity的onCreate()等生命周期方法。 当onResume执行完毕后UI开始渲染，渲染完毕后，App正式启动完毕。 ","date":"2021-07-27","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:0:1","series":["AndroidFramework"],"tags":["Android"],"title":"Android应用启动过程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/#流程图"},{"categories":[],"content":" 我们主要开发的是App层，但是需要重点了解的是Framework层： ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:0","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#"},{"categories":[],"content":" Java API Framework 名称 功能 ActivityManager 管理各个应用的生命周期 PackageManager 管理所有安装在Android系统中的应用程序 ResourceManager 提供App需要的各种非代码资源 WindowManager 管理所有开启的窗口程序 ViewSystem 构建App的基本组件 ContentProvider 再不同App之间共享数据 LocationManager 提供定位功能 NotificationManager 通知管理 TelephoneManager 电话管理器，管理所有的移动设备功能 ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:1","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#java-api-framework"},{"categories":[],"content":" 系统运行库 Native C/C++Libraries包含Webkit、openGL什么的。 Android Runtime 安卓运行时库 Core Libraries 核心库，提供了java语言核心库的功能，和Android自带的一些语法糖、工具类； AndroidRuntime 安卓运行时，从5.0开始从 Dalvik变更为ART。 两个安卓运行时的区别 Dalvik 允许在有限的内存中同时运行多个虚拟机实例，并且相互隔离，即时一个崩了，也不会影响其他实例，每一个实例都作为一个单独的Linux进程运行。边解释边执行，需要依靠JIT(即时编译器)把字节码转换成机器码，运行效率低； ART 在安装过程中把字节码预编译成机器码，执行效率高。 ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:2","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#系统运行库"},{"categories":[],"content":" 系统运行库 Native C/C++Libraries包含Webkit、openGL什么的。 Android Runtime 安卓运行时库 Core Libraries 核心库，提供了java语言核心库的功能，和Android自带的一些语法糖、工具类； AndroidRuntime 安卓运行时，从5.0开始从 Dalvik变更为ART。 两个安卓运行时的区别 Dalvik 允许在有限的内存中同时运行多个虚拟机实例，并且相互隔离，即时一个崩了，也不会影响其他实例，每一个实例都作为一个单独的Linux进程运行。边解释边执行，需要依靠JIT(即时编译器)把字节码转换成机器码，运行效率低； ART 在安装过程中把字节码预编译成机器码，执行效率高。 ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:2","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#native-cclibraries"},{"categories":[],"content":" 系统运行库 Native C/C++Libraries包含Webkit、openGL什么的。 Android Runtime 安卓运行时库 Core Libraries 核心库，提供了java语言核心库的功能，和Android自带的一些语法糖、工具类； AndroidRuntime 安卓运行时，从5.0开始从 Dalvik变更为ART。 两个安卓运行时的区别 Dalvik 允许在有限的内存中同时运行多个虚拟机实例，并且相互隔离，即时一个崩了，也不会影响其他实例，每一个实例都作为一个单独的Linux进程运行。边解释边执行，需要依靠JIT(即时编译器)把字节码转换成机器码，运行效率低； ART 在安装过程中把字节码预编译成机器码，执行效率高。 ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:2","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#android-runtime-安卓运行时库"},{"categories":[],"content":" 系统运行库 Native C/C++Libraries包含Webkit、openGL什么的。 Android Runtime 安卓运行时库 Core Libraries 核心库，提供了java语言核心库的功能，和Android自带的一些语法糖、工具类； AndroidRuntime 安卓运行时，从5.0开始从 Dalvik变更为ART。 两个安卓运行时的区别 Dalvik 允许在有限的内存中同时运行多个虚拟机实例，并且相互隔离，即时一个崩了，也不会影响其他实例，每一个实例都作为一个单独的Linux进程运行。边解释边执行，需要依靠JIT(即时编译器)把字节码转换成机器码，运行效率低； ART 在安装过程中把字节码预编译成机器码，执行效率高。 ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:2","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#两个安卓运行时的区别"},{"categories":[],"content":" 硬件抽象层其实就类似接口隔离，统一了不同厂商硬件调用的外观。 ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:3","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#硬件抽象层"},{"categories":[],"content":" Linux内核层一个linux系统，并且嵌入了Android专用的各种驱动。 ","date":"2021-07-27","objectID":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/:0:4","series":["AndroidFramework"],"tags":["Android"],"title":"Android系统架构","uri":"/android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#linux内核层"},{"categories":[],"content":"刚刚给接触Android的时候，感觉Activity就类似iOS中的Controller，就是一个个的页面。但是其实并不是这样的，因为Android同一时间并不是只绘制一个页面，比如状态栏，其他应用的toast，悬浮球等等。所以Android中必然存在一种\"管家\"机制，负责管理所有进程的绘制行为，他就是WindowManagerService服务。","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"categories":[],"content":" WindowActivity、Window、DecorView三者一一对应。 ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:1:0","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#window"},{"categories":[],"content":" Window的分类 普通window，z轴范围1~99； 子window，z轴范围1000~1999，需要依附在父window中，比如dialog； 系统window，z轴范围2000~29999，比如状态栏、toast、键盘等。 ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:1:1","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#window的分类"},{"categories":[],"content":" setContentView方法这里直接看Android30版本，AndroidX包下的activity: public class AppCompatActivity extends FragmentActivity implements AppCompatCallback, TaskStackBuilder.SupportParentable, ActionBarDrawerToggle.DelegateProvider { @Override public void setContentView(@LayoutRes int layoutResID) { getDelegate().setContentView(layoutResID); } 我们的Activity重写了AppCompatActivity的onCreate方法，并且直接调用了父级的setContentView方法，这个方法有三个重载： @Override public void setContentView(View view) { getDelegate().setContentView(view); } 重点要看一下这个getDelegate()方法： //单例创建 @NonNull public AppCompatDelegate getDelegate() { if (mDelegate == null) { mDelegate = AppCompatDelegate.create(this, this); } return mDelegate; } @NonNull public static AppCompatDelegate create(@NonNull Activity activity, @Nullable AppCompatCallback callback) { return new AppCompatDelegateImpl(activity, callback); } 每一个Activity对象都持有一个单例的代理对象，setContent其实是由它来完成的。为什么要搞个代理呢？因为不同版本的系统，使用了不同包名下的Activity。 接下来看AppCompatDelegateImpl： @Override public void setContentView(View v) { //确保存在decor ensureSubDecor(); //找到decorView中id为container容器 ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); //清空所有view contentParent.removeAllViews(); //把我们传递的view附加上去 contentParent.addView(v); //回调 mAppCompatWindowCallback.getWrapped().onContentChanged(); } ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:2:0","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#setcontentview方法"},{"categories":[],"content":" 创建SubDecorView在这里可以看出来，每个Activity中都存在一个SubDecorView，并且SubDecorView中存在一个id为’android.R.id.content’的ViewGroup。 继续看它是怎么确保SubDecor的： private void ensureSubDecor() { if (!mSubDecorInstalled) { //根据标志位判断，按需创建Decor mSubDecor = createSubDecor(); ... } } private ViewGroup createSubDecor() { ... // 重点是这里，确保window的存在 ensureWindow(); mWindow.getDecorView(); //根据风格主题从对应的模板填充SubDecorView if (!mWindowNoTitle) { if (mIsFloating) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_dialog_title_material, null); ... } else if (mHasActionBar) { ... subDecor = (ViewGroup) LayoutInflater.from(themedContext) .inflate(R.layout.abc_screen_toolbar, null); ... } } else { if (mOverlayActionMode) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_screen_simple_overlay_action_mode, null); } else { subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null); } } mWindow.setContentView(subDecor); ... } ensureWindow确保Window附加在AppCompatDelegateImpl中，在setContentView的时候，会先检查是否存在DecorView，然后按需创建Decor，在创建Decor的时候又去检查是否持有window，然后按需附加Window。 private void ensureWindow() { if (mWindow == null \u0026\u0026 mHost instanceof Activity) { attachToWindow(((Activity) mHost).getWindow()); } } private void attachToWindow(@NonNull Window window) { ... mWindow = window; } 我追踪(Activity) mHost).getWindow()，发现在setContentView时，window对象已经被创建好了，那么Window是何时创建的呢？ public Window getWindow() { return mWindow; } @UnsupportedAppUsage final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { ... mWindow = new PhoneWindow(this, window, activityConfigCallback); ... } window是Activity在attach的时候创建的，window本身是个接口，它的实现类是PhoneWindow。 mWindow.getDecorView()继续前面的代码往下走，就遇到了这一句。我们已经知道了，这里的window其实就是phoneWindow，然后进入PhoneWindow.java文件中搜索getDecorView()方法： @Override public final @NonNull View getDecorView() { if (mDecor == null || mForceDecorInstall) { installDecor(); } return mDecor; } //创建和配置DecorView private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { //创建DecorView mDecor = generateDecor(-1); ... } else { mDecor.setWindow(this); } ... } protected DecorView generateDecor(int featureId) { ... return new DecorView(context, featureId, this, getAttributes()); } 然后看这个所谓DecorView到底是个啥： public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { private static final String TAG = \"DecorView\"; private static final boolean DEBUG_MEASURE = false; 噔噔噔噔，果然就是个FrameLayout！ ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:2:1","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#创建subdecorview"},{"categories":[],"content":" 创建SubDecorView在这里可以看出来，每个Activity中都存在一个SubDecorView，并且SubDecorView中存在一个id为’android.R.id.content’的ViewGroup。 继续看它是怎么确保SubDecor的： private void ensureSubDecor() { if (!mSubDecorInstalled) { //根据标志位判断，按需创建Decor mSubDecor = createSubDecor(); ... } } private ViewGroup createSubDecor() { ... // 重点是这里，确保window的存在 ensureWindow(); mWindow.getDecorView(); //根据风格主题从对应的模板填充SubDecorView if (!mWindowNoTitle) { if (mIsFloating) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_dialog_title_material, null); ... } else if (mHasActionBar) { ... subDecor = (ViewGroup) LayoutInflater.from(themedContext) .inflate(R.layout.abc_screen_toolbar, null); ... } } else { if (mOverlayActionMode) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_screen_simple_overlay_action_mode, null); } else { subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null); } } mWindow.setContentView(subDecor); ... } ensureWindow确保Window附加在AppCompatDelegateImpl中，在setContentView的时候，会先检查是否存在DecorView，然后按需创建Decor，在创建Decor的时候又去检查是否持有window，然后按需附加Window。 private void ensureWindow() { if (mWindow == null \u0026\u0026 mHost instanceof Activity) { attachToWindow(((Activity) mHost).getWindow()); } } private void attachToWindow(@NonNull Window window) { ... mWindow = window; } 我追踪(Activity) mHost).getWindow()，发现在setContentView时，window对象已经被创建好了，那么Window是何时创建的呢？ public Window getWindow() { return mWindow; } @UnsupportedAppUsage final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { ... mWindow = new PhoneWindow(this, window, activityConfigCallback); ... } window是Activity在attach的时候创建的，window本身是个接口，它的实现类是PhoneWindow。 mWindow.getDecorView()继续前面的代码往下走，就遇到了这一句。我们已经知道了，这里的window其实就是phoneWindow，然后进入PhoneWindow.java文件中搜索getDecorView()方法： @Override public final @NonNull View getDecorView() { if (mDecor == null || mForceDecorInstall) { installDecor(); } return mDecor; } //创建和配置DecorView private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { //创建DecorView mDecor = generateDecor(-1); ... } else { mDecor.setWindow(this); } ... } protected DecorView generateDecor(int featureId) { ... return new DecorView(context, featureId, this, getAttributes()); } 然后看这个所谓DecorView到底是个啥： public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { private static final String TAG = \"DecorView\"; private static final boolean DEBUG_MEASURE = false; 噔噔噔噔，果然就是个FrameLayout！ ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:2:1","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#ensurewindow确保window附加"},{"categories":[],"content":" 创建SubDecorView在这里可以看出来，每个Activity中都存在一个SubDecorView，并且SubDecorView中存在一个id为’android.R.id.content’的ViewGroup。 继续看它是怎么确保SubDecor的： private void ensureSubDecor() { if (!mSubDecorInstalled) { //根据标志位判断，按需创建Decor mSubDecor = createSubDecor(); ... } } private ViewGroup createSubDecor() { ... // 重点是这里，确保window的存在 ensureWindow(); mWindow.getDecorView(); //根据风格主题从对应的模板填充SubDecorView if (!mWindowNoTitle) { if (mIsFloating) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_dialog_title_material, null); ... } else if (mHasActionBar) { ... subDecor = (ViewGroup) LayoutInflater.from(themedContext) .inflate(R.layout.abc_screen_toolbar, null); ... } } else { if (mOverlayActionMode) { subDecor = (ViewGroup) inflater.inflate( R.layout.abc_screen_simple_overlay_action_mode, null); } else { subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null); } } mWindow.setContentView(subDecor); ... } ensureWindow确保Window附加在AppCompatDelegateImpl中，在setContentView的时候，会先检查是否存在DecorView，然后按需创建Decor，在创建Decor的时候又去检查是否持有window，然后按需附加Window。 private void ensureWindow() { if (mWindow == null \u0026\u0026 mHost instanceof Activity) { attachToWindow(((Activity) mHost).getWindow()); } } private void attachToWindow(@NonNull Window window) { ... mWindow = window; } 我追踪(Activity) mHost).getWindow()，发现在setContentView时，window对象已经被创建好了，那么Window是何时创建的呢？ public Window getWindow() { return mWindow; } @UnsupportedAppUsage final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { ... mWindow = new PhoneWindow(this, window, activityConfigCallback); ... } window是Activity在attach的时候创建的，window本身是个接口，它的实现类是PhoneWindow。 mWindow.getDecorView()继续前面的代码往下走，就遇到了这一句。我们已经知道了，这里的window其实就是phoneWindow，然后进入PhoneWindow.java文件中搜索getDecorView()方法： @Override public final @NonNull View getDecorView() { if (mDecor == null || mForceDecorInstall) { installDecor(); } return mDecor; } //创建和配置DecorView private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { //创建DecorView mDecor = generateDecor(-1); ... } else { mDecor.setWindow(this); } ... } protected DecorView generateDecor(int featureId) { ... return new DecorView(context, featureId, this, getAttributes()); } 然后看这个所谓DecorView到底是个啥： public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { private static final String TAG = \"DecorView\"; private static final boolean DEBUG_MEASURE = false; 噔噔噔噔，果然就是个FrameLayout！ ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:2:1","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#mwindowgetdecorview"},{"categories":[],"content":" phoneWiodow.setContentView(resId)然后就是调用了phoneWindow的setContentView(subDecor)方法，这个设计模式很明显是个装饰者模式： @Override public void setContentView(int layoutResID) { if (mContentParent == null) { //检查机制，确保DeecorView一定存在 installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { //播放跳转动画 final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } ... } ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:2:2","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#phonewiodowsetcontentviewresid"},{"categories":[],"content":" 当前的View层级 ","date":"2021-07-26","objectID":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/:2:3","series":["Android运行流程"],"tags":["Android"],"title":"Android页面绘制流程","uri":"/android%E9%A1%B5%E9%9D%A2%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#当前的view层级"},{"categories":[],"content":" 三者之间的区别 Flutter Module：用来把flutter功能作为组件集成到Android或者iOS主项目中； Dart package：纯Dart工程，不包含Platforms，就是一个可以外置的包，里面存放各种类文件; Plugin packages：类似于主工程的插件，可以包含各种Platforms和本土代码。 这个是官方文档上面理所当然的解释，但是事实上，package和plugin就是同一个玩意：包里配置上platforms工程，就成了plugin；而相对的plugin去除掉flatforms之后，那就成了包。但是为啥要区分开呢，因为官方针对同一个东西给出了两种模板而已。 ","date":"2021-07-23","objectID":"/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:0","series":[],"tags":["Flutter"],"title":"Flutter 模块、包和插件(待续...)","uri":"/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/#三者之间的区别"},{"categories":[],"content":" 创建工程 # 创建包 flutter create -t plugin --platforms android --org com.vee plugin_test 采用脚本创建的话，必须要自己指明包含的平台，否则不会创建Android或者iOS的本土代码。比如以上代码，我通过platforms选项，只选择了Android平台，所以flutter生成的项目中也只含有安卓的包，而没有iOS的包。 ","date":"2021-07-23","objectID":"/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:0","series":[],"tags":["Flutter"],"title":"Flutter 模块、包和插件(待续...)","uri":"/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/#创建工程"},{"categories":[],"content":" 通信三种通道： BasicMessageChannel：用于传递字符串和半结构化的信息； MethodChannel：用于传递方法调用（method invocation）； EventChannel: 用于数据流（event streams）的通信。 PS：消息编解码器，是JSON格式的二进制序列化，所以调用方法的参数类型必须是可JSON序列化的。 PS：方法调用，也可以反向发送调用消息。 ","date":"2021-07-23","objectID":"/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:3:0","series":[],"tags":["Flutter"],"title":"Flutter 模块、包和插件(待续...)","uri":"/flutter-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/#通信"},{"categories":[],"content":" 构造函数 initState 初始化状态，只调用一次； didChangeDependencies在initState执行完立刻调用，当依赖的InheritedWidget发生build时也会调用； build画画用的； didUpdateWidget状态改变时调用，如调用了setState函数； deactivate相当于Android的onStop方法； dispose销毁时调用。 ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:0:0","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#"},{"categories":[],"content":" 测试","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:0","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#测试"},{"categories":[],"content":" 页面打开 I/flutter (30299): 调用了initState I/flutter (30299): 调用了didChangeDependencies I/flutter (30299): 调用了build ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:1","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#页面打开"},{"categories":[],"content":" 页面刷新 状态没变测试代码： @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() {}); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 可以看到状态没有变化的时候，是不会调用didUpdateWidget函数的。 状态改变测试1测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() { i = 1; }); }), ), ); } 输出： I/flutter (30299): 调用了initState I/flutter (30299): 调用了didChangeDependencies I/flutter (30299): 调用了build 这里可以看到，我把赋值操作写在setState的回调里面，可以触发调用了didChangeDependencies。 状态改变测试2测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); i = 2; setState(() { }); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 这里可以看到，我把赋值操作**写在setState的回调外面，didChangeDependencies函数就不会触发了。 总结当使用setState方法时： 赋值写在括号里面，可以触发didChangeDependencies函数； 赋值写在括号外面，不能触发didChangeDependencies。 ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:2","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#页面刷新"},{"categories":[],"content":" 页面刷新 状态没变测试代码： @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() {}); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 可以看到状态没有变化的时候，是不会调用didUpdateWidget函数的。 状态改变测试1测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() { i = 1; }); }), ), ); } 输出： I/flutter (30299): 调用了initState I/flutter (30299): 调用了didChangeDependencies I/flutter (30299): 调用了build 这里可以看到，我把赋值操作写在setState的回调里面，可以触发调用了didChangeDependencies。 状态改变测试2测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); i = 2; setState(() { }); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 这里可以看到，我把赋值操作**写在setState的回调外面，didChangeDependencies函数就不会触发了。 总结当使用setState方法时： 赋值写在括号里面，可以触发didChangeDependencies函数； 赋值写在括号外面，不能触发didChangeDependencies。 ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:2","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#状态没变"},{"categories":[],"content":" 页面刷新 状态没变测试代码： @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() {}); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 可以看到状态没有变化的时候，是不会调用didUpdateWidget函数的。 状态改变测试1测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() { i = 1; }); }), ), ); } 输出： I/flutter (30299): 调用了initState I/flutter (30299): 调用了didChangeDependencies I/flutter (30299): 调用了build 这里可以看到，我把赋值操作写在setState的回调里面，可以触发调用了didChangeDependencies。 状态改变测试2测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); i = 2; setState(() { }); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 这里可以看到，我把赋值操作**写在setState的回调外面，didChangeDependencies函数就不会触发了。 总结当使用setState方法时： 赋值写在括号里面，可以触发didChangeDependencies函数； 赋值写在括号外面，不能触发didChangeDependencies。 ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:2","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#状态改变测试1"},{"categories":[],"content":" 页面刷新 状态没变测试代码： @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() {}); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 可以看到状态没有变化的时候，是不会调用didUpdateWidget函数的。 状态改变测试1测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() { i = 1; }); }), ), ); } 输出： I/flutter (30299): 调用了initState I/flutter (30299): 调用了didChangeDependencies I/flutter (30299): 调用了build 这里可以看到，我把赋值操作写在setState的回调里面，可以触发调用了didChangeDependencies。 状态改变测试2测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); i = 2; setState(() { }); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 这里可以看到，我把赋值操作**写在setState的回调外面，didChangeDependencies函数就不会触发了。 总结当使用setState方法时： 赋值写在括号里面，可以触发didChangeDependencies函数； 赋值写在括号外面，不能触发didChangeDependencies。 ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:2","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#状态改变测试2"},{"categories":[],"content":" 页面刷新 状态没变测试代码： @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() {}); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 可以看到状态没有变化的时候，是不会调用didUpdateWidget函数的。 状态改变测试1测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); setState(() { i = 1; }); }), ), ); } 输出： I/flutter (30299): 调用了initState I/flutter (30299): 调用了didChangeDependencies I/flutter (30299): 调用了build 这里可以看到，我把赋值操作写在setState的回调里面，可以触发调用了didChangeDependencies。 状态改变测试2测试代码： ///创建一个变量，通过改变这个变量来改变状态 int i = 0; @override Widget build(BuildContext context) { print('调用了build'); return Scaffold( appBar: AppBar(), body: Container( child: MaterialButton( child: Text('主动刷新页面'), onPressed: () { print('我主动调用了setState'); i = 2; setState(() { }); }), ), ); } 输出： I/flutter (30299): 我主动调用了setState I/flutter (30299): 调用了build 这里可以看到，我把赋值操作**写在setState的回调外面，didChangeDependencies函数就不会触发了。 总结当使用setState方法时： 赋值写在括号里面，可以触发didChangeDependencies函数； 赋值写在括号外面，不能触发didChangeDependencies。 ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:2","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#总结"},{"categories":[],"content":" 页面退出 I/flutter (30299): 调用了deactivate I/flutter (30299): 调用了dispose ","date":"2021-07-23","objectID":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/:1:3","series":[],"tags":["Flutter"],"title":"Flutter的生命周期函数","uri":"/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/#页面退出"},{"categories":[],"content":"以前使用Hexo的时候了解到了Travis这个好东东，应该是我自jenkins之后接触过的第二个CI了，挺有意思。 之前的做法，或者说一般网上的做法，都是只弄一个仓库，然后源码和生成物在不同的分支，包括Travis官文上也是这样写的。这就存在两个问题： Travis只有发布到开源仓库才免费，而发布到私有仓库每月好像要100多美元； 如果发布到开源仓库的不同分支，那我私密性的博客不就源码可见了嘛。 所以我这里采用了两个仓库： 源码仓库，私有，只用来存放源码； 静态文件仓库，开源，只用来存放Hugo的生成物。 .travis.yml language: go go: # 指定Golang 1.8 - \"1.8\" env: global: # 定义一个全局变量 - GH_REF: github.com/vee-zhang/vee-zhang.github.io # 分支白名单限制: 只有master分支的提交才会触发构建 branches: only: # 指定master分支参与构建 - master install: # 安装hugo - wget -q -O hugo.deb https://github.com/gohugoio/hugo/releases/download/v0.86.0/hugo_extended_0.86.0_Linux-64bit.deb - sudo dpkg -i hugo.deb script: # 运行hugo命令 - hugo # git直接推public - cd public - git init - git config user.name \"vee-zhang\" - git config user.password \"$githubtoken\" - git add -A - git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\" - git push --force --quiet \"https://$githubtoken@${GH_REF}\" master:master 我通过各种方法来安装Hugo，包括go get直接安装，clone源码然后go install编译安装，都报错失败了。最后从网上查到竟然可以使用wget下载成品！！！ 但是这样以来确定也很明显，就是Hugo不能自动更新了。留待以后解决吧。 ","date":"2021-07-22","objectID":"/travis%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83hugo%E5%8D%9A%E5%AE%A2/:0:0","series":[],"tags":["Travis","Hugo"],"title":"Travis持续发布Hugo博客","uri":"/travis%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83hugo%E5%8D%9A%E5%AE%A2/#"},{"categories":[],"content":" 添加Travis构建结果图标 \u003cimg src=\"https://www.travis-ci.com/vee-zhang/VeeBlogSourceCode.svg?token=zr2k46J9vsyyAMcKzMGx\u0026amp;branch=master\u0026amp;status=passed\" alt=\"build:passed\"\u003e 鸣谢： qq_43103581 ","date":"2021-07-22","objectID":"/travis%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83hugo%E5%8D%9A%E5%AE%A2/:1:0","series":[],"tags":["Travis","Hugo"],"title":"Travis持续发布Hugo博客","uri":"/travis%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83hugo%E5%8D%9A%E5%AE%A2/#添加travis构建结果图标"},{"categories":[],"content":" Future 未来的一次回调Future位于event queue事件队列中。 Future表示未来的一次性的任务回调。 ","date":"2021-07-21","objectID":"/dart-future%E5%92%8Cstream/:1:0","series":[],"tags":["Dart"],"title":"Dart-Future和Stream","uri":"/dart-future%E5%92%8Cstream/#future-未来的一次回调"},{"categories":[],"content":" wait方法类似RxJava中的zip操作符： final futures = [ Future.delayed(Duration(seconds: 3)), Future.delayed(Duration(seconds: 5)) ]; Future.wait(futures) .then((value) =\u003e print('拿到值：$value')); ","date":"2021-07-21","objectID":"/dart-future%E5%92%8Cstream/:1:1","series":[],"tags":["Dart"],"title":"Dart-Future和Stream","uri":"/dart-future%E5%92%8Cstream/#wait方法"},{"categories":[],"content":" Stream 持续监听Stream是持续性监听，所以就必须要在不需要的时候手动释放。 final stream = File('').openRead(); //订阅 final listener = stream.listen((event) { //启动监听 }); //转换成Future Future future = listener.asFuture(); //暂停 listener.pause(); //暂停恢复 listener.resume(); //取消 listener.cancel(); ","date":"2021-07-21","objectID":"/dart-future%E5%92%8Cstream/:2:0","series":[],"tags":["Dart"],"title":"Dart-Future和Stream","uri":"/dart-future%E5%92%8Cstream/#stream-持续监听"},{"categories":[],"content":" Stream的订阅与广播 订阅Stream默认就是单订阅模式。如果重复调用listen()方法就会报错，比如： final stream = File('').openRead(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 报错： 广播模式广播模式允许多订阅。可以把订阅模式转为广播模式： final stream = File('').openRead(); stream.asBroadcastStream(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 也可以通过StreamController直接创建广播： final streamController = StreamController.broadcast(); streamController.stream.listen((event) { // todo 回调 }); streamController.add('value'); streamController.close(); StreamSink","date":"2021-07-21","objectID":"/dart-future%E5%92%8Cstream/:2:1","series":[],"tags":["Dart"],"title":"Dart-Future和Stream","uri":"/dart-future%E5%92%8Cstream/#stream的订阅与广播"},{"categories":[],"content":" Stream的订阅与广播 订阅Stream默认就是单订阅模式。如果重复调用listen()方法就会报错，比如： final stream = File('').openRead(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 报错： 广播模式广播模式允许多订阅。可以把订阅模式转为广播模式： final stream = File('').openRead(); stream.asBroadcastStream(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 也可以通过StreamController直接创建广播： final streamController = StreamController.broadcast(); streamController.stream.listen((event) { // todo 回调 }); streamController.add('value'); streamController.close(); StreamSink","date":"2021-07-21","objectID":"/dart-future%E5%92%8Cstream/:2:1","series":[],"tags":["Dart"],"title":"Dart-Future和Stream","uri":"/dart-future%E5%92%8Cstream/#订阅"},{"categories":[],"content":" Stream的订阅与广播 订阅Stream默认就是单订阅模式。如果重复调用listen()方法就会报错，比如： final stream = File('').openRead(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 报错： 广播模式广播模式允许多订阅。可以把订阅模式转为广播模式： final stream = File('').openRead(); stream.asBroadcastStream(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 也可以通过StreamController直接创建广播： final streamController = StreamController.broadcast(); streamController.stream.listen((event) { // todo 回调 }); streamController.add('value'); streamController.close(); StreamSink","date":"2021-07-21","objectID":"/dart-future%E5%92%8Cstream/:2:1","series":[],"tags":["Dart"],"title":"Dart-Future和Stream","uri":"/dart-future%E5%92%8Cstream/#广播模式"},{"categories":[],"content":" Stream的订阅与广播 订阅Stream默认就是单订阅模式。如果重复调用listen()方法就会报错，比如： final stream = File('').openRead(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 报错： 广播模式广播模式允许多订阅。可以把订阅模式转为广播模式： final stream = File('').openRead(); stream.asBroadcastStream(); //订阅 final listener = stream.listen((event) { //启动监听 }); final listener1 = stream.listen((event) {}); 也可以通过StreamController直接创建广播： final streamController = StreamController.broadcast(); streamController.stream.listen((event) { // todo 回调 }); streamController.add('value'); streamController.close(); StreamSink","date":"2021-07-21","objectID":"/dart-future%E5%92%8Cstream/:2:1","series":[],"tags":["Dart"],"title":"Dart-Future和Stream","uri":"/dart-future%E5%92%8Cstream/#streamsink"},{"categories":[],"content":" Dart的消息队列机制Dart像Android一样，是基于消息驱动的. 依靠eventLoop不停的从队列中获取消息或者事件来驱动整个应用的运行，包括isolate发送过来的消息就是通过Loop处理。 看起来很像Android中的handler+looper+msg机制。 但是不同的是，Android中每个线程只有一个looper对应一个一个MessageQueue，但是dart中存在两个队列： event queue事件队列； microtask queue微服务队列。 ","date":"2021-07-21","objectID":"/dart-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:1:0","series":[],"tags":["Dart"],"title":"Dart-任务队列","uri":"/dart-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/#dart的消息队列机制"},{"categories":[],"content":" Dart的消息传递过程 Dart在执行完main方法后，就会由loop开始执行两个任务队列中event。 loop会先执行完所有的微服务队列中的所有event，再去执行事件队列中的一个事件，one by one，所以微服务队列的优先级高于事件队列，我们可以利用这项特性来插队： eg:打印文件内容 import 'dart:io'; void main(){ new File(\"/Users/enjoy/a.txt\").readAsString().then((content){ print(content); }); //死循环造成阻塞 while(true){} } 文件内容永远也无法打印出来，因为main函数还没执行完。而then方法是由Loop检查Event queue执行的。 如果需要往微服务中插入Event进行插队： import 'dart:async'; import 'dart:io'; //结果是先执行了microtask然后执行then方法。 void main(){ new File(\"/Users/enjoy/a.txt\").readAsString().then((content){ print(content); }); //future内部就是调用了 scheduleMicrotask Future.microtask((){ print(\"future: excute microtask\"); }); // scheduleMicrotask((){ // print(\"\"); // }); } 注意：如果微服务中出现阻塞，那么两个队列中所有的后续任务都不会执行，也是因为单线程模型导致。 ","date":"2021-07-21","objectID":"/dart-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:2:0","series":[],"tags":["Dart"],"title":"Dart-任务队列","uri":"/dart-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/#dart的消息传递过程"},{"categories":["technology"],"content":"事情的起因是，在工作项目中，一开始只有我一个人研发，为了方便，我封装了一个网络访问层。但是随着团队规模的拓展，陆续加入了其他人，时间紧项目重，所以后续的伙伴没有时间来问我这个框架怎么使用，所以他们直接上手改了我的封装！但是后期架构要求加入oauth2.0机制，所以需要全局处理token的有效认证，并且自动刷新token。为了满足这一需求，我需要重新编写网络层，同时为了避免伙伴修改我的抽象，我想到了本文的主题——搭建个pub.dev私服吧！ ","date":"2021-07-15","objectID":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/:0:0","series":[],"tags":["flutter"],"title":"搭建pub私服及上传package","uri":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/#"},{"categories":["technology"],"content":" server配置首先到我的码云clone个项目下来,然后习惯性flutter pub get。 接下来修改配置，修改pub_server/example/src/example.dart文件,找到argsParser()： ArgParser argsParser() { var parser = ArgParser(); parser.addOption('directory', abbr: 'd', defaultsTo: 'pub_server-repository-data'); //host地址 parser.addOption('host', abbr: 'h', defaultsTo: 'localhost'); //端口号 parser.addOption('port', abbr: 'p', defaultsTo: '8080'); // 运行模式 parser.addFlag('standalone', abbr: 's', defaultsTo: false); return parser; } 由于我的8080端口已经被jenkies占用了，所以只能把pub的端口改为9090。要注意的是，host默认是localhost，只支持本机访问，如果我们要挂到服务上，需要把这里改为0.0.0.0之后，我们才能通过ip或者域名访问服务。 然后启动服务： dart example/example.dart -d /tmp/package-db 如果出现「To make the pub client use this repository configure…」表示服务启动成功！ ","date":"2021-07-15","objectID":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/:1:0","series":[],"tags":["flutter"],"title":"搭建pub私服及上传package","uri":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/#server配置"},{"categories":["technology"],"content":" 创建测试package怎么创建，不说了，这里只贴出yaml文件： name: lk_dio description: 用于来康科技公司的网络请求层封装，包括平台、大脑的接口调用规则和token有效期验证及自动刷新机制。 version: 0.0.2 author: William \u003c自己的邮箱@enn.cn\u003e homepage: 'http://项目主页地址.com' publish_to: 'http://localhost:9090' environment: sdk: \"\u003e=2.7.0 \u003c3.0.0\" flutter: \"\u003e=1.17.0\" dependencies: flutter: sdk: flutter dev_dependencies: flutter_test: sdk: flutter flutter: 配置好之后,可以在本地直接依赖： lk_dio: path: user/william/lk_dio 当然也可以发布到我们的pub私服上，发布之前可以通过命令检查错误： flutter packages pub publish --dry-run 按照提示解决问题，然后发布： flutter packages pub publish 出现如下信息表明发布成功： |-- lib | '-- helloworld.dart |-- pubspec.yaml '-- test '-- helloworld_test.dart Looks great! Are you ready to upload your package (y/n)? y Uploading... Successfully uploaded package. 但是如果不FQ，是一定不会成功的，你看到的将是如下信息： Pub needs your authorization to upload packages on your behalf. 失败的原因就是需要google的认证，怎么办，fq? 有没有更好的办法？ ","date":"2021-07-15","objectID":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/:2:0","series":[],"tags":["flutter"],"title":"搭建pub私服及上传package","uri":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/#创建测试package"},{"categories":["technology"],"content":" 绕过google认证再clone这个项目之后flutter pub get，然后执行： dart --snapshot=mypub.dart.snapshot bin/pub.dart 完事后会自动生成一个mypub.dart.snapshot。 复制之后放入${flutterSDK Path}/bin/cache/dart-sdk/bin/snapshots/ 目录下 用txt编辑器打开${flutterSDK Path}/bin/cache/dart-sdk/bin/pub文件，将倒数第三行的：pub.dart.snapshot 替换为 mypub.dart.snapshot,然后重新发布package就OK了。 ","date":"2021-07-15","objectID":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/:3:0","series":[],"tags":["flutter"],"title":"搭建pub私服及上传package","uri":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/#绕过google认证"},{"categories":["technology"],"content":" 依赖自己的package lk_dio:#这里要与之前一致 hosted: name: lk_dio #这里要与之前一致 url: http://localhost:9090 version: ^1.0.0 添加了依赖之后，我flutter pub get，本机没问题，项目正常跑，万分激动，但是。。。 当我把server发布到公司服务器后，**publish失败！**经查，是运维没有开放9090端口，找过运维之后问题解决。 然后我再添加依赖，运行pub get，竟然卡住不动了，内心瞬间一万只草泥马德，上传可以下载就不行怪了！后来发现server的配置文件中有个配置： // 运行模式 parser.addFlag('standalone', abbr: 's', defaultsTo: false); standalone好像是独立部署的意思。 把这里的defaultTo的值改为true,重新部署、启动，再重新下载依赖pub get，等等足足71秒后竟然成功了！后来运维解释，之所以这么慢是因为从北京访问我们盐城的服务器，而且没有CDN加速。 ","date":"2021-07-15","objectID":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/:4:0","series":[],"tags":["flutter"],"title":"搭建pub私服及上传package","uri":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/#依赖自己的package"},{"categories":["technology"],"content":" 鸣谢：https://www.jianshu.com/p/59f4778864f0 ","date":"2021-07-15","objectID":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/:5:0","series":[],"tags":["flutter"],"title":"搭建pub私服及上传package","uri":"/%E6%90%AD%E5%BB%BApub%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/#鸣谢"},{"categories":null,"content":" 关于我","date":"2021-07-15","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/#关于我"},{"categories":null,"content":" /bin： bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc： etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home： 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 /lib： lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media： linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt： opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc： proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： echo 1 \u003e /proc/sys/net/ipv4/icmp_echo_ignore_all /root： 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin： s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 /sys： 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。 sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp： tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var： var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。 值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里 ","date":"2021-07-15","objectID":"/linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":null,"title":"linux目录结构","uri":"/linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/#"},{"categories":null,"content":"自定义ViewGroup与自定义View不同，一般不需要重写onDraw，而是需要重写onLayout。 import android.content.Context import android.util.AttributeSet import android.util.Log import android.view.MotionEvent import android.view.View import android.view.ViewGroup import kotlin.math.max class MyViewGroup(context: Context, attrs: AttributeSet?, defStyleAttr: Int, defStyleRes: Int) : ViewGroup(context, attrs, defStyleAttr, defStyleRes) { constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : this(context, attrs, defStyleAttr, 0) constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0) constructor(context: Context) : this(context, null) private val TAG = \"测试\" override fun generateLayoutParams(attrs: AttributeSet?): LayoutParams { return MarginLayoutParams(context, attrs) } override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { //测量子view measureChildren(widthMeasureSpec, heightMeasureSpec) var width1 = 0 var width2 = 0 var height1 = 0 var height2 = 0 var child: View var childWidth: Int var childHeight: Int var childLp: LayoutParams //叠加所有子View的宽高 for (i in 0 until childCount) { child = getChildAt(i) childWidth = child.measuredWidth childHeight = child.measuredHeight childLp = child.layoutParams as MarginLayoutParams if (i \u003c 2) { width1 += childWidth + childLp.leftMargin + childLp.rightMargin height1 += childHeight + childLp.topMargin + childLp.bottomMargin } else { width2 += childWidth + childLp.leftMargin + childLp.rightMargin height2 += childHeight + childLp.topMargin + childLp.bottomMargin } } // 获取父容器推荐的尺寸 val widthMode = MeasureSpec.getMode(widthMeasureSpec) val measureWidth = MeasureSpec.getSize(widthMeasureSpec) val heightMode = MeasureSpec.getMode(heightMeasureSpec) val measureHeight = MeasureSpec.getSize(heightMeasureSpec) // 根据情况计算出可容纳所有child的尺寸 val width = if (widthMode == MeasureSpec.EXACTLY) measureWidth else max(width1, width2) val height = if (heightMode == MeasureSpec.EXACTLY) measureHeight else max(height1, height2) setMeasuredDimension(width, height) } override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) { var childLp: LayoutParams var child: View var cl: Int var ct: Int var cr: Int var cb: Int // 依次为所有的child布局 for (i in 0 until childCount) { child = getChildAt(i) childLp = child.layoutParams as MarginLayoutParams when (i) { 0 -\u003e { cl = 0 + childLp.leftMargin ct = 0 + childLp.topMargin } 1 -\u003e { cl = width - child.measuredWidth - childLp.leftMargin - childLp.rightMargin ct = 0 + childLp.topMargin } 2 -\u003e { cl = 0 + childLp.leftMargin ct = height - child.measuredHeight - childLp.topMargin - childLp.bottomMargin } else -\u003e { cl = width - child.measuredWidth - childLp.leftMargin - childLp.rightMargin ct = height - child.measuredHeight - childLp.topMargin - childLp.bottomMargin } } cr = cl + child.measuredWidth cb = ct + child.measuredHeight //布局 child.layout(cl, ct, cr, cb) } } } ","date":"2021-07-12","objectID":"/android%E8%87%AA%E5%AE%9A%E4%B9%89viewgroup/:0:0","series":null,"tags":["Android"],"title":"Android自定义ViewGroup","uri":"/android%E8%87%AA%E5%AE%9A%E4%B9%89viewgroup/#"},{"categories":null,"content":" 用途读取.class文件的字节码并加载成内存形式的类对象。 ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:1:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#用途"},{"categories":null,"content":" 边解释边执行JVM并不是一次性加载全部的类，而是需要用到才会去加载。比如加载了类，但是不会去加载类里面定义的对象类型的字段的类，因为暂时用不到。 ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:2:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#边解释边执行"},{"categories":null,"content":" Java内置的ClassLoader BootstrapClassLoader 负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.xxx.* 都在里面，比如 java.util.、java.io.、java.nio.、java.lang. 等等。这个 ClassLoader 比较特殊，它是由 C 代码实现的，我们将它称之为「根加载器」。 ExtensionClassLoader 负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，有很多 jar 包。 AppClassLoader 这才是直接面向我们用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。 URLClassLoader 专门用来加载位于网络上静态文件服务器提供的 jar 包和 class文件。 ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:3:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#java内置的classloader"},{"categories":null,"content":" ClassLoader的选择当我们定义一个ClassLoader，其内部都包含了一个ClassLoader，当遇到未知的类，JVM会选择调用者自己的ClassLoader去加载。 那么最初的调用者一定是持有main()方法的类，他持有的是AppClassLoader。 ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:4:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#classloader的选择"},{"categories":null,"content":" 双亲委派AppClassLoader只负责加载Classpath下面的类秒如果遇到没有加载过的系统类，他会将系统类库的加载工作交给BootstrapClassLoader和ExtensionClassLoader来做，这就叫双亲委派。 每个ClassLoader中都有一个parent属性指向父级，然后会优先让父级去加载，若父级加载失败，才轮到自己去加载： AppClassLoader -\u003e ExtensionClassLoader -\u003e BootstrapClassLoader ExtensionClassLoader的parent的值为null，只要是parent=null的，说明父加载器就是BootstrapClassLoader。 ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:5:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#双亲委派"},{"categories":null,"content":" 使用ClassLoader","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:6:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#使用classloader"},{"categories":null,"content":" Class.forName Class.forName(\"com.mysql.cj.jdbc.Driver\"); Class\u003c?\u003e forName(String name, boolean initialize, ClassLoader cl) 这个方法默认使用“调用者”的ClassLoader来加载目标类，并且可以选择其他的ClassLoader。 ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:6:1","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#classforname"},{"categories":null,"content":" ClassLoader.loadClass ClassLoader.getSystemClassLoader().loadClass(\"[I\"); ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:6:2","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#classloaderloadclass"},{"categories":null,"content":" 使用使用时一般都会结合反射。 Class\u003c?\u003e clazz1 = App.class.getClassLoader().loadClass(\"Student\"); Class\u003c?\u003e clazz2 = Student.class.getClassLoader().loadClass(\"Student\"); Class\u003c?\u003e clazz3 = ClassLoader.getSystemClassLoader().loadClass(\"Student\"); Class\u003c?\u003e clazz4 = Class.forName(\"Student\"); Object obj1 = clazz1.getConstructor().newInstance(); clazz1.getMethods()[0].invoke(obj1, \"obj1\"); Object obj2 = clazz2.getConstructor().newInstance(); clazz1.getMethods()[0].invoke(obj2, \"obj2\"); Object obj3 = clazz3.getConstructor().newInstance(); clazz1.getMethods()[0].invoke(obj3, \"obj3\"); Object obj4 = clazz4.getConstructor().newInstance(); clazz1.getMethods()[0].invoke(obj4, \"obj4\"); ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:7:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#使用"},{"categories":null,"content":" 自定义类加载器ClassLoader 里面有三个重要的方法 loadClass()、findClass() 和 defineClass()。 ClassLoader 不重写 用来加载目标类的入口。首先会查找当前自己和双亲是否已经加载目标类，没有的话就让双亲加载，弱失败，再调用findClass()。 findClass() 需重写 去读取字节码，然后调用defineClass()。 defineClass() 不重写 用来从字节码加载类对象。 ","date":"2021-07-08","objectID":"/classloader%E5%AD%A6%E4%B9%A0/:8:0","series":null,"tags":["java"],"title":"ClassLoader学习.md","uri":"/classloader%E5%AD%A6%E4%B9%A0/#自定义类加载器"},{"categories":null,"content":" 字节流标准用法： DataOutputStream out = new DataOutputStream(//负责数据类型 new BufferedOutputStream(//添加缓冲区，提高读流效率 new FileOutputStream(//负责把文件转成流 new File(file) ) ) ); //DataOutputStream类型可直接读写一般类型变量 out.writeString(\"哈哈\"); // 在读取时，比如与写入时顺序一样，才能成功读出来 以上代码充分体现了装饰者模式。 装饰模式在Android中的体现: ","date":"2021-07-06","objectID":"/javaio/:1:0","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#字节流"},{"categories":null,"content":" 字符流最大的区别：readLine() 字符流自带编码。 InputStreamReader isr = new InputStreamReader(in); BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) { System.out.println(line); } br.close(); ","date":"2021-07-06","objectID":"/javaio/:2:0","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#字符流"},{"categories":null,"content":" 字符流与字节流的依赖关系字符流-\u003e字节流-\u003e文件 ","date":"2021-07-06","objectID":"/javaio/:3:0","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#字符流与字节流的依赖关系"},{"categories":null,"content":" RadomAccessFile（用于断点续传） File 打哪指哪 RadomAccessFile 指哪打哪 主要是靠seek()方法标记磁头位置。 ","date":"2021-07-06","objectID":"/javaio/:4:0","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#radomaccessfile用于断点续传"},{"categories":null,"content":" NIO——FileChannel大文件操作时使用。 ","date":"2021-07-06","objectID":"/javaio/:5:0","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#niofilechannel"},{"categories":null,"content":" Android各版本对文件系统的变更 版本号 修改内容 4.4 访问外部公共文件getExternalStoragePublicDirectory()需要具备READ_EXTERNAL_STORAGE权限。 7.0 获取本地文件的Uri方式由Uri.fromFile(new File(filePath))改为FileProvider.getUriForFile()。并且需要在AndroidManifest中添加provider 11.0 启用沙盒机制 ","date":"2021-07-06","objectID":"/javaio/:6:0","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#android各版本对文件系统的变更"},{"categories":null,"content":" Android的文件系统","date":"2021-07-06","objectID":"/javaio/:7:0","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#android的文件系统"},{"categories":null,"content":" 内部储存/data/data/应用包名/ 特点： 无需权限，直接操作； 一般情况下只有App自己能够访问； 卸载后删除； files目录用来长期保存自己的文件，外部无法访问。 //获取内部根目录 context.getDir(String name,int mode) //获取 File file = context.getFilesDir(); //列出文件名 String[] files = context.fileList(); //删除 context.deleteFile(\"路径\"); //创建流 context.openFileOutput(String name, int mode); cache目录用来临时存放文件，空间不足时优先删除。清除缓存时可删除。 File cacheFile = context.getCacheDir(); code_cache目录就是当App升级时，会删除该目录下的内容，这个API要求大于21。 File code = context.getCodeCacheDir() ","date":"2021-07-06","objectID":"/javaio/:7:1","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#内部储存"},{"categories":null,"content":" 内部储存/data/data/应用包名/ 特点： 无需权限，直接操作； 一般情况下只有App自己能够访问； 卸载后删除； files目录用来长期保存自己的文件，外部无法访问。 //获取内部根目录 context.getDir(String name,int mode) //获取 File file = context.getFilesDir(); //列出文件名 String[] files = context.fileList(); //删除 context.deleteFile(\"路径\"); //创建流 context.openFileOutput(String name, int mode); cache目录用来临时存放文件，空间不足时优先删除。清除缓存时可删除。 File cacheFile = context.getCacheDir(); code_cache目录就是当App升级时，会删除该目录下的内容，这个API要求大于21。 File code = context.getCodeCacheDir() ","date":"2021-07-06","objectID":"/javaio/:7:1","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#files目录"},{"categories":null,"content":" 内部储存/data/data/应用包名/ 特点： 无需权限，直接操作； 一般情况下只有App自己能够访问； 卸载后删除； files目录用来长期保存自己的文件，外部无法访问。 //获取内部根目录 context.getDir(String name,int mode) //获取 File file = context.getFilesDir(); //列出文件名 String[] files = context.fileList(); //删除 context.deleteFile(\"路径\"); //创建流 context.openFileOutput(String name, int mode); cache目录用来临时存放文件，空间不足时优先删除。清除缓存时可删除。 File cacheFile = context.getCacheDir(); code_cache目录就是当App升级时，会删除该目录下的内容，这个API要求大于21。 File code = context.getCodeCacheDir() ","date":"2021-07-06","objectID":"/javaio/:7:1","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#cache目录"},{"categories":null,"content":" 内部储存/data/data/应用包名/ 特点： 无需权限，直接操作； 一般情况下只有App自己能够访问； 卸载后删除； files目录用来长期保存自己的文件，外部无法访问。 //获取内部根目录 context.getDir(String name,int mode) //获取 File file = context.getFilesDir(); //列出文件名 String[] files = context.fileList(); //删除 context.deleteFile(\"路径\"); //创建流 context.openFileOutput(String name, int mode); cache目录用来临时存放文件，空间不足时优先删除。清除缓存时可删除。 File cacheFile = context.getCacheDir(); code_cache目录就是当App升级时，会删除该目录下的内容，这个API要求大于21。 File code = context.getCodeCacheDir() ","date":"2021-07-06","objectID":"/javaio/:7:1","series":null,"tags":["IO"],"title":"Java IO","uri":"/javaio/#code_cache目录"},{"categories":null,"content":" JDK、JVM、Jre之间的关系 JVM 只负责把.class文件翻译成操作系统可识别的语句。 Jre 提供Java程序的运行环境 JDK 提供工具 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:1:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#jdkjvmjre之间的关系"},{"categories":null,"content":" JVM的三大区域 Java类加载器ClassLoader 运行时数据区（JVM内存） 执行引擎 注意： JVM是边解释边执行的。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:2:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#jvm的三大区域"},{"categories":null,"content":" 运行时数据区定义：Jre在执行Java程序的过程中会把他所管理的内存划分成若干个不同的数据区域。包括： - 程序计数器 - 虚拟机栈 - 本地方法栈 用来保存native方法的信息 - Java堆 - 方法区（运行时常量池） - 直接内存（也叫堆外内存，用于nio） ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:3:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#运行时数据区"},{"categories":null,"content":" 线程私有 虚拟机栈（A函数调用B函数，B函数会先入栈，此时B函数位于栈顶，被执行。执行完B出栈，使A回到栈顶，A继续执） 本地方法栈 程序计数器 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:3:1","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#线程私有"},{"categories":null,"content":" 线程共享 方法区 堆 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:3:2","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#线程共享"},{"categories":null,"content":" 程序计数器程序计数器是一个很小的内存区域，指向当前线程正在执行的指令对应的字节码地址（指针）。 为什么需要程序计数器？ CPU时间片轮转回来的时候，通过程序计数器才直到程序执行到了哪里，以及从哪继续执行。 JVM的内存区域中，程序计数器是唯一不会OOM的储存区。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:4:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#程序计数器"},{"categories":null,"content":" 虚拟机栈栈：FILA，后进先出。 虚拟机栈用来存储当前线程运行方法所需的数据、指令、返回地址等。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:5:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#虚拟机栈"},{"categories":null,"content":" 栈帧 局部变量表:用来存储局部变量（结构体和引用） 操作数栈:存放函数的执行。 动态连接: 用于多态 完成出口（返回地址）: private void test(){ int i = 0; } 当以上函数进入虚拟机栈时，就成为了一个栈帧，他内部做了两件事： 首先函数中有个创建变量i的操作，入栈到操作数栈； 将操作数栈的栈顶操作生成的数据（i）存入局部变量表下标为[1]的位置（局部变量表下标[0]位置是this，代表实例自己）。 Java的解释执行是基于操作数栈，所以移植性和兼容性好，而C语言是基于寄存器（硬件）运算，所以速度快。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:5:1","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#栈帧"},{"categories":null,"content":" 虚拟机栈的大小 -Xss","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:5:2","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#虚拟机栈的大小--xss"},{"categories":null,"content":" 本地方法栈用来保存native方法的信息。比如hashCode()方法等加了native关键字的方法。 本地方法栈中存放的其实是C函数的链接，由于不是java方法，所以程序计数器不会计数。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:6:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#本地方法栈"},{"categories":null,"content":" 方法区用来存放： 类信息 常量 静态变量 即时编译后的代码 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:7:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#方法区"},{"categories":null,"content":" Java堆用来存放： 对象 数组 参数： Xmx 堆区内存可被分配的最大上限 Xms 堆内存初始内存分配的大小 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:8:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#java堆"},{"categories":null,"content":" 问题，为何要分成方法区和堆堆位于新生代和老年代，回收频繁；而方法区位于永生代（1.8叫元空间，使用的是物理内存，提升了容量），回收不频繁。这是一种动静分离的思想，有利于回收的高效。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:9:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#问题为何要分成方法区和堆"},{"categories":null,"content":" 怎么可视化查看内存 AS的profile JDK9的HSDB ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:10:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#怎么可视化查看内存"},{"categories":null,"content":" 内存溢出常见的内存溢出有以下三种： java.lang.OutOfMemoryError: Java heap space ——\u003ejava堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。 java.lang.OutOfMemoryError: PermGen space ——\u003ejava永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。 java.lang.StackOverflowError ——\u003e 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:11:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#内存溢出"},{"categories":null,"content":" 遗留问题1.JVM 有哪些内存区域？（JVM 的内存布局是什么？） 2.StackOverFlow与OOM的区别？分别发生在什么时候，JVM栈中存储的是什么？堆中存储是什么？ 今天状态不好，学的云里雾里，时间不够快下班了，也懒得总结了，留到后面再说吧。 ","date":"2021-07-06","objectID":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/:12:0","series":null,"tags":["JVM"],"title":"JVM内存结构","uri":"/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#遗留问题"},{"categories":["technology"],"content":" 创建类 class StudentEntity with JsonConvert\u003cStudentEntity\u003e { @JSONField(name: \"name\") late String name; } ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:1:0","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#创建类"},{"categories":["technology"],"content":" 使用 //序列化 Map\u003cString, dynamic\u003e json = StudentEntity(name: \"走两步试试\").toJson(); //反序列化方式一 final student1 = StudentEntity().fromJson(json); //反序列化方式二 final student2 = JsonConvert.fromJsonAsT\u003cStudentEntity\u003e(json); print('student1:$student1'); print('student2:$student2'); ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:2:0","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#使用"},{"categories":["technology"],"content":" 序列化过程","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:3:0","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#序列化过程"},{"categories":["technology"],"content":" JsonConvert /// 当我们混入这个类时，就必须确定这个泛型 class JsonConvert\u003cT\u003e { ///序列化 Map\u003cString, dynamic\u003e toJson() { //注意这里获取到了runtimeType return _getToJson\u003cT\u003e(runtimeType, this); } ///通过静态方法分发 static _getToJson\u003cT\u003e(Type type, data) { switch (type) { case StudentEntity: //注意这里的强转 return studentEntityToJson(data as StudentEntity); } return data as T; } } } 这里首先拿到了runtimeType。每个dart对象都继承于Object： @pragma(\"vm:entry-point\") class Object { @pragma(\"vm:recognized\", \"other\") const Object(); external bool operator ==(Object other); external int get hashCode; external String toString(); @pragma(\"vm:entry-point\") external dynamic noSuchMethod(Invocation invocation); external Type get runtimeType; } Object中有个get属性，而且加了external关键字修饰，表明dart会自动处理，不需要我们来实现。 接下来去看studentEntityToJson(data)方法，位于生成的student_entity_helper.dart中。 ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:3:1","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#jsonconvert"},{"categories":["technology"],"content":" 生成的help辅助文件 Map\u003cString, dynamic\u003e studentEntityToJson(StudentEntity entity) { final Map\u003cString, dynamic\u003e data = new Map\u003cString, dynamic\u003e(); data['name'] = entity.name; return data; } 完全就是遍历了StudentEntity文件中的属性，然后生成了这么个方法，一切的核心都是强转。这让我想起了号称最快的FastJson，原理也是强转。 ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:3:2","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#生成的help辅助文件"},{"categories":["technology"],"content":" 反序列化","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:4:0","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#反序列化"},{"categories":["technology"],"content":" JsonConvert T fromJson(Map\u003cString, dynamic\u003e json) { return _getFromJson\u003cT\u003e(runtimeType, this, json); } static _getFromJson\u003cT\u003e(Type type, data, json) { switch (type) { case StudentEntity: return studentEntityFromJson(data as StudentEntity, json) as T; } return data as T; } ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:4:1","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#jsonconvert-1"},{"categories":["technology"],"content":" 生成的help辅助文件 studentEntityFromJson(StudentEntity data, Map\u003cString, dynamic\u003e json) { if (json['name'] != null) { data.name = json['name'].toString(); } return data; } 不用猜，依然是强转，小学生的思维设计，甚至比不上fastJson考虑的多。 ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:4:2","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#生成的help辅助文件-1"},{"categories":["technology"],"content":" 顶层列表处理 static M fromJsonAsT\u003cM\u003e(json) { //直接通过类型判断 if (json is List) { return _getListChildType\u003cM\u003e(json); } else { return _fromJsonSingle\u003cM\u003e(json) as M; } } //单对象处理 static _fromJsonSingle\u003cM\u003e( json) { //看看，多简单的设计，但是思维还是挺巧妙的 String type = M.toString(); if(type == (StudentEntity).toString()){ return StudentEntity().fromJson(json); } return null; } //列表处理 static M _getListChildType\u003cM\u003e(List data) { if(\u003cStudentEntity\u003e[] is M){ return data.map\u003cStudentEntity\u003e((e) =\u003e StudentEntity().fromJson(e)).toList() as M; } //啊，这个幼稚的异常 throw Exception(\"not fond\"); } ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:5:0","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#顶层列表处理"},{"categories":["technology"],"content":" 总结看完以后，就觉得吧，我们的项目就是用这么个新手写就的插件上，奔跑了快一年时间。不是说这东西不好，他确实是用了简单直接的方式，解决了flutter编程上的一大痛点。而且当我刚刚接触flutter的时候，也觉得这个东西很方便，但是当时心里总是觉得不靠谱，所以没有采用。直到被别人强推了，那就用吧，然后就是磕磕绊绊的各种小问题，也都好解决，直到——当我需要部署devOps的时候，我惊喜的发现jenkins不能alt+j啊！ 通过了解源码，也感觉原作者虽然是个编程新手，但是他在突破问题的时候确实是下了一番功夫的，而且他的知识面也比较宽，甚至通过idea插件的方式解决问题，也是很厉害的了。 最主要的是，确实解决了flutter对于json解析不方便的痛点，所以最后还是对作者表示：非常感谢！ ","date":"2021-06-25","objectID":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/:6:0","series":null,"tags":["flutter","dart"],"title":"FlutterJsonBeanFactory原理","uri":"/flutterjsonbeanfactory%E5%8E%9F%E7%90%86/#总结"},{"categories":null,"content":" 打开命令面板 ctrl+shift+P 跳转设置页面 ctrl+, ","date":"2021-06-24","objectID":"/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BF%86/:0:0","series":null,"tags":["vscode"],"title":"vscode快捷键记忆","uri":"/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BF%86/#"},{"categories":[],"content":" 流程 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； system_server进程接收到请求后，向zygote进程发送创建进程的请求； Zygote进程fork出新的子进程，即App进程； App进程，通过Binder IPC向sytem_server进程发起attachApplication请求； system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求； App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息； 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 ","date":"2021-06-21","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:1:0","series":["Android运行流程"],"tags":["Android"],"title":"Android应用启动流程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#流程"},{"categories":[],"content":" zygote（fork自己，不断增生）zygote意思是受精卵，有分裂增生的意思。 它在Android中是一个独立的进程. 在linux中，所有的进程都是从init进程中fork出来的。当系统启动后会自动从init进程fork出一个zygote进程，当需要启动App时，会从这个初始zygote再fork出新的进程。 zygote被fork出来要做的就是通过binder向sytem_server发送attachApplication请求。 所以这货就两个作用： fork自己； 通知sytem_server附加Application。 ","date":"2021-06-21","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:2:0","series":["Android运行流程"],"tags":["Android"],"title":"Android应用启动流程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#zygotefork自己不断增生"},{"categories":[],"content":" system_serversystem_server也是一个独立的进程，而且也是从zygote中fork出来的。 当他收到应用的附加请求后，会通过binder通知应用进程去scheduleLaunchActivity。这里能够了解到，具体启动哪个activity是由app进程进程决定的。 系统里面很多重要的服务都是在这里启动的，比如ActivityManagerService、PackageManagerService、WindowManagerService等。 ","date":"2021-06-21","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:3:0","series":["Android运行流程"],"tags":["Android"],"title":"Android应用启动流程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#system_server"},{"categories":[],"content":" ActivityManagerService(AMS)服务端对象，负责管理系统中所有Activity的生命周期。 ","date":"2021-06-21","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:4:0","series":["Android运行流程"],"tags":["Android"],"title":"Android应用启动流程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#activitymanagerserviceams"},{"categories":[],"content":" Instrumentation每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。这个类就是完成对Application和Activity初始化和生命周期的工具类。 ActivityThread，依赖于UI线程。App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。 ","date":"2021-06-21","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:5:0","series":["Android运行流程"],"tags":["Android"],"title":"Android应用启动流程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#instrumentation"},{"categories":[],"content":" ApplicationThread","date":"2021-06-21","objectID":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:6:0","series":["Android运行流程"],"tags":["Android"],"title":"Android应用启动流程","uri":"/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#applicationthread"},{"categories":null,"content":" .apk文件的组成apk文件其实就是个压缩包，里面包含： classes.dex编译后的代码文件，安卓的可执行文件 resource.arsc 编译后的资源文件（raw） AndroidManifest.xml 应用配置文件 res文件夹 未编译的应用资源 META-info文件夹 签名，包信息等 ","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:1:0","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#apk文件的组成"},{"categories":null,"content":" 打包流程 aapt编译打包资源文件，生成R.java。 编译AndroidManifest成二进制； 编译layout等xml文件，生成R.java，和resource.arsc文件。 处理aidl文件，生成对应的.java文件。 java编译器（javac）编译项目源码，生成.class文件，位于bin/classes目录下； Android编译器使用dx工具整合所有的class文件生成classes.dex文件； 由apkbuilder打包生成apk； 对包签名； 对齐处理，将包中的资源文件距离文件起始偏移为4字节的整数倍，这样通过内存映射访问apk文件时可提高速度，减少运行时内存的使用。 ","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:2:0","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#打包流程"},{"categories":null,"content":" 安装流程核心类：PMS(PackageManagerService) 复制apk到data/app目录下，解压并扫描安装包，把classes.dex文件保存到dalvik-cache目录，并再data/data目录下创建对应的应用数据目录； 解析AndroidManifinest，提取信息写入/data/system/packages.xml； Launcher加载桌面图标； ","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:3:0","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#安装流程"},{"categories":null,"content":" APK安装方式 方式 有无界面 系统应用 无 market应用下载 无 第三方下载 有 adb 无 ","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:4:0","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#apk安装方式"},{"categories":null,"content":" 反编译","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:5:0","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#反编译"},{"categories":null,"content":" 流程 解压.apk 使用dex2jar将class.dex转为jar包 使用jd-gui反编译jar包 ","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:5:1","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#流程"},{"categories":null,"content":" 加固手段 反模拟器 模拟器运行apk，可以监控到各种行为，所以发现时模拟器在运行就直接退出。 代码虚拟化 自建一个虚拟执行引擎，然后把原生的可执行代码转换成自定义的指令进行虚拟执行。 加密 样本的部分可执行代码是以压缩或者加密的形式存在的，比如被保护过的代码被切割成多个小段，前面的一段代码先把后面的代码片段在内存中解密，然后再执行解密之后的代码。 ","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:5:2","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#加固手段"},{"categories":null,"content":" dex文件结构 ","date":"2021-06-21","objectID":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/:5:3","series":null,"tags":["Android"],"title":"Apk打包和安装流程","uri":"/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/#dex文件结构"},{"categories":null,"content":" .apk文件的组成apk文件其实就是个压缩包，里面包含： classes.dex文件 resource ","date":"2021-06-21","objectID":"/%E5%8F%8D%E7%BC%96%E8%AF%91/:1:0","series":null,"tags":["Android"],"title":"Apk反编译流程","uri":"/%E5%8F%8D%E7%BC%96%E8%AF%91/#apk文件的组成"},{"categories":null,"content":" 打包流程 aapt编译打包资源文件，生成R.java。 编译AndroidManifest成二进制； 编译layout等xml文件，生成R.java，和resource.arsc文件。 处理aidl文件，生成对应的.java文件。 java编译器（javac）编译项目源码，生成.class文件，位于bin/classes目录下； Android编译器使用dx工具整合所有的class文件生成classes.dex文件； 由apkbuilder打包生成apk； 对包签名； 对齐处理，将包中的资源文件距离文件起始偏移为4字节的整数倍，这样通过内存映射访问apk文件时可提高速度，减少运行时内存的使用。 ","date":"2021-06-21","objectID":"/%E5%8F%8D%E7%BC%96%E8%AF%91/:2:0","series":null,"tags":["Android"],"title":"Apk反编译流程","uri":"/%E5%8F%8D%E7%BC%96%E8%AF%91/#打包流程"},{"categories":null,"content":" 安装流程核心类：PMS(PackageManagerService) 复制apk到data/app目录下，解压并扫描安装包，把classes.dex文件保存到dalvik-cache目录，并再data/data目录下创建对应的应用数据目录； 解析AndroidManifinest，提取信息写入/data/system/packages.xml； Launcher加载桌面图标； ","date":"2021-06-21","objectID":"/%E5%8F%8D%E7%BC%96%E8%AF%91/:3:0","series":null,"tags":["Android"],"title":"Apk反编译流程","uri":"/%E5%8F%8D%E7%BC%96%E8%AF%91/#安装流程"},{"categories":null,"content":" APK安装方式 方式 有无界面 系统应用 无 market应用下载 无 第三方下载 有 adb 无 ","date":"2021-06-21","objectID":"/%E5%8F%8D%E7%BC%96%E8%AF%91/:4:0","series":null,"tags":["Android"],"title":"Apk反编译流程","uri":"/%E5%8F%8D%E7%BC%96%E8%AF%91/#apk安装方式"},{"categories":null,"content":" ReentrantLock的使用 ReentrantLock lock = new ReentrantLock(); try { lock.lock(); } finally { lock.unlock(); } ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:1:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#reentrantlock的使用"},{"categories":null,"content":" AQS原理概述 private volatile int state; 维护了一个int state作为状态机，CLH队列Node暂存阻塞的线程，通过判断状态以及CAS变更状态机，遵循FIFO方式从队列中拿出线程运行。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:2:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#aqs原理概述"},{"categories":null,"content":" java中内置的实现： ReentrantLock(可重入锁) Semaphore（信号量） CountDownLatch（计数锁，这个是老朋友了） ReentrantReadWriteLock可重入读写锁 SynchronousQueue FutureTask ThreadPoolExecutor中的work ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:3:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#java中内置的实现"},{"categories":null,"content":" AQS锁分类 独占锁：也叫排他锁，即锁只能由一个线程获取，若一个线程获取了锁，则其他想要获取锁的线程只能等待，直到锁被释放。eg:写锁； 共享锁：锁可以由多个线程同时获取，锁被获取一次，则锁的计数器+1。eg:读锁； ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:4:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#aqs锁分类"},{"categories":null,"content":" 核心方法","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:5:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#核心方法"},{"categories":null,"content":" 抽象方法： tryAcquire 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态。 tryRelease 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态； tryAcquireShared 共享式获取同步状态，返回\u003e=0的值，表示获取成功，反之获取失败 tryReleaseShared 共享式释放同步状态 isHeldExclusively 当前同步器是否再独占模式下被线程占用，一般该方法表示是否被当前线程所独占 记忆方法：只记Acquire和release，前面加shared就是共享，没有就是独占。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:5:1","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#抽象方法"},{"categories":null,"content":" 模板方法： acquire 独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的tryAcquire(int arg)方法。 acquireInterruptibly 与上面方法作用相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回 tryAcquireNanos(int arg,Long nanos) 在上个方法基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false，如果获取到了返回true acquireShared(int arg) 共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同意时刻可以有多个线程获取到同步状态 acquireSharedInterruptibly(int arg) 与上个方法相同，但是会响应中断 tryAcquireSharedNanos 在上个方法基础上怎加了超时机制 release（int arg) 独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒 releaseShared(int arg) 共享式释放同步状态 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:5:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#模板方法"},{"categories":null,"content":" 同步队列CLH同步队列是一个遵循FIFO（first in first out）原则的双向链表。双向链包含前驱节点和后继节点。通常用于自旋同步场景。 入队时需要创建一个新的节点拼接到队尾，而出队时只需要把队首置空就行了。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:6:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#同步队列clh"},{"categories":null,"content":" AQS中的同步队列 public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable { //队首引用 private transient volatile Node head; //队尾引用 private transient volatile Node tail; static final class Node { // 表示线程取消申请锁 static final int CANCELLED = 1; // 表示线程正在申请锁，等待被分配 static final int SIGNAL = -1; // 表示线程在等待某些条件达成，再进入下一阶段 static final int CONDITION = -2; // 表示把对当前节点进行的操作，继续往队列传播下去 static final int PROPAGATE = -3; // 表示当前线程的状态，有五种 volatile int waitStatus; // 双向链之一：前驱节点 volatile Node prev; // 双向链之一：后继节点 volatile Node next; // 节点代表的线程 volatile Thread thread; // 条件队列——单向链，链接下一个节点 Node nextWaiter; } AQS通过这个同步队列来维护当前获取锁失败处于阻塞状态的线程。 在这个队列中，每一个node对应一个线程，当一个线程获取锁失败，会被加入到队尾。只有链首是处于运行状态的线程，其他都在阻塞中。当队首的线程释放锁时，会唤醒下一个node，而下一个node中的线程会尝试获取锁。如果成功，则将上一个node移除，使自己至于链首。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:6:1","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#aqs中的同步队列"},{"categories":null,"content":" Node的五种状态 0：新结点入队时的默认状态； CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。 SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将当前结点的状态更新为SIGNAL。 CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。 PROPAGATE(-3)：共享模式下，前驱结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:6:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#node的五种状态"},{"categories":null,"content":" Node的双向链结构以Node的结构来看，prev 和 next 属性将可以支持AQS可以将请求锁的线程构成双向队列，而入队列出队列，以及先入先出的特性，需要方法来支持。 private transient volatile Node head; private transient volatile Node tail; private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // 进入到这里，说明没有head节点，CAS操作创建一个head节点 if (compareAndSetHead(new Node())) // 如果这里失败，说明发生了并发，会再次循环并走到下面的else tail = head; } else { node.prev = t; // 把Node加入到尾部，保证加入到为止，并发会重走 if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } AQS中，以head为CLH队列头部，以tail为CLH队列尾部，当加入节点时，通过CAS和自旋保证节点正确入队（加入队尾）。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:6:3","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#node的双向链结构"},{"categories":null,"content":" ReentrantLock原理","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#reentrantlock原理"},{"categories":null,"content":" 构造方法 //无参构造方法 public ReentrantLock() { sync = new NonfairSync(); } //有参构造方法 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 构造方法中只是初始化了一个Sync，这就是个AQS： abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; 那么构造方法的作用就是初始化Sync这个AQS，但是根据参数，有两种实现方式： FairSync公平锁：也叫独占锁，多个线程按照申请锁的顺序去获得锁，后申请锁的线程需要排队，等它之前的线程获得锁并释放后，它才能获得锁； NonfairSync非公平锁：线程获得锁的顺序于申请锁的顺序无关，申请锁的线程可以直接尝试获得锁，谁抢到就是谁的。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:1","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#构造方法"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#lock"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#tryaxquireint-arg尝试获取锁"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#公平锁"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#非公平锁"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#reentrantlock的公平与非公平锁都是可重入的"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#公平与非公平锁的区别"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#addwaiter"},{"categories":null,"content":" lock() //注意这里传递了1 public void lock() { sync.acquire(1); } 注意，lock时固定传了整数1。 加锁，就是调用了AQS的acquire(int arg)方法。内部实现是： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } tryAcquire(arg)尝试获取锁； 如果拿不到，则addWaiter(Node.EXCLUSIVE)创建一个等待节点； 然后acquireQueued(waiter)添加进等待队列； 最后中断。 tryAxquire(int arg)尝试获取锁这个方法的作用是尝试获取锁，返回Boolean表示是否成功获取锁，这是个抽象方法，他在公平锁和非公平锁的实现有差别。 当我看完部分源码后，不得不佩服老外的命名能力，try用的非常准确，真的只是尝试获取锁，并不保证一定能获取到锁。 公平锁 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; //尝试获取锁 @ReservedStackAccess protected final boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态 int c = getState(); if (c == 0) { //如果AQS是初始化状态 if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { //如果没有线程正在等待，并且CAS由0到1通过，把当前线程缓存为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程就是独占线程 int nextc = c + acquires; if (nextc \u003c 0) throw new Error(\"Maximum lock count exceeded\"); //就重置AQS状态计数 setState(nextc); return true; } return false; } } //查询是否有线程正在等待 public final boolean hasQueuedPredecessors() { Node h, s; if ((h = head) != null) { //如果head不为空， if ((s = h.next) == null || s.waitStatus \u003e 0) { //如果head的next不为空，或者head处于等待状态 s = null; for (Node p = tail; p != h \u0026\u0026 p != null; p = p.prev) { //从队尾遍历到队首 if (p.waitStatus \u003c= 0) //找到最早开始等待的node s = p; } } if (s != null \u0026\u0026 s.thread != Thread.currentThread()) //最后找到[最早开始等待的node]并且它所在的线程不是当前线程，如果有就返回true return true; } return false; } 在tryAcquire方法中，首先判断AQS的state是否为0，为0表示当前没有线程持有锁，在锁待命的状态下才会去获取锁。 然后判断是否有其他线程在等待锁，没有的话就CAS那个state由0到1（防止其他线程竞争锁，先到先得），通过就把当前线程设置为AQS的独占线程，返回true，这样就使得线程申请到了锁。 如果不是初始化状态，判断当前线程是否独占线程，是的话直接返回true，并且把state加1并返回true。这里充分体现了可重入锁的特点。 那么如果有线程正在等待锁会怎样呢？当前线程会获取锁失败，会返回false，然后AQS会把当前线程封装成Node，添加到CLH的队尾，后面会详细说明。 hasQueuedPredecessors方法负责从队尾遍历到队首，找到最早开始等待并且持有其他线程的node，如果存在，就说明有线程处于等待状态。 总结一下可重入锁的原理： 通过CAS改变state并且判断state状态，避免锁竞争； 已经持有锁的线程可免除CAS再次获取锁。 再总结一下公平锁的原理：判断当前锁是否被占用，再遍历CLH队列，如果存在处于等待状态的其他线程，则当前线获取锁失败，改变为等待状态，添加到CLH的队尾，以保证每个线程按序持有锁。 非公平锁 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; protected final boolean tryAcquire(int acquires) { //调用父类的方法 return nonfairTryAcquire(acquires); } } nonfairTryAcquire方法位于父类Sync中，那么这里也体现了模板方法模式。 final boolean nonfairTryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS中的state int c = getState(); if (c == 0) { //如果是初始状态 if (compareAndSetState(0, acquires)) { //如果CAS由0到1通过，那么就把当前线程设置为外部线程，到这里 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 从代码来看，非公平锁并没有判断是否有线程正在等待锁，所以当新线程申请锁时，能拿到锁就拿，拿不到再加入队列去等。 ReentrantLock的公平与非公平锁都是可重入的 公平与非公平锁的区别公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队首的线程才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样有可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 addWaiter() 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。 摘自：https://www.jianshu.com/p/6fc0601ffe34 //空占位 static final Node EXCLUSIVE = null; /** * 把当前线程封装成node置于队尾 * @param mode固定是null **/ private Node addWaiter(Node mode) { //创建一个持有当前线程的node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) { //如果tail存在，就把新node置于队尾 node.prev = pred; //变更tail为新创建的node if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //通过设置头尾节点，建立新的队列顺序 private Node enq(final Node node) { for (;;) { //拿到缓存的tail Node t = tail; if (t == null) { //如果没有缓存就初始化head和tail if (compareAndSetHead(new Node())) tail = he","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#acquirequeued"},{"categories":null,"content":" unlock()同步队列（CLH）遵循FIFO，首节点是获取同步状态的节点，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单。如下图： 设置首节点是通过获取锁成功的线程来完成的（获取同步状态是通过CAS来完成），只能有一个线程能够获取到锁，因此设置头节点的操作并不需要CAS来保证，只需要将首节点设置为其原首节点的后继节点并断开原首节点的next（等待GC回收）即可。 public void unlock() { sync.release(1); } public final boolean release(int arg) { //尝试释放锁 if (tryRelease(arg)) { Node h = head; if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //尝试释放锁 @ReservedStackAccess protected final boolean tryRelease(int releases) { //检查状态机，是否可释放 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) //如果当前线程不是独占线程，则抛出异常 throw new IllegalMonitorStateException(); //改标记位 boolean free = false; if (c == 0) { free = true; //释放独占线程 setExclusiveOwnerThread(null); } //变更状态机 setState(c); return free; } //唤醒下一个线程 private void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws \u003c 0) //重置node的状态 node.compareAndSetWaitStatus(ws, 0); Node s = node.next; if (s == null || s.waitStatus \u003e 0) { s = null; for (Node p = tail; p != node \u0026\u0026 p != null; p = p.prev) if (p.waitStatus \u003c= 0) s = p; } //如果存在next，唤醒下个node线程 if (s != null) LockSupport.unpark(s.thread); } 其实我觉得这里就没必要细看了，细看也记不住。 unlock()方法主要是通过AQS的release(int arg)实现的，内部机制无非就是重置状态机，释放独占线程，并且唤醒下一个线程。而唤醒线程的方式也必然是LockSupport.unpark(s.thread)。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:3","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#unlock"},{"categories":null,"content":" 共享锁的申请先回顾一下独占锁的申请： public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //中断当前线程 selfInterrupt(); } 线程申请独占锁失败会通过acquireQueued进入队列等待。 共享锁的申请则要简单的多： public final void acquireShared(int arg) { //调用抽象方法tryAcquireShared，可以看到返回了一个计数，如果计数大于0就表示成功拿到锁 if (tryAcquireShared(arg) \u003c 0) //如果返回小于0会调用doAcquireShared doAcquireShared(arg); } static final Node SHARED = new Node(); private void doAcquireShared(int arg) { //同样调用了addWaiter，但是传递的不是null而是一个空Node（），这样就保证Node.SHARED一直是[当前]节点的后继节点 final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { //拿到上一节点 final Node p = node.predecessor(); if (p == head) { //如果上个节点是head //再次尝试申请锁 int r = tryAcquireShared(arg); if (r \u003e= 0) { //如果拿到锁就释放head setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026 parkAndCheckInterrupt()) //阻塞线程，并检测线程是否被中断 interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 先调用addWaiter()向队尾添加一个空的node并包装当前的thread，然后给这个空的节点增加后继节点Node.SHARED。再进入自旋，从当前节点向上遍历，如果当前节点的前驱节点是head，就尝试申请锁，申请成功就释放head，并把自己置于队首。其他位置的线程会判断状态是否应该被阻塞，然后再进入阻塞状态。 我们看到，共享锁全程没有判断当前线程是否独占线程，只要调用tryAcquireShared()方法不返回负数，就能成功申请到锁，而且同一时间可以多个线程并发拿到锁。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:7:4","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#共享锁的申请"},{"categories":null,"content":" 自定义一个最简单的重入锁上面终于把源码巴拉完了，但是整个流程记不住。记不住怎么办？想办法，所以我决定自己实现一个最简单的可重入非公平锁： /** * 我自己实现的非公平锁 */ public class MyLock { private final Sync sync; public MyLock() { this.sync = new Sync(); } public void lock() { sync.acquire(1); } public void unlock() { sync.release(1); } /** * AQS实现类 */ class Sync extends AbstractQueuedSynchronizer { /** * 重写tryAcquire */ @Override protected boolean tryAcquire(int acquires) { //拿到当前线程 final Thread current = Thread.currentThread(); //拿到AQS的状态机 int c = getState(); //判断状态机如果是初始状态 if (c == 0) { //CAS由0到1 if (compareAndSetState(0, acquires)) { //当前线程设置为独占线程 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { //如果当前线程已经是独占线程，改变AQS状态 int nextc = c + acquires; setState(nextc); return true; } return false; } /** * 重写tryRelease */ @Override protected boolean tryRelease(int release) { int c = getState() - release; boolean free = false; if (c == 0) { free = true; //释放独占线程 setExclusiveOwnerThread(null); } //改变状态机 setState(c); return free; } } } 从这里看出，利用AQS实现一个锁的流程： 继承AQS； 重写tryAcquire，当前线程置为独占线程，setState()变更状态； 重写tryRelease(int release)，释放独占线程，setState()变更状态。 然后激动的试了一下： private static int num; private static MyLock myLock = new MyLock(); public static void main(String[] args) throws Exception { Thread t1 = new Thread() { @Override public void run() { concat(); } }; Thread t2 = new Thread() { @Override public void run() { concat(); } }; t1.setName(\"t1\"); t2.setName(\"t2\"); t1.start(); t2.start(); } private static void concat() { try { myLock.lock(); for (int i = 0; i \u003c 10; i++) { try { Thread.sleep(3000); num++; System.out.println(\"线程\" + Thread.currentThread().getName() + \"把num改为\" + num); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } finally { myLock.unlock(); } } 最后惴惴不安的看了下结果： 线程t1把num改为1 线程t1把num改为2 线程t1把num改为3 线程t1把num改为4 线程t1把num改为5 线程t1把num改为6 线程t1把num改为7 线程t1把num改为8 线程t1把num改为9 线程t1把num改为10 线程t2把num改为11 线程t2把num改为12 线程t2把num改为13 线程t2把num改为14 线程t2把num改为15 线程t2把num改为16 线程t2把num改为17 线程t2把num改为18 线程t2把num改为19 线程t2把num改为20 没问题，i did it ! ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:8:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#自定义一个最简单的重入锁"},{"categories":null,"content":" AQS的条件队列","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#aqs的条件队列"},{"categories":null,"content":" 条件队列的使用VSObject监视器方法 对象监视器锁使用 public class App { // 创建一把锁 private static Object obj = new Object(); public static void main(String[] args) { Thread t1 = new Thread() { @Override public void run() { //上锁 synchronized (obj) { try { System.out.println(getName() + \"开始等待\"); //阻塞等待 obj.wait(); System.out.println(getName() + \"已被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }; t1.setName(\"t1\"); Thread t2 = new Thread() { @Override public void run() { //上锁 synchronized (obj) { try { System.out.println(getName() + \"已开始执行，3秒后将唤醒t1\"); sleep(3000); //唤醒 obj.notify(); } catch (InterruptedException e) { e.printStackTrace(); } } } }; t2.setName(\"t2\"); t1.start(); t2.start(); } } 用法解析： 阻塞wait和唤醒notify都必须在持有锁的前提下调用，否则会报异常； 通过wait()阻塞线程； 通过notify()唤醒线程； 阻塞wait之后不会再执行任何代码，所以notify不应该在await之后。 输出： t1开始等待 t2已开始执行，3秒后将唤醒t1 t1已被唤醒 条件锁使用 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class App2 { // 创建一个独占锁 private static ReentrantLock lock = new ReentrantLock(); // 用独占锁创建Condition private static Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread() { public void run() { try { lock.lock(); System.out.println(getName() + \"开始等待\"); condition.await(); System.out.println(getName() + \"已被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }; }; t1.setName(\"t1\"); Thread t2 = new Thread() { public void run() { try { lock.lock(); System.out.println(getName() + \"已开始执行，3秒后将唤醒t1\"); sleep(3000); condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }; }; t2.setName(\"t2\"); t1.start(); t2.start(); } } 用法解析： 不论阻塞还是环境，都需要通过lock.lock()获取锁，否则或报监视器异常； 使用await()方法阻塞线程； 使用signal()方法唤醒线程； await()阻塞之后不会执行任何代码，直到被唤醒。 输出： t1开始等待 t2已开始执行，3秒后将唤醒t1 t1已被唤醒 从上面的对比可以看出，条件锁与对象监视器锁的用法几乎一样： Object Condition 作用 wait() await() 阻塞线程 notify() signal() 唤醒线程 notifyAll() signalAll() 唤醒全部线程 但是Condition在使用起来更加灵活，且在同一把锁中支持多个条件，所以应该优先使用。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:1","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#条件队列的使用vsobject监视器方法"},{"categories":null,"content":" 条件队列的使用VSObject监视器方法 对象监视器锁使用 public class App { // 创建一把锁 private static Object obj = new Object(); public static void main(String[] args) { Thread t1 = new Thread() { @Override public void run() { //上锁 synchronized (obj) { try { System.out.println(getName() + \"开始等待\"); //阻塞等待 obj.wait(); System.out.println(getName() + \"已被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }; t1.setName(\"t1\"); Thread t2 = new Thread() { @Override public void run() { //上锁 synchronized (obj) { try { System.out.println(getName() + \"已开始执行，3秒后将唤醒t1\"); sleep(3000); //唤醒 obj.notify(); } catch (InterruptedException e) { e.printStackTrace(); } } } }; t2.setName(\"t2\"); t1.start(); t2.start(); } } 用法解析： 阻塞wait和唤醒notify都必须在持有锁的前提下调用，否则会报异常； 通过wait()阻塞线程； 通过notify()唤醒线程； 阻塞wait之后不会再执行任何代码，所以notify不应该在await之后。 输出： t1开始等待 t2已开始执行，3秒后将唤醒t1 t1已被唤醒 条件锁使用 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class App2 { // 创建一个独占锁 private static ReentrantLock lock = new ReentrantLock(); // 用独占锁创建Condition private static Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread() { public void run() { try { lock.lock(); System.out.println(getName() + \"开始等待\"); condition.await(); System.out.println(getName() + \"已被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }; }; t1.setName(\"t1\"); Thread t2 = new Thread() { public void run() { try { lock.lock(); System.out.println(getName() + \"已开始执行，3秒后将唤醒t1\"); sleep(3000); condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }; }; t2.setName(\"t2\"); t1.start(); t2.start(); } } 用法解析： 不论阻塞还是环境，都需要通过lock.lock()获取锁，否则或报监视器异常； 使用await()方法阻塞线程； 使用signal()方法唤醒线程； await()阻塞之后不会执行任何代码，直到被唤醒。 输出： t1开始等待 t2已开始执行，3秒后将唤醒t1 t1已被唤醒 从上面的对比可以看出，条件锁与对象监视器锁的用法几乎一样： Object Condition 作用 wait() await() 阻塞线程 notify() signal() 唤醒线程 notifyAll() signalAll() 唤醒全部线程 但是Condition在使用起来更加灵活，且在同一把锁中支持多个条件，所以应该优先使用。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:1","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#对象监视器锁使用"},{"categories":null,"content":" 条件队列的使用VSObject监视器方法 对象监视器锁使用 public class App { // 创建一把锁 private static Object obj = new Object(); public static void main(String[] args) { Thread t1 = new Thread() { @Override public void run() { //上锁 synchronized (obj) { try { System.out.println(getName() + \"开始等待\"); //阻塞等待 obj.wait(); System.out.println(getName() + \"已被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }; t1.setName(\"t1\"); Thread t2 = new Thread() { @Override public void run() { //上锁 synchronized (obj) { try { System.out.println(getName() + \"已开始执行，3秒后将唤醒t1\"); sleep(3000); //唤醒 obj.notify(); } catch (InterruptedException e) { e.printStackTrace(); } } } }; t2.setName(\"t2\"); t1.start(); t2.start(); } } 用法解析： 阻塞wait和唤醒notify都必须在持有锁的前提下调用，否则会报异常； 通过wait()阻塞线程； 通过notify()唤醒线程； 阻塞wait之后不会再执行任何代码，所以notify不应该在await之后。 输出： t1开始等待 t2已开始执行，3秒后将唤醒t1 t1已被唤醒 条件锁使用 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class App2 { // 创建一个独占锁 private static ReentrantLock lock = new ReentrantLock(); // 用独占锁创建Condition private static Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread() { public void run() { try { lock.lock(); System.out.println(getName() + \"开始等待\"); condition.await(); System.out.println(getName() + \"已被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }; }; t1.setName(\"t1\"); Thread t2 = new Thread() { public void run() { try { lock.lock(); System.out.println(getName() + \"已开始执行，3秒后将唤醒t1\"); sleep(3000); condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }; }; t2.setName(\"t2\"); t1.start(); t2.start(); } } 用法解析： 不论阻塞还是环境，都需要通过lock.lock()获取锁，否则或报监视器异常； 使用await()方法阻塞线程； 使用signal()方法唤醒线程； await()阻塞之后不会执行任何代码，直到被唤醒。 输出： t1开始等待 t2已开始执行，3秒后将唤醒t1 t1已被唤醒 从上面的对比可以看出，条件锁与对象监视器锁的用法几乎一样： Object Condition 作用 wait() await() 阻塞线程 notify() signal() 唤醒线程 notifyAll() signalAll() 唤醒全部线程 但是Condition在使用起来更加灵活，且在同一把锁中支持多个条件，所以应该优先使用。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:1","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#条件锁使用"},{"categories":null,"content":" ReentrantLock VS synchronized 区别 synchronized ReentrantLock 来源 jvm JUC包 原理 对象监视器 AQS队列+CAS+valatile 易用 强 弱 释放 自动 手动unlock 位置 对象、方法、类、代码块 只有代码块 可中断 不 可 公平锁 不支持 支持 精确唤醒 不支持 支持 多条件 不支持 支持 结果 只能一直阻塞 可返回结果 超时 不支持 支持 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#reentrantlock-vs-synchronized"},{"categories":null,"content":" 条件队列原理 newCondition() final ConditionObject newCondition() { return new ConditionObject(); } 很简单，就是构建了一个ConditionObject对象，他是Condition的实现类。 await()阻塞方法 public final void await() throws InterruptedException { //当前线程的中断检查，会重置中断状态 if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); //释放之前获取到的锁资源，因为后续会阻塞该线程，所以如果不释放的话，其他线程将会等待该线程被唤醒 int savedState = fullyRelease(node); int interruptMode = 0; //isOnSyncQueue方法会遍历CLH队列寻找当前node while (!isOnSyncQueue(node)) { //如果当前节点不在CLH队列中则阻塞住，等待unpark唤醒 //阻塞当前线程 LockSupport.park(this); //中断检测 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } //唤醒后，会再次调用acquireQueued来阻塞，并且会不断的tryAcquire队首，让队首尝试获取锁 if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } //把当前线程包装成一个新的node，并且设置成等待条件状态，加入条件队列 private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null \u0026\u0026 t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //当前线程包装成一个新node，状态为：等待条件 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else //node的nextWaiter是一条单向链，这里是把新的节点加入条件队列中 t.nextWaiter = node; lastWaiter = node; return node; } //清除条件队列中已不是等待条件状态的节点 private void unlinkCancelledWaiters() { Node t = firstWaiter; Node trail = null; while (t != null) { Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) { //释放队列中所有状态不是条件的节点 t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; } else trail = t; t = next; } } final boolean isOnSyncQueue(Node node) { //如果node是condition状态或者没有前驱节点返回false if (node.waitStatus == Node.CONDITION || node.prev == null) return false; //如果存在下一个节点，返回true，会终止自旋 if (node.next != null) // If has successor, it must be on queue return true; return findNodeFromTail(node); } //判断当前节点是否存在于CLH队列中 private boolean findNodeFromTail(Node node) { Node t = tail; for (;;) { if (t == node) return true; if (t == null) return false; t = t.prev; } } signal()唤醒方法 public final void signal() { //如果当前线程不是独占线程，就会抛异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) //唤醒线程，改变状态 doSignal(first); } private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; //剔除当前节点 first.nextWaiter = null; } while (!transferForSignal(first) \u0026\u0026 (first = firstWaiter) != null); } //把node的状态从CONDITION变为其他状态，唤醒线程 final boolean transferForSignal(Node node) { //CAS操作重置node的状态 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //走到这里说明该节点的状态已经被修改成了初始状态0。把其加入到CLH队列尾部，并返回前一个节点 Node p = enq(node); int ws = p.waitStatus; if (ws \u003e 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) //唤醒线程 LockSupport.unpark(node.thread); return true; } isHeldExclusively 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占。这里看出调用signal()时必须位于独占线程。 由以上代码可以看到： signal()唤起线程时，会把线程从条件队列中剔除； await()方法中阻塞的线程被唤起时会调用acquireQueued()方法不断获取锁。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:3","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#条件队列原理"},{"categories":null,"content":" 条件队列原理 newCondition() final ConditionObject newCondition() { return new ConditionObject(); } 很简单，就是构建了一个ConditionObject对象，他是Condition的实现类。 await()阻塞方法 public final void await() throws InterruptedException { //当前线程的中断检查，会重置中断状态 if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); //释放之前获取到的锁资源，因为后续会阻塞该线程，所以如果不释放的话，其他线程将会等待该线程被唤醒 int savedState = fullyRelease(node); int interruptMode = 0; //isOnSyncQueue方法会遍历CLH队列寻找当前node while (!isOnSyncQueue(node)) { //如果当前节点不在CLH队列中则阻塞住，等待unpark唤醒 //阻塞当前线程 LockSupport.park(this); //中断检测 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } //唤醒后，会再次调用acquireQueued来阻塞，并且会不断的tryAcquire队首，让队首尝试获取锁 if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } //把当前线程包装成一个新的node，并且设置成等待条件状态，加入条件队列 private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null \u0026\u0026 t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //当前线程包装成一个新node，状态为：等待条件 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else //node的nextWaiter是一条单向链，这里是把新的节点加入条件队列中 t.nextWaiter = node; lastWaiter = node; return node; } //清除条件队列中已不是等待条件状态的节点 private void unlinkCancelledWaiters() { Node t = firstWaiter; Node trail = null; while (t != null) { Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) { //释放队列中所有状态不是条件的节点 t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; } else trail = t; t = next; } } final boolean isOnSyncQueue(Node node) { //如果node是condition状态或者没有前驱节点返回false if (node.waitStatus == Node.CONDITION || node.prev == null) return false; //如果存在下一个节点，返回true，会终止自旋 if (node.next != null) // If has successor, it must be on queue return true; return findNodeFromTail(node); } //判断当前节点是否存在于CLH队列中 private boolean findNodeFromTail(Node node) { Node t = tail; for (;;) { if (t == node) return true; if (t == null) return false; t = t.prev; } } signal()唤醒方法 public final void signal() { //如果当前线程不是独占线程，就会抛异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) //唤醒线程，改变状态 doSignal(first); } private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; //剔除当前节点 first.nextWaiter = null; } while (!transferForSignal(first) \u0026\u0026 (first = firstWaiter) != null); } //把node的状态从CONDITION变为其他状态，唤醒线程 final boolean transferForSignal(Node node) { //CAS操作重置node的状态 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //走到这里说明该节点的状态已经被修改成了初始状态0。把其加入到CLH队列尾部，并返回前一个节点 Node p = enq(node); int ws = p.waitStatus; if (ws \u003e 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) //唤醒线程 LockSupport.unpark(node.thread); return true; } isHeldExclusively 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占。这里看出调用signal()时必须位于独占线程。 由以上代码可以看到： signal()唤起线程时，会把线程从条件队列中剔除； await()方法中阻塞的线程被唤起时会调用acquireQueued()方法不断获取锁。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:3","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#newcondition"},{"categories":null,"content":" 条件队列原理 newCondition() final ConditionObject newCondition() { return new ConditionObject(); } 很简单，就是构建了一个ConditionObject对象，他是Condition的实现类。 await()阻塞方法 public final void await() throws InterruptedException { //当前线程的中断检查，会重置中断状态 if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); //释放之前获取到的锁资源，因为后续会阻塞该线程，所以如果不释放的话，其他线程将会等待该线程被唤醒 int savedState = fullyRelease(node); int interruptMode = 0; //isOnSyncQueue方法会遍历CLH队列寻找当前node while (!isOnSyncQueue(node)) { //如果当前节点不在CLH队列中则阻塞住，等待unpark唤醒 //阻塞当前线程 LockSupport.park(this); //中断检测 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } //唤醒后，会再次调用acquireQueued来阻塞，并且会不断的tryAcquire队首，让队首尝试获取锁 if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } //把当前线程包装成一个新的node，并且设置成等待条件状态，加入条件队列 private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null \u0026\u0026 t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //当前线程包装成一个新node，状态为：等待条件 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else //node的nextWaiter是一条单向链，这里是把新的节点加入条件队列中 t.nextWaiter = node; lastWaiter = node; return node; } //清除条件队列中已不是等待条件状态的节点 private void unlinkCancelledWaiters() { Node t = firstWaiter; Node trail = null; while (t != null) { Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) { //释放队列中所有状态不是条件的节点 t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; } else trail = t; t = next; } } final boolean isOnSyncQueue(Node node) { //如果node是condition状态或者没有前驱节点返回false if (node.waitStatus == Node.CONDITION || node.prev == null) return false; //如果存在下一个节点，返回true，会终止自旋 if (node.next != null) // If has successor, it must be on queue return true; return findNodeFromTail(node); } //判断当前节点是否存在于CLH队列中 private boolean findNodeFromTail(Node node) { Node t = tail; for (;;) { if (t == node) return true; if (t == null) return false; t = t.prev; } } signal()唤醒方法 public final void signal() { //如果当前线程不是独占线程，就会抛异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) //唤醒线程，改变状态 doSignal(first); } private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; //剔除当前节点 first.nextWaiter = null; } while (!transferForSignal(first) \u0026\u0026 (first = firstWaiter) != null); } //把node的状态从CONDITION变为其他状态，唤醒线程 final boolean transferForSignal(Node node) { //CAS操作重置node的状态 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //走到这里说明该节点的状态已经被修改成了初始状态0。把其加入到CLH队列尾部，并返回前一个节点 Node p = enq(node); int ws = p.waitStatus; if (ws \u003e 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) //唤醒线程 LockSupport.unpark(node.thread); return true; } isHeldExclusively 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占。这里看出调用signal()时必须位于独占线程。 由以上代码可以看到： signal()唤起线程时，会把线程从条件队列中剔除； await()方法中阻塞的线程被唤起时会调用acquireQueued()方法不断获取锁。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:3","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#await阻塞方法"},{"categories":null,"content":" 条件队列原理 newCondition() final ConditionObject newCondition() { return new ConditionObject(); } 很简单，就是构建了一个ConditionObject对象，他是Condition的实现类。 await()阻塞方法 public final void await() throws InterruptedException { //当前线程的中断检查，会重置中断状态 if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); //释放之前获取到的锁资源，因为后续会阻塞该线程，所以如果不释放的话，其他线程将会等待该线程被唤醒 int savedState = fullyRelease(node); int interruptMode = 0; //isOnSyncQueue方法会遍历CLH队列寻找当前node while (!isOnSyncQueue(node)) { //如果当前节点不在CLH队列中则阻塞住，等待unpark唤醒 //阻塞当前线程 LockSupport.park(this); //中断检测 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } //唤醒后，会再次调用acquireQueued来阻塞，并且会不断的tryAcquire队首，让队首尝试获取锁 if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } //把当前线程包装成一个新的node，并且设置成等待条件状态，加入条件队列 private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null \u0026\u0026 t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //当前线程包装成一个新node，状态为：等待条件 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else //node的nextWaiter是一条单向链，这里是把新的节点加入条件队列中 t.nextWaiter = node; lastWaiter = node; return node; } //清除条件队列中已不是等待条件状态的节点 private void unlinkCancelledWaiters() { Node t = firstWaiter; Node trail = null; while (t != null) { Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) { //释放队列中所有状态不是条件的节点 t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; } else trail = t; t = next; } } final boolean isOnSyncQueue(Node node) { //如果node是condition状态或者没有前驱节点返回false if (node.waitStatus == Node.CONDITION || node.prev == null) return false; //如果存在下一个节点，返回true，会终止自旋 if (node.next != null) // If has successor, it must be on queue return true; return findNodeFromTail(node); } //判断当前节点是否存在于CLH队列中 private boolean findNodeFromTail(Node node) { Node t = tail; for (;;) { if (t == node) return true; if (t == null) return false; t = t.prev; } } signal()唤醒方法 public final void signal() { //如果当前线程不是独占线程，就会抛异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) //唤醒线程，改变状态 doSignal(first); } private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; //剔除当前节点 first.nextWaiter = null; } while (!transferForSignal(first) \u0026\u0026 (first = firstWaiter) != null); } //把node的状态从CONDITION变为其他状态，唤醒线程 final boolean transferForSignal(Node node) { //CAS操作重置node的状态 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //走到这里说明该节点的状态已经被修改成了初始状态0。把其加入到CLH队列尾部，并返回前一个节点 Node p = enq(node); int ws = p.waitStatus; if (ws \u003e 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) //唤醒线程 LockSupport.unpark(node.thread); return true; } isHeldExclusively 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占。这里看出调用signal()时必须位于独占线程。 由以上代码可以看到： signal()唤起线程时，会把线程从条件队列中剔除； await()方法中阻塞的线程被唤起时会调用acquireQueued()方法不断获取锁。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:9:3","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#signal唤醒方法"},{"categories":null,"content":" 全文总结","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:10:0","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#全文总结"},{"categories":null,"content":" 一句话总结AQS原理AQS内部包含int state状态机和CLH同步队列，通过判断状态机决定线程是否能获得锁，并利用CAS原子操作改变状态，并让拿不到锁的线程加入CLH同步队列，依赖LockSuport.part方法阻塞线程，当锁释放时会唤醒线程，让队首节点出队，并让下一个线程自旋竞争锁。 同时AQS利用Node中的nextWaiter单向链作为条件队列，让其中符合条件的节点加入CLH队列获得竞争锁的机会。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:10:1","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#一句话总结aqs原理"},{"categories":null,"content":" 可重入锁的原理ReentrantLock是在AQS的基础上重写了tryAcquire()方法，判断当前线程是否是独占线程，是的话就直接让当前线程获得锁。 ","date":"2021-05-13","objectID":"/aqs%E5%8E%9F%E7%90%86/:10:2","series":null,"tags":null,"title":"从ReentrantLock看AQS原理","uri":"/aqs%E5%8E%9F%E7%90%86/#可重入锁的原理"},{"categories":null,"content":" RV是什么 public class RecyclerView extends ViewGroup implements ScrollingView{ ... } 就是个ViewGroup，并且遵循了ScrollingView接口，所以支持滑动。 那么，既然是VG，那么我们就从VG的核心方法入手，他们分别是： onMeasure onLayout onDrow ","date":"2021-05-10","objectID":"/recyclerview%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":["Android"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/recyclerview%E8%A7%A3%E8%AF%BB/#rv是什么"},{"categories":null,"content":" RV的状态在开始RV的内窥之前，我们先了解一下RV有几种状态，这样有利于我们的理解。 @IntDef(flag = true, value = { STEP_START, STEP_LAYOUT, STEP_ANIMATIONS }) @Retention(RetentionPolicy.SOURCE) @interface LayoutState {} @LayoutState int mLayoutStep = STEP_START; STEP_START：开始状态 STEP_LAYOUT：布局状态 STEP_ANIMATIONS：动画状态 ","date":"2021-05-10","objectID":"/recyclerview%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":["Android"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/recyclerview%E8%A7%A3%E8%AF%BB/#rv的状态"},{"categories":null,"content":" onMeasure @Override protected void onMeasure(int widthSpec, int heightSpec) { //如果没有设置layoutManager，则采用padding+最小尺寸 if (mLayout == null) { defaultOnMeasure(widthSpec, heightSpec); return; } //判断layoutManager中的一个标志位，但是这个标志位已经标明过期了 if (mLayout.isAutoMeasureEnabled()) { //拿到mode final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); //让layoutManager测量 mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY \u0026\u0026 heightMode == MeasureSpec.EXACTLY; //如果是match_parent或这是个确定的值，而此时没有adapter，那就不玩了，等下次measure时再处理 if (measureSpecModeIsExactly || mAdapter == null) { return; } //如果是开始状态， if (mState.mLayoutStep == State.STEP_START) { //第一次layout过程 dispatchLayoutStep1(); } // set dimensions in 2nd step. Pre-layout should happen with old dimensions for // consistency mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; //第二次layout过程 dispatchLayoutStep2(); // 从children中获取宽高 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); //如果RV存在不精确的宽高，或者存在child也不精确，我们不得不再次measure if (mLayout.shouldMeasureTwice()) { //用当前已测量过的宽高，重新生成MeasureSpec，并设置给layoutMnager mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; //重启过程2 dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); } } else { if (mHasFixedSize) { mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); return; } // custom onMeasure if (mAdapterUpdateDuringMeasure) { startInterceptRequestLayout(); onEnterLayoutOrScroll(); processAdapterUpdatesAndSetAnimationFlags(); onExitLayoutOrScroll(); if (mState.mRunPredictiveAnimations) { mState.mInPreLayout = true; } else { // consume remaining updates to provide a consistent state with the layout pass. mAdapterHelper.consumeUpdatesInOnePass(); mState.mInPreLayout = false; } mAdapterUpdateDuringMeasure = false; stopInterceptRequestLayout(false); } else if (mState.mRunPredictiveAnimations) { // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true: // this means there is already an onMeasure() call performed to handle the pending // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time // because getViewForPosition() will crash when LM uses a child to measure. setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); return; } if (mAdapter != null) { mState.mItemCount = mAdapter.getItemCount(); } else { mState.mItemCount = 0; } startInterceptRequestLayout(); mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); stopInterceptRequestLayout(false); mState.mInPreLayout = false; // clear } } // 如果没有设置layoutManager，则采用padding+最小尺寸 void defaultOnMeasure(int widthSpec, int heightSpec) { final int width = LayoutManager.chooseSize(widthSpec,getPaddingLeft() + getPaddingRight(), ViewCompat.getMinimumWidth(this)); final int height = LayoutManager.chooseSize(heightSpec,getPaddingTop() + getPaddingBottom(), ViewCompat.getMinimumHeight(this)); setMeasuredDimension(width, height); } ","date":"2021-05-10","objectID":"/recyclerview%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":["Android"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/recyclerview%E8%A7%A3%E8%AF%BB/#onmeasure"},{"categories":null,"content":" Measure两次的原因 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); //是否需要再次测量，默认为false boolean measureAgain = false; if (lp.horizontalWeight \u003e 0.0f) { width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; } if (lp.verticalWeight \u003e 0.0f) { height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; } if (measureAgain) { if (DEBUG_LAYOUT) Log.v(mTag, \"And hey let's measure once more: width=\" + width + \" height=\" + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } 在第一次 performMeasure() 方法调用后， 如果子View 需要的空间大于父容器为它测量的大小，那么对应的 verticalWeight 和 horizontalWeight 将会大于0，即这两个字段分别对应垂直和水平的情况下子 View 需要的额外空间。 这时候会将 measureAgain 设置为 true， 并且开始第二次测量。 未完待续… ","date":"2021-05-10","objectID":"/recyclerview%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/recyclerview%E8%A7%A3%E8%AF%BB/#measure两次的原因"},{"categories":null,"content":" SharedPreferences解读 SharedPreferences是我们平时常用的简单储存工具。优点就是用起来方便，而且线程安全，甚至有的公司干脆连sqLite都不用了，全用SP！但是突然有一天腾讯弄出了个MMKV用来替代他，最近google也弄了个DataStorage，而且最近面试也是必问原理，于是我决定死磕一下SP。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:0:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#sharedpreferences解读"},{"categories":null,"content":" 初始化","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#初始化"},{"categories":null,"content":" getSharedPreferences我们通过这个方法拿到SP，该方法在Activity中内置，最终调用的是ContextWrapper的方法： @Override public SharedPreferences getSharedPreferences(String name, int mode) { return mBase.getSharedPreferences(name, mode); } ContextWrapper里面调用的mBase的对应方法，通过百度，查到mBase其实就是传说中的ContextImpl： @Override public SharedPreferences getSharedPreferences(String name, int mode) { if (mPackageInfo.getApplicationInfo().targetSdkVersion \u003c Build.VERSION_CODES.KITKAT) { if (name == null) { name = \"null\"; } } File file; synchronized (ContextImpl.class) { if (mSharedPrefsPaths == null) { mSharedPrefsPaths = new ArrayMap\u003c\u003e(); } file = mSharedPrefsPaths.get(name); if (file == null) { file = getSharedPreferencesPath(name); //拿到文件后加入缓存，下次再拿文件就快了 mSharedPrefsPaths.put(name, file); } } //调用重载方法执行真正的逻辑 return getSharedPreferences(file, mode); } 这个方法主要是用来获取文件，并且把文件放入ArrayMap缓存起来以备以后再次获取file可以提高效率。key就是文件的path，value就是文件映射的File对象。 然后使用文件作为参数，调用了同名的重载方法。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:1:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#getsharedpreferences"},{"categories":null,"content":" 生成文件上述代码中出现了一个file局部变量，它是个什么角色呢，下一步我们就要来揭开它神秘的面纱。 首先看到Synchronized关键字，并且充当了ContextIml的类锁，那么带来线程安全的同时，会使所有并发访问该类的操作阻塞。那么会不会造成UI线程卡顿呢？会，但是不明显。 mSharedPrefsPaths = new ArrayMap\u003c\u003e();，那么不用想，mSharedPrefsPaths是个ArrayMap，一定是个内存缓存。 此处代码不重要，请直接看下面文字结论。 /** * 拿到SP文件地址 **/ @Override public File getSharedPreferencesPath(String name) { return makeFilename(getPreferencesDir(), name + \".xml\"); } /** * 拿到SP所在目录 **/ @UnsupportedAppUsage private File getPreferencesDir() { synchronized (mSync) { if (mPreferencesDir == null) { //创建File对象 mPreferencesDir = new File(getDataDir(), \"shared_prefs\"); } //确保文件一定存在 return ensurePrivateDirExists(mPreferencesDir); } } /** * 拿到数据目录，里面包括SP文件 **/ @Override public File getDataDir() { if (mPackageInfo != null) { File res = null; if (isCredentialProtectedStorage()) { res = mPackageInfo.getCredentialProtectedDataDirFile(); } else if (isDeviceProtectedStorage()) { res = mPackageInfo.getDeviceProtectedDataDirFile(); } else { res = mPackageInfo.getDataDirFile(); } if (res != null) { if (!res.exists() \u0026\u0026 android.os.Process.myUid() == android.os.Process.SYSTEM_UID) { Log.wtf(TAG, \"Data directory doesn't exist for package \" + getPackageName(), new Throwable()); } return res; } else { throw new RuntimeException( \"No data directory found for package \" + getPackageName()); } } else { throw new RuntimeException( \"No package details found for package \" + getPackageName()); } } private File makeFilename(File base, String name) { if (name.indexOf(File.separatorChar) \u003c 0) { final File res = new File(base, name); // We report as filesystem access here to give us the best shot at // detecting apps that will pass the path down to native code. BlockGuard.getVmPolicy().onPathAccess(res.getPath()); return res; } throw new IllegalArgumentException( \"File \" + name + \" contains a path separator\"); } 上述代码没必要研究，就是经过一系列拼拼凑凑，最后拿到/data/data/包名/shared_prefs/[name].xml 文件，然后调用ensurePrivateDirExists方法确保文件一定存在(不存在就创建)。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:1:2","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#生成文件"},{"categories":null,"content":" getSharedPreferences 重载方法接下来调用了一个重载方法，主要是创建SharedPreferenceImpl对象，通过缓存进arrayMap，并且以file作为key一一绑定。 @Override public SharedPreferences getSharedPreferences(File file, int mode) { SharedPreferencesImpl sp; synchronized (ContextImpl.class) { //获取缓存，该缓存把file和SharedPreferencesImpl一一绑定 final ArrayMap\u003cfile, sharedpreferencesimpl\u003e cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) { checkMode(mode); //创建SharedPreferencesImpl sp = new SharedPreferencesImpl(file, mode); //缓存SP cache.put(file, sp); return sp; } } //如果开启多进程模式，或者小于3.0版本，则每次都重新加载文件 if ((mode \u0026 Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion \u003c android.os.Build.VERSION_CODES.HONEYCOMB) { sp.startReloadIfChangedUnexpectedly(); } return sp; } private ArrayMap\u003cfile, sharedpreferencesimpl\u003e getSharedPreferencesCacheLocked() { if (sSharedPrefsCache == null) { sSharedPrefsCache = new ArrayMap\u003c\u003e(); } final String packageName = getPackageName(); ArrayMap\u003cfile, sharedpreferencesimpl\u003e packagePrefs = sSharedPrefsCache.get(packageName); if (packagePrefs == null) { packagePrefs = new ArrayMap\u003c\u003e(); sSharedPrefsCache.put(packageName, packagePrefs); } return packagePrefs; } 这个重载方法，主要是创建SharedPreferencesImpl对象并且缓存，File作为key，SharedPreferencesImpl作为value，保证了File和SharedPreferencesImpl的一一对应。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:1:3","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#getsharedpreferences-重载方法"},{"categories":null,"content":" SharedPreferencesImpl构造方法 @UnsupportedAppUsage SharedPreferencesImpl(File file, int mode) { mFile = file; //创建备份文件对象 mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; mThrowable = null; //开始加载 startLoadFromDisk(); } /** * 创建一个同名文件，以.bak作为后缀 **/ static File makeBackupFile(File prefsFile) { return new File(prefsFile.getPath() + \".bak\"); } 在构造方法中，在sp所在目录中先创建了一个以“.bak”为后缀的备份文件的对象，然后在子线程中从硬盘加载文件： /** *在子线程加载文件 **/ @UnsupportedAppUsage private void startLoadFromDisk() { synchronized (mLock) { // 变更标志位 mLoaded = false; } //开启子线程从硬盘加载文件 new Thread(\"SharedPreferencesImpl-load\") { public void run() { loadFromDisk(); } }.start(); } private void loadFromDisk() { synchronized (mLock) { //dlc机制 if (mLoaded) { return; } //如果备份文件实体存在，则从备份恢复sp文件 if (mBackupFile.exists()) { mFile.delete(); mBackupFile.renameTo(mFile); } } Map\u003cstring, object=\"object\"\u003e map = null; StructStat stat = null; Throwable thrown = null; try { stat = Os.stat(mFile.getPath()); if (mFile.canRead()) { BufferedInputStream str = null; try { //读取文件内容 str = new BufferedInputStream( new FileInputStream(mFile), 16 * 1024); //采用poll方式解析xml map = (Map\u003cstring, object=\"object\"\u003e) XmlUtils.readMapXml(str); } catch (Exception e) { Log.w(TAG, \"Cannot read \" + mFile.getAbsolutePath(), e); } finally { IoUtils.closeQuietly(str); } } } catch (ErrnoException e) { // An errno exception means the stat failed. Treat as empty/non-existing by // ignoring. } catch (Throwable t) { thrown = t; } //注意这个锁 synchronized (mLock) { //变更标志位 mLoaded = true; mThrowable = thrown; try { if (thrown == null) { if (map != null) { mMap = map; mStatTimestamp = stat.st_mtim; mStatSize = stat.st_size; } else { mMap = new HashMap\u003c\u003e(); } } } catch (Throwable t) { mThrowable = t; } finally { //唯一唤醒锁的时机 mLock.notifyAll(); } } } getXXX() @Override @Nullable public String getString(String key, @Nullable String defValue) { //注意这个锁 synchronized (mLock) { //持续等待 awaitLoadedLocked(); String v = (String)mMap.get(key); return v != null ? v : defValue; } } @GuardedBy(\"mLock\") private void awaitLoadedLocked() { if (!mLoaded) { BlockGuard.getThreadPolicy().onReadFromDisk(); } while (!mLoaded) { try { mLock.wait(); } catch (InterruptedException unused) { } } if (mThrowable != null) { throw new IllegalStateException(mThrowable); } } 这里要注意的就是，getXXX()方法与构造方法中读取文件的地方是共享同一把锁mLock，从而使这两个方法存在互斥关系。如果文件很大，那么程序运行sharedPreferenceImpl构造方法的耗时就会比较长，此时调用getXXX()方法因为互斥锁的关系，就会持续等待，一直到构造方法执行完毕之后才能返回结果，导致主线程被阻塞，出现UI卡顿，甚至出现ANR。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:1:4","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#sharedpreferencesimpl构造方法"},{"categories":null,"content":" SharedPreferencesImpl构造方法 @UnsupportedAppUsage SharedPreferencesImpl(File file, int mode) { mFile = file; //创建备份文件对象 mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; mThrowable = null; //开始加载 startLoadFromDisk(); } /** * 创建一个同名文件，以.bak作为后缀 **/ static File makeBackupFile(File prefsFile) { return new File(prefsFile.getPath() + \".bak\"); } 在构造方法中，在sp所在目录中先创建了一个以“.bak”为后缀的备份文件的对象，然后在子线程中从硬盘加载文件： /** *在子线程加载文件 **/ @UnsupportedAppUsage private void startLoadFromDisk() { synchronized (mLock) { // 变更标志位 mLoaded = false; } //开启子线程从硬盘加载文件 new Thread(\"SharedPreferencesImpl-load\") { public void run() { loadFromDisk(); } }.start(); } private void loadFromDisk() { synchronized (mLock) { //dlc机制 if (mLoaded) { return; } //如果备份文件实体存在，则从备份恢复sp文件 if (mBackupFile.exists()) { mFile.delete(); mBackupFile.renameTo(mFile); } } Map map = null; StructStat stat = null; Throwable thrown = null; try { stat = Os.stat(mFile.getPath()); if (mFile.canRead()) { BufferedInputStream str = null; try { //读取文件内容 str = new BufferedInputStream( new FileInputStream(mFile), 16 * 1024); //采用poll方式解析xml map = (Map) XmlUtils.readMapXml(str); } catch (Exception e) { Log.w(TAG, \"Cannot read \" + mFile.getAbsolutePath(), e); } finally { IoUtils.closeQuietly(str); } } } catch (ErrnoException e) { // An errno exception means the stat failed. Treat as empty/non-existing by // ignoring. } catch (Throwable t) { thrown = t; } //注意这个锁 synchronized (mLock) { //变更标志位 mLoaded = true; mThrowable = thrown; try { if (thrown == null) { if (map != null) { mMap = map; mStatTimestamp = stat.st_mtim; mStatSize = stat.st_size; } else { mMap = new HashMap\u003c\u003e(); } } } catch (Throwable t) { mThrowable = t; } finally { //唯一唤醒锁的时机 mLock.notifyAll(); } } } getXXX() @Override @Nullable public String getString(String key, @Nullable String defValue) { //注意这个锁 synchronized (mLock) { //持续等待 awaitLoadedLocked(); String v = (String)mMap.get(key); return v != null ? v : defValue; } } @GuardedBy(\"mLock\") private void awaitLoadedLocked() { if (!mLoaded) { BlockGuard.getThreadPolicy().onReadFromDisk(); } while (!mLoaded) { try { mLock.wait(); } catch (InterruptedException unused) { } } if (mThrowable != null) { throw new IllegalStateException(mThrowable); } } 这里要注意的就是，getXXX()方法与构造方法中读取文件的地方是共享同一把锁mLock，从而使这两个方法存在互斥关系。如果文件很大，那么程序运行sharedPreferenceImpl构造方法的耗时就会比较长，此时调用getXXX()方法因为互斥锁的关系，就会持续等待，一直到构造方法执行完毕之后才能返回结果，导致主线程被阻塞，出现UI卡顿，甚至出现ANR。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:1:4","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#getxxx"},{"categories":null,"content":" 阶段总结getSharedPreferences(String name,int mode)方法用来初始化SP，主要就是创建xml文件，进而使用文件和mode创建getSharedPreferencesImpl对象并且返回。 而在创建getSharedPreferencesImpl时就会开启一个子线程从硬盘解析xml文件到内存中，同时创建一个以.bat为后缀的备份文件。 如果在构造方法读取文件期间调用了getXXX()方法，后者会持续等待前者完成之后才执行，会造成UI卡顿甚至ANR。 当开启多进程模式时，每次调用getSharedPreferences()时都会重新读取文件。因为SP不知道文件是否已被更新，所以只能每次重新读取。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:1:5","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#阶段总结"},{"categories":null,"content":" Editor","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#editor"},{"categories":null,"content":" 获取按照SP的使用流程，下一步就是要获取到Editor对象了，我们通过Editor提供的putXXX()方法来向SP中写入数据。 Editor是一个接口，提供了一些列的put虚方法。接口是不能直接调用的，所以我们调用的其实是他的实现类——EditorImpl，它是getSharedPreferencesImpl的内部匿名类，由于内部匿名类持有外部类的引用，那么它就可以访问外层类的成员！ @Override public Editor edit() { //又看到了这把锁 synchronized (mLock) { //持续等待 awaitLoadedLocked(); } //创建EditorImpl return new EditorImpl(); } 每次调用sp.editor()方法，也会共享mLock这把锁，那么同样也存在上面说的问题，会出现卡顿。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#获取"},{"categories":null,"content":" EditorImpl定义和Put操作 public final class EditorImpl implements Editor { //一把锁 private final Object mEditorLock = new Object(); //缓存 @GuardedBy(\"mEditorLock\") private final Map\u003cstring, object\u003e mModified = new HashMap\u003c\u003e(); //标志位 @GuardedBy(\"mEditorLock\") private boolean mClear = false; //喜闻乐见的putString @Override public Editor putString(String key, @Nullable String value) { synchronized (mEditorLock) { mModified.put(key, value); return this; } } ...... 代码很简单，put操作其实就是对HashMap缓存进行写入，同时为了保证线程安全，加了锁。每个PUT操作都是互斥关系。改动并没有即时提交到硬盘文件，也没有提交到真正的缓存mMap，而是提交到了editor内部的缓存mModified里面了。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:2","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#editorimpl定义和put操作"},{"categories":null,"content":" remove @Override public Editor remove(String key) { synchronized (mEditorLock) { //为何不设置为null?; mModified.put(key, this); return this; } } 当我看到remove()方法定义时，我惊呆了！mModified里面放了this，而this又持有了mModified，这不就造成循环引用了吗，不会出问题吗？希望日后能找到答案吧。 我觉得一般人都会设置null吧。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:3","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#remove"},{"categories":null,"content":" clear @Override public Editor clear() { synchronized (mEditorLock) { mClear = true; return this; } } clear方法也是非常奇怪，只是设置了一下标志位，并没有做其他的事情。 小结怎样解决卡顿问题？ 尽量把大文件拆分成多个小文件。 尽量提前初始化sp。 然后尽量不要在初始化之后马上就用sp。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:4","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#clear"},{"categories":null,"content":" clear @Override public Editor clear() { synchronized (mEditorLock) { mClear = true; return this; } } clear方法也是非常奇怪，只是设置了一下标志位，并没有做其他的事情。 小结怎样解决卡顿问题？ 尽量把大文件拆分成多个小文件。 尽量提前初始化sp。 然后尽量不要在初始化之后马上就用sp。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:4","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#小结"},{"categories":null,"content":" commit() @Override public boolean commit() { //提交到内存 MemoryCommitResult mcr = commitToMemory(); //子线程写入文件 SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null); try { //计数锁等待 mcr.writtenToDiskLatch.await(); } catch (InterruptedException e) { return false; } finally { } //通知监视器 notifyListeners(mcr); //返回读写结果true or false return mcr.writeToDiskResult; } commit方法通过计数锁阻塞了当前线程，等待子线程中的写操作完成，才会被唤醒，充分体现了线程协作的思想。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:5","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#commit"},{"categories":null,"content":" apply() @Override public void apply() { //提交到内存 final MemoryCommitResult mcr = commitToMemory(); //其实并不起作用，迷之操作 final Runnable awaitCommit = new Runnable() { @Override public void run() { try { //计数锁开始等待 mcr.writtenToDiskLatch.await(); } catch (InterruptedException ignored) { } } }; //添加生命周期回调 QueuedWork.addFinisher(awaitCommit); Runnable postWriteRunnable = new Runnable() { @Override public void run() { //利用计数锁阻塞当前线程 awaitCommit.run(); //移除生命周期回调 QueuedWork.removeFinisher(awaitCommit); } }; //子线程写入文件 SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); //通知监视器 notifyListeners(mcr); } ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:6","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#apply"},{"categories":null,"content":" 小结这两个方法主要干了三件事： 调用commitToMemory()方法从mModified提交改动到mMap； 调用SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);把改动写入文件； 调用notifyListeners(mcr);通知监视器。 不同点在于，commit方法在写入文件时，通过计数锁阻塞了当前线程，那么如果在主线程调用commit的话，就会造成卡顿了。而apply方法是把计数锁放到了另一个子线程中去执行了，所以阻塞的是另一个子线程，在一般情况下对主线程没有影响。 但是，当生命周期处于handleStopService() 、 handlePauseActivity() 、 handleStopActivity()时，会调用 QueuedWork的waitToFinish()方法，在这个方法中会遍历执行所有的finisher，所以如果内容很多，Apply方法还是会引起ANR。 最后，apply方法没有返回写入的成功失败。 怎么解决ANR问题？ 我觉得在子线程中调用commit方法应该是个不错的选择吧。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:7","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#小结-1"},{"categories":null,"content":" enqueueDiskWritecommit和apply两个方法都是在主线程调用了这个方法完成写入： /** *使已经提交给内存的结果排队，以将其写入磁盘。它们将按入队的顺序一次写入磁盘 **/ private void enqueueDiskWrite(final MemoryCommitResult mcr, final Runnable postWriteRunnable) { //commit-true apply-false final boolean isFromSyncCommit = (postWriteRunnable == null); final Runnable writeToDiskRunnable = new Runnable() { @Override public void run() { synchronized (mWritingToDiskLock) { writeToFile(mcr, isFromSyncCommit); } synchronized (mLock) { //文件写完之后才会减1 mDiskWritesInFlight--; } //apply会执行 if (postWriteRunnable != null) { //主要是为了移除Finisher postWriteRunnable.run(); } } }; // commit执行 if (isFromSyncCommit) { boolean wasEmpty = false; synchronized (mLock) { //如果在commit之后紧接着又调用了commit，那么这里就是false了 wasEmpty = mDiskWritesInFlight == 1; } if (wasEmpty) { writeToDiskRunnable.run(); return; } } // apply执行；频繁commit时后面的commit会转为异步执行 QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit); } 在这里先定义了一个Runnable叫做writeToDiskRunnable ，一看名字就知道是用来IO写磁盘的。所以其中必然有writeToFile方法的调用啦。由于在同一线程顺序执行，writeToFile方法中必然会把mcr.writtenToDiskLatch.countDown()，所以后面的postWriteRunnable.run();只是为了移除finisher，而之前的awaitCommit这个Runnable中的mcr.writtenToDiskLatch.await();并没有起什么作用。 我们看到，系统通过变换mDiskWritesInFlight尽可能把commit转换为apply去执行。 commit在当前线程就直接run了，而apply则是提交给了QueuedWork.queue(writeToDiskRunnable,false)。 这里要注意mDiskWritesInFlight这个计数器只有在commitToMemory()方法中才会++，只有在writeToFile()完成后才会–，所以当commit之后，紧接着再次调用commit，那么之后的commit都会转成异步方式执行写入，而异步是通过HandlerThread实现的（8.0以前则是通过SingleThreadPool实现），QueuedWork.queue()方法是把任务提交到了一个静态队列里面，由HandlerThread顺序执行。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:8","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#enqueuediskwrite"},{"categories":null,"content":" commitToMemory // Returns true if any changes were made private MemoryCommitResult commitToMemory() { long memoryStateGeneration; boolean keysCleared = false; List\u003cString\u003e keysModified = null; Set\u003cOnSharedPreferenceChangeListener\u003e listeners = null; Map\u003cString, Object\u003e mapToWriteToDisk; //注意这把锁 synchronized (SharedPreferencesImpl.this.mLock) { if (mDiskWritesInFlight \u003e 0) { mMap = new HashMap\u003cString, Object\u003e(mMap); } // 转换对象 mapToWriteToDisk = mMap; mDiskWritesInFlight++; //同样是转换对象 boolean hasListeners = mListeners.size() \u003e 0; if (hasListeners) { keysModified = new ArrayList\u003cString\u003e(); listeners = new HashSet\u003cOnSharedPreferenceChangeListener\u003e(mListeners.keySet()); } //又一把锁 synchronized (mEditorLock) { boolean changesMade = false; //注意这个标志位，为true说明调用过editor.clear()方法 if (mClear) { if (!mapToWriteToDisk.isEmpty()) { changesMade = true; mapToWriteToDisk.clear(); } keysCleared = true; mClear = false; } //遍历拷贝 for (Map.Entry\u003cString, Object\u003e e : mModified.entrySet()) { String k = e.getKey(); Object v = e.getValue(); if (v == this || v == null) {//说明被editor.remove()过了 if (!mapToWriteToDisk.containsKey(k)) { continue; } mapToWriteToDisk.remove(k); } else { if (mapToWriteToDisk.containsKey(k)) { Object existingValue = mapToWriteToDisk.get(k); if (existingValue != null \u0026\u0026 existingValue.equals(v)) {//如果值没变就跳过 continue; } } mapToWriteToDisk.put(k, v); } changesMade = true; if (hasListeners) { keysModified.add(k); } } //清除editor缓存，释放内存 mModified.clear(); if (changesMade) { mCurrentMemoryStateGeneration++; } memoryStateGeneration = mCurrentMemoryStateGeneration; } } //返回结果 return new MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified, listeners, mapToWriteToDisk); } commitToMemory方法顾名思义就是把editor的mModified中的值提交到sharedferenceImpl的mMap。 这里加了SharedPreferencesImpl.this.mLock，说明多次调用commit或apply方法都会阻塞执行，而且在进行commit或者apply还没结束时就调用getXXX()，依然会造成卡顿。 而这里出现的第二把锁mEditorLock是为了保证mModified的线程安全。 MemoryCommitResultMemoryCommitResult是一个打包类，它把当前的内存缓存、内存状态、监听回调、写入结果全部装箱到一起。 private static class MemoryCommitResult { //内存状态版本号 final long memoryStateGeneration; final boolean keysCleared; @Nullable final List\u003cstring\u003e keysModified; @Nullable final Set\u003consharedpreferencechangelistener\u003e listeners; final Map\u003cstring, object\u003e mapToWriteToDisk; final CountDownLatch writtenToDiskLatch = new CountDownLatch(1); @GuardedBy(\"mWritingToDiskLock\") volatile boolean writeToDiskResult = false; boolean wasWritten = false; //私有构造方法 private MemoryCommitResult(long memoryStateGeneration, boolean keysCleared, @Nullable List\u003cstring\u003e keysModified, @Nullable Set\u003consharedpreferencechangelistener\u003e listeners, Map\u003cstring, object\u003e mapToWriteToDisk) { this.memoryStateGeneration = memoryStateGeneration; this.keysCleared = keysCleared; this.keysModified = keysModified; this.listeners = listeners; this.mapToWriteToDisk = mapToWriteToDisk; } //唯一提供的方法，用来变更标记为，储存写入结果 //只有这里能唤醒计数锁！！！ void setDiskWriteResult(boolean wasWritten, boolean result) { this.wasWritten = wasWritten; writeToDiskResult = result; writtenToDiskLatch.countDown(); } } ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:9","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#committomemory"},{"categories":null,"content":" commitToMemory // Returns true if any changes were made private MemoryCommitResult commitToMemory() { long memoryStateGeneration; boolean keysCleared = false; List keysModified = null; Set listeners = null; Map mapToWriteToDisk; //注意这把锁 synchronized (SharedPreferencesImpl.this.mLock) { if (mDiskWritesInFlight \u003e 0) { mMap = new HashMap(mMap); } // 转换对象 mapToWriteToDisk = mMap; mDiskWritesInFlight++; //同样是转换对象 boolean hasListeners = mListeners.size() \u003e 0; if (hasListeners) { keysModified = new ArrayList(); listeners = new HashSet(mListeners.keySet()); } //又一把锁 synchronized (mEditorLock) { boolean changesMade = false; //注意这个标志位，为true说明调用过editor.clear()方法 if (mClear) { if (!mapToWriteToDisk.isEmpty()) { changesMade = true; mapToWriteToDisk.clear(); } keysCleared = true; mClear = false; } //遍历拷贝 for (Map.Entry e : mModified.entrySet()) { String k = e.getKey(); Object v = e.getValue(); if (v == this || v == null) {//说明被editor.remove()过了 if (!mapToWriteToDisk.containsKey(k)) { continue; } mapToWriteToDisk.remove(k); } else { if (mapToWriteToDisk.containsKey(k)) { Object existingValue = mapToWriteToDisk.get(k); if (existingValue != null \u0026\u0026 existingValue.equals(v)) {//如果值没变就跳过 continue; } } mapToWriteToDisk.put(k, v); } changesMade = true; if (hasListeners) { keysModified.add(k); } } //清除editor缓存，释放内存 mModified.clear(); if (changesMade) { mCurrentMemoryStateGeneration++; } memoryStateGeneration = mCurrentMemoryStateGeneration; } } //返回结果 return new MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified, listeners, mapToWriteToDisk); } commitToMemory方法顾名思义就是把editor的mModified中的值提交到sharedferenceImpl的mMap。 这里加了SharedPreferencesImpl.this.mLock，说明多次调用commit或apply方法都会阻塞执行，而且在进行commit或者apply还没结束时就调用getXXX()，依然会造成卡顿。 而这里出现的第二把锁mEditorLock是为了保证mModified的线程安全。 MemoryCommitResultMemoryCommitResult是一个打包类，它把当前的内存缓存、内存状态、监听回调、写入结果全部装箱到一起。 private static class MemoryCommitResult { //内存状态版本号 final long memoryStateGeneration; final boolean keysCleared; @Nullable final List keysModified; @Nullable final Set listeners; final Map mapToWriteToDisk; final CountDownLatch writtenToDiskLatch = new CountDownLatch(1); @GuardedBy(\"mWritingToDiskLock\") volatile boolean writeToDiskResult = false; boolean wasWritten = false; //私有构造方法 private MemoryCommitResult(long memoryStateGeneration, boolean keysCleared, @Nullable List keysModified, @Nullable Set listeners, Map mapToWriteToDisk) { this.memoryStateGeneration = memoryStateGeneration; this.keysCleared = keysCleared; this.keysModified = keysModified; this.listeners = listeners; this.mapToWriteToDisk = mapToWriteToDisk; } //唯一提供的方法，用来变更标记为，储存写入结果 //只有这里能唤醒计数锁！！！ void setDiskWriteResult(boolean wasWritten, boolean result) { this.wasWritten = wasWritten; writeToDiskResult = result; writtenToDiskLatch.countDown(); } } ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:9","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#memorycommitresult"},{"categories":null,"content":" apply方法的QueuedWork机制 /** * @hide 很奇怪为啥好东西都不让我们用呢？ */ public class QueuedWork { private static final long DELAY = 100; /** 我是一把锁 */ private static final Object sLock = new Object(); private static Object sProcessingWork = new Object(); @GuardedBy(\"sLock\") @UnsupportedAppUsage private static final LinkedList\u003cRunnable\u003e sFinishers = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static Handler sHandler = null; /** Work queued via {@link #queue} */ @GuardedBy(\"sLock\") private static final LinkedList\u003cRunnable\u003e sWork = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static boolean sCanDelay = true; /** * Add task */ @UnsupportedAppUsage public static void addFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.add(finisher); } } /** * Remove task */ @UnsupportedAppUsage public static void removeFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.remove(finisher); } } /** * 在主线程立即处理剩余任务 */ public static void waitToFinish() { boolean hadMessages = false; Handler handler = getHandler(); synchronized (sLock) { //解除loop if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) { //移除消息，使handlerThread剩余的任务不再执行了 handler.removeMessages(QueuedWorkHandler.MSG_RUN); } // We should not delay any work as this might delay the finishers sCanDelay = false; } //线程使用自检 StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites(); try { //当生命周期变化时，系统会主动触发写入，这可是在主线程哦 processPendingWork(); } finally { //允许在当前线程进行文件写入操作 StrictMode.setThreadPolicy(oldPolicy); } //事后检查机制，保证所有finisher都被执行 try { while (true) { Runnable finisher; synchronized (sLock) { finisher = sFinishers.poll(); } //由于在同一线程中先调用了processPendingWork()，完成写操作后就会remove掉finisher，所以大多数情况会走到这里 if (finisher == null) { break; } finisher.run(); } } finally { sCanDelay = true; } } //同一个方法在7.0上的实现 // 在一个单线程的线程池中执行，就单纯的靠countDownLatch.await()来等待全部任务执行完毕。 public static void waitToFinish() { Runnable toFinish; while ((toFinish = sPendingWorkFinishers.poll()) != null) { toFinish.run(); } } /** * 一看就懂 */ public static boolean hasPendingWork() { synchronized (sLock) { return !sWork.isEmpty(); } } /** * 异步任务调度,其实就是切换到工作线程 * @param shouldDelay apply=false */ @UnsupportedAppUsage public static void queue(Runnable work, boolean shouldDelay) { Handler handler = getHandler(); synchronized (sLock) { sWork.add(work); if (shouldDelay \u0026\u0026 sCanDelay) { handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY); } else { handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN); } } } /** * 创建一个HandlerThread，并且返回一个单例的Handler * queue方法和waitToFinish中调用 */ @UnsupportedAppUsage private static Handler getHandler() { synchronized (sLock) { if (sHandler == null) { HandlerThread handlerThread = new HandlerThread(\"queued-work-looper\", Process.THREAD_PRIORITY_FOREGROUND); handlerThread.start(); sHandler = new QueuedWorkHandler(handlerThread.getLooper()); } return sHandler; } } /** * 自定义的Handler **/ private static class QueuedWorkHandler extends Handler { static final int MSG_RUN = 1; QueuedWorkHandler(Looper looper) { super(looper); } public void handleMessage(Message msg) { if (msg.what == MSG_RUN) { //切换到了handlerThread所在线程 processPendingWork(); } } } /** * 用来处理挂起的任务，核心方法，遍历执行task，此时已切换到工作线程 **/ private static void processPendingWork() { //这里又是一把锁 synchronized (sProcessingWork) { LinkedList\u003cRunnable\u003e work; //这里的锁注意一下 synchronized (sLock) { //浅拷贝，这里的work其实是writeToDiskRunnable，包含文件的写入操作和finisher调用 work = (LinkedList\u003cRunnable\u003e) sWork.clone(); //释放内存 sWork.clear(); //释放msg getHandler().removeMessages(QueuedWorkHandler.MSG_RUN); } //遍历执行task if (work.size() \u003e 0) { for (Runnable w : work) { w.run(); } } } } } Activity在OnPause时会调用ActivityThread的handleStopActivity方法: @Override public void handleStopActivity(IBinder token, int configChanges, PendingTransactionActions pendingActions, boolean finalStateRequest, String reason) { final ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; final StopInfo stopInfo = new StopInfo(); performStopActivityInner(r, stopInfo, true ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:10","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#apply方法的queuedwork机制"},{"categories":null,"content":" apply方法的QueuedWork机制 /** * @hide 很奇怪为啥好东西都不让我们用呢？ */ public class QueuedWork { private static final long DELAY = 100; /** 我是一把锁 */ private static final Object sLock = new Object(); private static Object sProcessingWork = new Object(); @GuardedBy(\"sLock\") @UnsupportedAppUsage private static final LinkedList sFinishers = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static Handler sHandler = null; /** Work queued via {@link #queue} */ @GuardedBy(\"sLock\") private static final LinkedList sWork = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static boolean sCanDelay = true; /** * Add task */ @UnsupportedAppUsage public static void addFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.add(finisher); } } /** * Remove task */ @UnsupportedAppUsage public static void removeFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.remove(finisher); } } /** * 在主线程立即处理剩余任务 */ public static void waitToFinish() { boolean hadMessages = false; Handler handler = getHandler(); synchronized (sLock) { //解除loop if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) { //移除消息，使handlerThread剩余的任务不再执行了 handler.removeMessages(QueuedWorkHandler.MSG_RUN); } // We should not delay any work as this might delay the finishers sCanDelay = false; } //线程使用自检 StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites(); try { //当生命周期变化时，系统会主动触发写入，这可是在主线程哦 processPendingWork(); } finally { //允许在当前线程进行文件写入操作 StrictMode.setThreadPolicy(oldPolicy); } //事后检查机制，保证所有finisher都被执行 try { while (true) { Runnable finisher; synchronized (sLock) { finisher = sFinishers.poll(); } //由于在同一线程中先调用了processPendingWork()，完成写操作后就会remove掉finisher，所以大多数情况会走到这里 if (finisher == null) { break; } finisher.run(); } } finally { sCanDelay = true; } } //同一个方法在7.0上的实现 // 在一个单线程的线程池中执行，就单纯的靠countDownLatch.await()来等待全部任务执行完毕。 public static void waitToFinish() { Runnable toFinish; while ((toFinish = sPendingWorkFinishers.poll()) != null) { toFinish.run(); } } /** * 一看就懂 */ public static boolean hasPendingWork() { synchronized (sLock) { return !sWork.isEmpty(); } } /** * 异步任务调度,其实就是切换到工作线程 * @param shouldDelay apply=false */ @UnsupportedAppUsage public static void queue(Runnable work, boolean shouldDelay) { Handler handler = getHandler(); synchronized (sLock) { sWork.add(work); if (shouldDelay \u0026\u0026 sCanDelay) { handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY); } else { handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN); } } } /** * 创建一个HandlerThread，并且返回一个单例的Handler * queue方法和waitToFinish中调用 */ @UnsupportedAppUsage private static Handler getHandler() { synchronized (sLock) { if (sHandler == null) { HandlerThread handlerThread = new HandlerThread(\"queued-work-looper\", Process.THREAD_PRIORITY_FOREGROUND); handlerThread.start(); sHandler = new QueuedWorkHandler(handlerThread.getLooper()); } return sHandler; } } /** * 自定义的Handler **/ private static class QueuedWorkHandler extends Handler { static final int MSG_RUN = 1; QueuedWorkHandler(Looper looper) { super(looper); } public void handleMessage(Message msg) { if (msg.what == MSG_RUN) { //切换到了handlerThread所在线程 processPendingWork(); } } } /** * 用来处理挂起的任务，核心方法，遍历执行task，此时已切换到工作线程 **/ private static void processPendingWork() { //这里又是一把锁 synchronized (sProcessingWork) { LinkedList work; //这里的锁注意一下 synchronized (sLock) { //浅拷贝，这里的work其实是writeToDiskRunnable，包含文件的写入操作和finisher调用 work = (LinkedList) sWork.clone(); //释放内存 sWork.clear(); //释放msg getHandler().removeMessages(QueuedWorkHandler.MSG_RUN); } //遍历执行task if (work.size() \u003e 0) { for (Runnable w : work) { w.run(); } } } } } Activity在OnPause时会调用ActivityThread的handleStopActivity方法: @Override public void handleStopActivity(IBinder token, int configChanges, PendingTransactionActions pendingActions, boolean finalStateRequest, String reason) { final ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; final StopInfo stopInfo = new StopInfo(); performStopActivityInner(r, stopInfo, true ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:10","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#最重要的方法writetofile"},{"categories":null,"content":" apply方法的QueuedWork机制 /** * @hide 很奇怪为啥好东西都不让我们用呢？ */ public class QueuedWork { private static final long DELAY = 100; /** 我是一把锁 */ private static final Object sLock = new Object(); private static Object sProcessingWork = new Object(); @GuardedBy(\"sLock\") @UnsupportedAppUsage private static final LinkedList sFinishers = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static Handler sHandler = null; /** Work queued via {@link #queue} */ @GuardedBy(\"sLock\") private static final LinkedList sWork = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static boolean sCanDelay = true; /** * Add task */ @UnsupportedAppUsage public static void addFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.add(finisher); } } /** * Remove task */ @UnsupportedAppUsage public static void removeFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.remove(finisher); } } /** * 在主线程立即处理剩余任务 */ public static void waitToFinish() { boolean hadMessages = false; Handler handler = getHandler(); synchronized (sLock) { //解除loop if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) { //移除消息，使handlerThread剩余的任务不再执行了 handler.removeMessages(QueuedWorkHandler.MSG_RUN); } // We should not delay any work as this might delay the finishers sCanDelay = false; } //线程使用自检 StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites(); try { //当生命周期变化时，系统会主动触发写入，这可是在主线程哦 processPendingWork(); } finally { //允许在当前线程进行文件写入操作 StrictMode.setThreadPolicy(oldPolicy); } //事后检查机制，保证所有finisher都被执行 try { while (true) { Runnable finisher; synchronized (sLock) { finisher = sFinishers.poll(); } //由于在同一线程中先调用了processPendingWork()，完成写操作后就会remove掉finisher，所以大多数情况会走到这里 if (finisher == null) { break; } finisher.run(); } } finally { sCanDelay = true; } } //同一个方法在7.0上的实现 // 在一个单线程的线程池中执行，就单纯的靠countDownLatch.await()来等待全部任务执行完毕。 public static void waitToFinish() { Runnable toFinish; while ((toFinish = sPendingWorkFinishers.poll()) != null) { toFinish.run(); } } /** * 一看就懂 */ public static boolean hasPendingWork() { synchronized (sLock) { return !sWork.isEmpty(); } } /** * 异步任务调度,其实就是切换到工作线程 * @param shouldDelay apply=false */ @UnsupportedAppUsage public static void queue(Runnable work, boolean shouldDelay) { Handler handler = getHandler(); synchronized (sLock) { sWork.add(work); if (shouldDelay \u0026\u0026 sCanDelay) { handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY); } else { handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN); } } } /** * 创建一个HandlerThread，并且返回一个单例的Handler * queue方法和waitToFinish中调用 */ @UnsupportedAppUsage private static Handler getHandler() { synchronized (sLock) { if (sHandler == null) { HandlerThread handlerThread = new HandlerThread(\"queued-work-looper\", Process.THREAD_PRIORITY_FOREGROUND); handlerThread.start(); sHandler = new QueuedWorkHandler(handlerThread.getLooper()); } return sHandler; } } /** * 自定义的Handler **/ private static class QueuedWorkHandler extends Handler { static final int MSG_RUN = 1; QueuedWorkHandler(Looper looper) { super(looper); } public void handleMessage(Message msg) { if (msg.what == MSG_RUN) { //切换到了handlerThread所在线程 processPendingWork(); } } } /** * 用来处理挂起的任务，核心方法，遍历执行task，此时已切换到工作线程 **/ private static void processPendingWork() { //这里又是一把锁 synchronized (sProcessingWork) { LinkedList work; //这里的锁注意一下 synchronized (sLock) { //浅拷贝，这里的work其实是writeToDiskRunnable，包含文件的写入操作和finisher调用 work = (LinkedList) sWork.clone(); //释放内存 sWork.clear(); //释放msg getHandler().removeMessages(QueuedWorkHandler.MSG_RUN); } //遍历执行task if (work.size() \u003e 0) { for (Runnable w : work) { w.run(); } } } } } Activity在OnPause时会调用ActivityThread的handleStopActivity方法: @Override public void handleStopActivity(IBinder token, int configChanges, PendingTransactionActions pendingActions, boolean finalStateRequest, String reason) { final ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; final StopInfo stopInfo = new StopInfo(); performStopActivityInner(r, stopInfo, true ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:10","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#备份文件"},{"categories":null,"content":" apply方法的QueuedWork机制 /** * @hide 很奇怪为啥好东西都不让我们用呢？ */ public class QueuedWork { private static final long DELAY = 100; /** 我是一把锁 */ private static final Object sLock = new Object(); private static Object sProcessingWork = new Object(); @GuardedBy(\"sLock\") @UnsupportedAppUsage private static final LinkedList sFinishers = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static Handler sHandler = null; /** Work queued via {@link #queue} */ @GuardedBy(\"sLock\") private static final LinkedList sWork = new LinkedList\u003c\u003e(); @GuardedBy(\"sLock\") private static boolean sCanDelay = true; /** * Add task */ @UnsupportedAppUsage public static void addFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.add(finisher); } } /** * Remove task */ @UnsupportedAppUsage public static void removeFinisher(Runnable finisher) { synchronized (sLock) { sFinishers.remove(finisher); } } /** * 在主线程立即处理剩余任务 */ public static void waitToFinish() { boolean hadMessages = false; Handler handler = getHandler(); synchronized (sLock) { //解除loop if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) { //移除消息，使handlerThread剩余的任务不再执行了 handler.removeMessages(QueuedWorkHandler.MSG_RUN); } // We should not delay any work as this might delay the finishers sCanDelay = false; } //线程使用自检 StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites(); try { //当生命周期变化时，系统会主动触发写入，这可是在主线程哦 processPendingWork(); } finally { //允许在当前线程进行文件写入操作 StrictMode.setThreadPolicy(oldPolicy); } //事后检查机制，保证所有finisher都被执行 try { while (true) { Runnable finisher; synchronized (sLock) { finisher = sFinishers.poll(); } //由于在同一线程中先调用了processPendingWork()，完成写操作后就会remove掉finisher，所以大多数情况会走到这里 if (finisher == null) { break; } finisher.run(); } } finally { sCanDelay = true; } } //同一个方法在7.0上的实现 // 在一个单线程的线程池中执行，就单纯的靠countDownLatch.await()来等待全部任务执行完毕。 public static void waitToFinish() { Runnable toFinish; while ((toFinish = sPendingWorkFinishers.poll()) != null) { toFinish.run(); } } /** * 一看就懂 */ public static boolean hasPendingWork() { synchronized (sLock) { return !sWork.isEmpty(); } } /** * 异步任务调度,其实就是切换到工作线程 * @param shouldDelay apply=false */ @UnsupportedAppUsage public static void queue(Runnable work, boolean shouldDelay) { Handler handler = getHandler(); synchronized (sLock) { sWork.add(work); if (shouldDelay \u0026\u0026 sCanDelay) { handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY); } else { handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN); } } } /** * 创建一个HandlerThread，并且返回一个单例的Handler * queue方法和waitToFinish中调用 */ @UnsupportedAppUsage private static Handler getHandler() { synchronized (sLock) { if (sHandler == null) { HandlerThread handlerThread = new HandlerThread(\"queued-work-looper\", Process.THREAD_PRIORITY_FOREGROUND); handlerThread.start(); sHandler = new QueuedWorkHandler(handlerThread.getLooper()); } return sHandler; } } /** * 自定义的Handler **/ private static class QueuedWorkHandler extends Handler { static final int MSG_RUN = 1; QueuedWorkHandler(Looper looper) { super(looper); } public void handleMessage(Message msg) { if (msg.what == MSG_RUN) { //切换到了handlerThread所在线程 processPendingWork(); } } } /** * 用来处理挂起的任务，核心方法，遍历执行task，此时已切换到工作线程 **/ private static void processPendingWork() { //这里又是一把锁 synchronized (sProcessingWork) { LinkedList work; //这里的锁注意一下 synchronized (sLock) { //浅拷贝，这里的work其实是writeToDiskRunnable，包含文件的写入操作和finisher调用 work = (LinkedList) sWork.clone(); //释放内存 sWork.clear(); //释放msg getHandler().removeMessages(QueuedWorkHandler.MSG_RUN); } //遍历执行task if (work.size() \u003e 0) { for (Runnable w : work) { w.run(); } } } } } Activity在OnPause时会调用ActivityThread的handleStopActivity方法: @Override public void handleStopActivity(IBinder token, int configChanges, PendingTransactionActions pendingActions, boolean finalStateRequest, String reason) { final ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; final StopInfo stopInfo = new StopInfo(); performStopActivityInner(r, stopInfo, true ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:10","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#真正的写入"},{"categories":null,"content":" notifyListeners private void notifyListeners(final MemoryCommitResult mcr) { if (mcr.listeners == null || (mcr.keysModified == null \u0026\u0026 !mcr.keysCleared)) { return; } if (Looper.myLooper() == Looper.getMainLooper()) { //如果当前是主线程，就遍历MemoryCommitResult中listener if (mcr.keysCleared \u0026\u0026 Compatibility.isChangeEnabled(CALLBACK_ON_CLEAR_CHANGE)) { for (OnSharedPreferenceChangeListener listener : mcr.listeners) { if (listener != null) { listener.onSharedPreferenceChanged(SharedPreferencesImpl.this, null); } } } for (int i = mcr.keysModified.size() - 1; i \u003e= 0; i--) { final String key = mcr.keysModified.get(i); for (OnSharedPreferenceChangeListener listener : mcr.listeners) { if (listener != null) { listener.onSharedPreferenceChanged(SharedPreferencesImpl.this, key); } } } } else { //如果当前是子线程，就切换到主线程重新调用方法 ActivityThread.sMainThreadHandler.post(() -\u003e notifyListeners(mcr)); } } 看了这个方法，我才知道SP还可以注册监听。并且只有在commit或者apply时才会触发监听。而且必定在主线程回调。那么如果监听太多，或者监听里面有耗时操作，那么必定还是会ANR。 下面是监听的用法： val sp = getSharedPreferences(\"我擦\", Context.MODE_PRIVATE) val listener = object: SharedPreferences.OnSharedPreferenceChangeListener{ override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences?, key: String?) { // do something } } sp.registerOnSharedPreferenceChangeListener(listener) sp.unregisterOnSharedPreferenceChangeListener(listener) ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:2:11","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#notifylisteners"},{"categories":null,"content":" 专题：SP的缓存机制","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#专题sp的缓存机制"},{"categories":null,"content":" 内存缓存 ContextImpl中 private ArrayMap\u003cString, File\u003e mSharedPrefsPaths; 用来缓存sp的file对象，它把name与file一一对应，用来根据name快速找到对应的file。 private static ArrayMap\u003cString, ArrayMap\u003cFile, SharedPreferencesImpl\u003e\u003e sSharedPrefsCache; 用来根据file缓存spIml对象。 private final File mFile; sp的硬盘缓存。 spImpl中 private Map\u003cString, Object\u003e mMap; 内容的内存缓存，主要用于getXXX()方法。 EditorImpl中 private final Map\u003cstring, object\u003e mModified = new HashMap\u003c\u003e(); 写缓存，主要用于putXXX()方法写入的缓存，会先存到这里，等调用commit或者apply时，通过commitToMemory方法一次性刷入mapToWriteToDisk中。 MemoryCommitResult中 final Map\u003cstring, object\u003e mapToWriteToDisk; 用来做写入前的缓存，但其实并不是缓存，而是mMap的引用。修改它就是修改mMap。 硬盘缓存 mFile ：位于/data/data/包名/shared_prefs/[name].xml，真正的sp文件，xml格式。 mBackupFile: 位于/data/data/包名/shared_prefs/[name].xml.bak,备份文件。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#内存缓存"},{"categories":null,"content":" 内存缓存 ContextImpl中 private ArrayMap mSharedPrefsPaths; 用来缓存sp的file对象，它把name与file一一对应，用来根据name快速找到对应的file。 private static ArrayMap","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#contextimpl中"},{"categories":null,"content":" 内存缓存 ContextImpl中 private ArrayMap mSharedPrefsPaths; 用来缓存sp的file对象，它把name与file一一对应，用来根据name快速找到对应的file。 private static ArrayMap","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#spimpl中"},{"categories":null,"content":" 内存缓存 ContextImpl中 private ArrayMap mSharedPrefsPaths; 用来缓存sp的file对象，它把name与file一一对应，用来根据name快速找到对应的file。 private static ArrayMap","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#editorimpl中"},{"categories":null,"content":" 内存缓存 ContextImpl中 private ArrayMap mSharedPrefsPaths; 用来缓存sp的file对象，它把name与file一一对应，用来根据name快速找到对应的file。 private static ArrayMap","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#memorycommitresult中"},{"categories":null,"content":" 内存缓存 ContextImpl中 private ArrayMap mSharedPrefsPaths; 用来缓存sp的file对象，它把name与file一一对应，用来根据name快速找到对应的file。 private static ArrayMap","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#硬盘缓存"},{"categories":null,"content":" 专题：SP的备份恢复机制 备份 private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) { //如果文件存在而备份不存在，则从源文件创建备份文件。 if (!backupFileExists) { if (!mFile.renameTo(mBackupFile)) { mcr.setDiskWriteResult(false, false); return; } } else {//如果源文件和备份都存在，则删除源文件 mFile.delete(); } ///写入源文件，此时一定会生成一个新的源文件 FileOutputStream str = createFileOutputStream(mFile); ... // 如果写入成功，就删除备份 mBackupFile.delete(); ///写入失败就删除脏文件，保留备份 mFile.delete() } 这里就一句话：写前备份，写后成功删备份，失败删源文件。 恢复 SharedPreferencesImpl(File file, int mode) { mFile = file; mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; mThrowable = null; startLoadFromDisk(); } 在spImpl的构造方法中会创建一个mBackupFile。之后，就会开始从硬盘加载，也就是startLoadFromDisk。在这个方法中会创建一个子线程，执行loadFromDisk: private void loadFromDisk() { synchronized (mLock) { if (mLoaded) { return; } //如果有备份就删掉原文件，然后从备份中恢复 if (mBackupFile.exists()) { mFile.delete(); mBackupFile.renameTo(mFile); } } //从mFile中解析xml到mMap缓存中 } 而第一次通过构造方法过来到这里时，mBackupFile还没有创建真实的物理文件，所以不会走恢复流程，而是直接从mFile中加载内容。 但是如果mBackupFile已经存在，则先删掉源文件，再从备份中恢复，最后再读取到内存缓存。 总结SP会在写入硬盘之前，先把以前的数据备份，写入成功就删除备份，失败就删除脏的源文件而保留备份。待下次初始化SP时，会重新从硬盘读取内容到缓存，此时如果存在备份，就先删掉源文件再从备份还原。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#专题sp的备份恢复机制"},{"categories":null,"content":" 专题：SP的备份恢复机制 备份 private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) { //如果文件存在而备份不存在，则从源文件创建备份文件。 if (!backupFileExists) { if (!mFile.renameTo(mBackupFile)) { mcr.setDiskWriteResult(false, false); return; } } else {//如果源文件和备份都存在，则删除源文件 mFile.delete(); } ///写入源文件，此时一定会生成一个新的源文件 FileOutputStream str = createFileOutputStream(mFile); ... // 如果写入成功，就删除备份 mBackupFile.delete(); ///写入失败就删除脏文件，保留备份 mFile.delete() } 这里就一句话：写前备份，写后成功删备份，失败删源文件。 恢复 SharedPreferencesImpl(File file, int mode) { mFile = file; mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; mThrowable = null; startLoadFromDisk(); } 在spImpl的构造方法中会创建一个mBackupFile。之后，就会开始从硬盘加载，也就是startLoadFromDisk。在这个方法中会创建一个子线程，执行loadFromDisk: private void loadFromDisk() { synchronized (mLock) { if (mLoaded) { return; } //如果有备份就删掉原文件，然后从备份中恢复 if (mBackupFile.exists()) { mFile.delete(); mBackupFile.renameTo(mFile); } } //从mFile中解析xml到mMap缓存中 } 而第一次通过构造方法过来到这里时，mBackupFile还没有创建真实的物理文件，所以不会走恢复流程，而是直接从mFile中加载内容。 但是如果mBackupFile已经存在，则先删掉源文件，再从备份中恢复，最后再读取到内存缓存。 总结SP会在写入硬盘之前，先把以前的数据备份，写入成功就删除备份，失败就删除脏的源文件而保留备份。待下次初始化SP时，会重新从硬盘读取内容到缓存，此时如果存在备份，就先删掉源文件再从备份还原。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#备份"},{"categories":null,"content":" 专题：SP的备份恢复机制 备份 private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) { //如果文件存在而备份不存在，则从源文件创建备份文件。 if (!backupFileExists) { if (!mFile.renameTo(mBackupFile)) { mcr.setDiskWriteResult(false, false); return; } } else {//如果源文件和备份都存在，则删除源文件 mFile.delete(); } ///写入源文件，此时一定会生成一个新的源文件 FileOutputStream str = createFileOutputStream(mFile); ... // 如果写入成功，就删除备份 mBackupFile.delete(); ///写入失败就删除脏文件，保留备份 mFile.delete() } 这里就一句话：写前备份，写后成功删备份，失败删源文件。 恢复 SharedPreferencesImpl(File file, int mode) { mFile = file; mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; mThrowable = null; startLoadFromDisk(); } 在spImpl的构造方法中会创建一个mBackupFile。之后，就会开始从硬盘加载，也就是startLoadFromDisk。在这个方法中会创建一个子线程，执行loadFromDisk: private void loadFromDisk() { synchronized (mLock) { if (mLoaded) { return; } //如果有备份就删掉原文件，然后从备份中恢复 if (mBackupFile.exists()) { mFile.delete(); mBackupFile.renameTo(mFile); } } //从mFile中解析xml到mMap缓存中 } 而第一次通过构造方法过来到这里时，mBackupFile还没有创建真实的物理文件，所以不会走恢复流程，而是直接从mFile中加载内容。 但是如果mBackupFile已经存在，则先删掉源文件，再从备份中恢复，最后再读取到内存缓存。 总结SP会在写入硬盘之前，先把以前的数据备份，写入成功就删除备份，失败就删除脏的源文件而保留备份。待下次初始化SP时，会重新从硬盘读取内容到缓存，此时如果存在备份，就先删掉源文件再从备份还原。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#恢复"},{"categories":null,"content":" 专题：SP的备份恢复机制 备份 private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) { //如果文件存在而备份不存在，则从源文件创建备份文件。 if (!backupFileExists) { if (!mFile.renameTo(mBackupFile)) { mcr.setDiskWriteResult(false, false); return; } } else {//如果源文件和备份都存在，则删除源文件 mFile.delete(); } ///写入源文件，此时一定会生成一个新的源文件 FileOutputStream str = createFileOutputStream(mFile); ... // 如果写入成功，就删除备份 mBackupFile.delete(); ///写入失败就删除脏文件，保留备份 mFile.delete() } 这里就一句话：写前备份，写后成功删备份，失败删源文件。 恢复 SharedPreferencesImpl(File file, int mode) { mFile = file; mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; mThrowable = null; startLoadFromDisk(); } 在spImpl的构造方法中会创建一个mBackupFile。之后，就会开始从硬盘加载，也就是startLoadFromDisk。在这个方法中会创建一个子线程，执行loadFromDisk: private void loadFromDisk() { synchronized (mLock) { if (mLoaded) { return; } //如果有备份就删掉原文件，然后从备份中恢复 if (mBackupFile.exists()) { mFile.delete(); mBackupFile.renameTo(mFile); } } //从mFile中解析xml到mMap缓存中 } 而第一次通过构造方法过来到这里时，mBackupFile还没有创建真实的物理文件，所以不会走恢复流程，而是直接从mFile中加载内容。 但是如果mBackupFile已经存在，则先删掉源文件，再从备份中恢复，最后再读取到内存缓存。 总结SP会在写入硬盘之前，先把以前的数据备份，写入成功就删除备份，失败就删除脏的源文件而保留备份。待下次初始化SP时，会重新从硬盘读取内容到缓存，此时如果存在备份，就先删掉源文件再从备份还原。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#总结"},{"categories":null,"content":" 专题：SP中的锁 mLock 主要用来保护spImpl对象的安全，它是所有访问spImpl对象的操作阻塞，已达到安全性目的。 mWritingToDiskLock：文件写入锁，当多次调用apply时可以阻塞写入。 mEditorLock：多线程调用editor.putXXX()方法时的同步锁，用来保护editor内部的mModified缓存的数据安全性。 sLock：QueuedWork中用来同步启动HandlerThread和同步访问work和finisher这两条队列的同步锁。 sProcessingWork：确保同一时间只有一个线程调用processPendingWork()方法(前面说过apply会一部调用这方法，而activityThread会在生命周期变化时同步调用这方法)。 writtenToDiskLatch: 文件写入结果MemoryCommitResult中的计数锁，阻塞当前线程，只能countDown一次，代表文件读写完成(并不代表成功)，然后才能继续执行线程。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:5:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#专题sp中的锁"},{"categories":null,"content":" 专题：SP造成的卡顿与ANR分析","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:6:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#专题sp造成的卡顿与anr分析"},{"categories":null,"content":" xml文件造成的卡顿SP在初始化过程中，要创建SPImpl对象时会创建一个子线程访问硬盘，加载并解析xml文件到内存缓存。如果这个文件比较大就会造成卡顿。那为什么在子线程中玩这一套会影响到主线程呢？就因为玩的是xml格式文件。 SP使用了高效的poll方式来解析xml成map，在此过程中会创建大量的临时对象，造成频繁的GC，而java在GC时会暂停所有的线程，当然也包括主线程，这就造成了主线程的卡顿了。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:6:1","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#xml文件造成的卡顿"},{"categories":null,"content":" 初始化后直接读取造成的卡顿在初始化过程中会调用startLoadFromDisk()加载文件，如果文件还没有加载完就在主线程调用getXXX()方法也会造成卡顿，甚至ANR。因为这两个方法都竞争**mLock**锁，并且在getXXX()中还会死循环让mLock.wait()，而只有文件全部读取完成后这把锁才会notifyAll。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:6:2","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#初始化后直接读取造成的卡顿"},{"categories":null,"content":" commit方法造成的卡顿commit是在当前线程去写入，写入完成之后还会返回结果，如果在主线程调用这个方法，就会容易引起ANR。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:6:3","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#commit方法造成的卡顿"},{"categories":null,"content":" apply方法引起的ANRapply本身是依靠handlerThread任务队列来异步写入的，但是ActivityThread在生命周期发生改变时，会在主线程主动调用QueuedWork的waitToFinish()方法，遍历执行所有的finisher，而finisher中只有一行代码，就是让mcr的计数锁去await当前线程，对于activityThread来说就是主线程。 Android8.0之后，还加入可主动调用processPendingWork()方法执行写入，所以导致Apply方法也很容易造成ANR。 而如果我们过多的使用了apply，那么就放到了QueuedWork中的一个队列，依靠仅仅一个HandlerThread，一个一个的慢慢处理。那么当生命周期改变时，这些work没有被处理完，waitToFinish()方法就会移除剩余的msg，剩下的work会切换到主线程来执行，并且靠计数锁阻塞主线程，就造成了ANR。 从这里可以看出，google希望在页面生命周期改变时，sp应该切换到主线程同步写入，宁可阻塞UI也要保证sp的写入完整性，这样才能保证到下一个页面我们直接get时能够拿到最新的值。同时这里也体现了sp应该只存入少量数据的设计思想。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:6:4","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#apply方法引起的anr"},{"categories":null,"content":" 专题：SP的问题梳理 xml格式，导致文件庞大，占用硬盘； xml解析带来的频繁GC，造成卡顿； 初始化时把所有文件内容缓存，造成内存压力； commit和apply都会造成ANR； 每次全量写入； 进程不安全； 只能在主线程监听； ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:7:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#专题sp的问题梳理"},{"categories":null,"content":" 专题：注意事项： 不要存过多内容，尤其不要存json字符串，因为json字符串中存在大量的转义字符\u0026； 尽量拆分多个sp文件； 不要在初始化sp后就直接put; 不要过多调用sp.edit()因为每次都会生成新的editor对象； 尽量使用apply方法，不要多次使用apply方法。 多进程使用依赖contentProvider。 ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:8:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#专题注意事项"},{"categories":null,"content":" 专题：改造思路 采用protobuf减少文件体积，提高序列化、反序列化效率，提高io速度； 引入懒加载机制； 增量写入； 解除监听回调的主线程限制。 终极方案当然是改用mmkv或者dataStorge ","date":"2021-04-30","objectID":"/sharedpreferences%E8%A7%A3%E8%AF%BB/:9:0","series":null,"tags":["Android"],"title":"SharedPreferences解读","uri":"/sharedpreferences%E8%A7%A3%E8%AF%BB/#专题改造思路"},{"categories":null,"content":" 原因短生命周期对象持有长生命周期对象的强引用，造成短生命周期对象在不需要使用时不能被回收。 ","date":"2021-03-24","objectID":"/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/:1:0","series":null,"tags":["Android","内存泄露","NPE"],"title":"Android内存泄露专题","uri":"/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/#原因"},{"categories":null,"content":" 静态变量导致 public class MainActivity extends AppCompatActivity { public static boolean RESULT; private static Activity mActivity; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mActivity = this; } } ","date":"2021-03-24","objectID":"/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/:1:1","series":null,"tags":["Android","内存泄露","NPE"],"title":"Android内存泄露专题","uri":"/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/#静态变量导致"},{"categories":null,"content":" LeakCanary原理 class App extends Application { @Override public void onCreate() { super.onCreate(); registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() { @Override public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) { } @Override public void onActivityStarted(@NonNull Activity activity) { } @Override public void onActivityResumed(@NonNull Activity activity) { } @Override public void onActivityPaused(@NonNull Activity activity) { } @Override public void onActivityStopped(@NonNull Activity activity) { } @Override public void onActivitySaveInstanceState(@NonNull Activity activity, @NonNull Bundle outState) { } @Override public void onActivityDestroyed(@NonNull Activity activity) { } }); } } Application提供了registerActivityLifecycleCallbacks方法，可以监听Activity的生命周期，而FragmentManager中提供了registerFragmentLifecycleCallbacks方法可以监听Fragment的生命周期。 在onActivityDestroyed方法中监听到Activity正在销毁，就用弱引用去包装这个Activity，然后放入队列里面，从线程池中obtain出一个线程，5秒之后判断这个Activity的弱引用是否为null，如果为null就是已被回收了。如果不是null，说明没有被回收，可能存在内存泄露，这时候强制GC回收他，如果还不为null，说明确实存在内存泄露。 然后通过HAHA获取内存中heap堆快找引用关系。 ","date":"2021-03-24","objectID":"/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/:1:2","series":null,"tags":["Android","内存泄露","NPE"],"title":"Android内存泄露专题","uri":"/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/#leakcanary原理"},{"categories":["policy"],"content":" 中共中央 国务院印发海南自由贸易港建设总体方案中共中央 国务院印发《海南自由贸易港建设总体方案》 新华社北京6月1日电 中共中央、国务院印发了《海南自由贸易港建设总体方案》，并发出通知，要求各地区各部门结合实际认真贯彻落实。 《海南自由贸易港建设总体方案》主要内容如下。 海南是我国最大的经济特区，具有实施全面深化改革和试验最高水平开放政策的独特优势。支持海南逐步探索、稳步推进中国特色自由贸易港建设，分步骤、分阶段建立自由贸易港政策和制度体系，是习近平总书记亲自谋划、亲自部署、亲自推动的改革开放重大举措，是党中央着眼国内国际两个大局，深入研究、统筹考虑、科学谋划作出的战略决策。当今世界正在经历新一轮大发展大变革大调整，保护主义、单边主义抬头，经济全球化遭遇更大的逆风和回头浪。在海南建设自由贸易港，是推进高水平开放，建立开放型经济新体制的根本要求；是深化市场化改革，打造法治化、国际化、便利化营商环境的迫切需要；是贯彻新发展理念，推动高质量发展，建设现代化经济体系的战略选择；是支持经济全球化，构建人类命运共同体的实际行动。为深入贯彻习近平总书记在庆祝海南建省办经济特区30周年大会上的重要讲话精神，落实《中共中央、国务院关于支持海南全面深化改革开放的指导意见》要求，加快建设高水平的中国特色自由贸易港，制定本方案。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:0:0","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#中共中央-国务院印发海南自由贸易港建设总体方案"},{"categories":["policy"],"content":" 一、总体要求","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:0","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#一总体要求"},{"categories":["policy"],"content":" （一）指导思想以习近平新时代中国特色社会主义思想为指导，全面贯彻党的十九大和十九届二中、三中、四中全会精神，坚持党的全面领导，坚持稳中求进工作总基调，坚持新发展理念，坚持高质量发展，统筹推进“五位一体”总体布局，协调推进“四个全面”战略布局，对标国际高水平经贸规则，解放思想、大胆创新，聚焦贸易投资自由化便利化，建立与高水平自由贸易港相适应的政策制度体系，建设具有国际竞争力和影响力的海关监管特殊区域，将海南自由贸易港打造成为引领我国新时代对外开放的鲜明旗帜和重要开放门户。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:1","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#一指导思想"},{"categories":["policy"],"content":" （二）基本原则 借鉴国际经验。坚持高起点谋划、高标准建设，主动适应国际经贸规则重构新趋势，充分学习借鉴国际自由贸易港（香港，新加坡？）的先进经营方式、管理方法和制度安排，形成具有国际竞争力的开放政策和制度，加快建立开放型经济新体制，增强区域辐射带动作用，打造我国深度融入全球经济体系的前沿地带。 体现中国特色。坚持党的集中统一领导，坚持中国特色社会主义道路，坚持以人民为中心，践行社会主义核心价值观，确保海南自由贸易港建设正确方向。充分发挥全国上下一盘棋和集中力量办大事的制度优势，调动各方面积极性和创造性，集聚全球优质生产要素，着力在推动制度创新、培育增长动能、构建全面开放新格局等方面取得新突破，为实现国家战略目标提供坚实支撑。加强与东南亚国家交流合作，促进与粤港澳大湾区联动发展。 符合海南定位。紧紧围绕国家赋予海南建设全面深化改革开放试验区、国家生态文明试验区、国际旅游消费中心和国家重大战略服务保障区的战略定位，充分发挥海南自然资源丰富、地理区位独特以及背靠超大规模国内市场和腹地经济等优势，抢抓全球新一轮科技革命和产业变革重要机遇，聚焦发展(来了): 旅游业 现代服务业 高新技术产业 加快培育具有海南特色的合作竞争新优势。 突出改革创新。强化改革创新意识，赋予海南更大改革自主权，支持海南全方位大力度推进改革创新，积极探索建立适应自由贸易港建设的更加灵活高效的法律法规、监管模式和管理体制，下大力气破除阻碍生产要素流动的体制机制障碍。深入推进商品和要素流动型开放，加快推动规则等制度型开放，以高水平开放带动改革全面深化。加强改革系统集成，注重协调推进，使各方面创新举措相互配合、相得益彰，提高改革创新的整体效益。 坚持底线思维。坚持稳扎稳打、步步为营，统筹安排好开放节奏和进度，成熟一项推出一项，不急于求成、急功近利。深入推进简政放权、放管结合、优化服务，全面推行准入便利、依法过程监管的制度体系，建立与国际接轨的监管标准和规范制度。加强重大风险识别和系统性风险防范，建立健全风险防控配套措施。完善重大疫情防控体制机制，健全公共卫生应急管理体系。开展常态化评估工作，及时纠偏纠错，确保海南自由贸易港建设方向正确、健康发展。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:2","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#二基本原则"},{"categories":["policy"],"content":" （三）发展目标 到2025年初步建立以贸易自由便利和投资自由便利为重点的自由贸易港政策制度体系。营商环境总体达到国内一流水平，市场主体大幅增长，产业竞争力显著提升，风险防控有力有效，适应自由贸易港建设的法律法规逐步完善，经济发展质量和效益明显改善。 感觉25年目标主要还是建立合理的政策和体系制度，优化营商环境。那么这就是个淘金期了。 到2035年自由贸易港制度体系和运作模式更加成熟，以自由、公平、法治、高水平过程监管为特征的贸易投资规则基本构建，实现贸易自由便利、投资自由便利、跨境资金流动自由便利、人员进出自由便利、运输来往自由便利和数据安全有序流动。营商环境更加优化，法律法规体系更加健全，风险防控体系更加严密，现代社会治理格局基本形成，成为我国开放型经济新高地。 35年达到成熟期，体制更加健全，相对机会就会越来越少。 到本世纪中叶全面建成具有较强国际影响力的高水平自由贸易港。 到50年基本全面建成，那么基本上资源会被头部占领，各种关系也都稳固了。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:3","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#三发展目标"},{"categories":["policy"],"content":" （三）发展目标 到2025年初步建立以贸易自由便利和投资自由便利为重点的自由贸易港政策制度体系。营商环境总体达到国内一流水平，市场主体大幅增长，产业竞争力显著提升，风险防控有力有效，适应自由贸易港建设的法律法规逐步完善，经济发展质量和效益明显改善。 感觉25年目标主要还是建立合理的政策和体系制度，优化营商环境。那么这就是个淘金期了。 到2035年自由贸易港制度体系和运作模式更加成熟，以自由、公平、法治、高水平过程监管为特征的贸易投资规则基本构建，实现贸易自由便利、投资自由便利、跨境资金流动自由便利、人员进出自由便利、运输来往自由便利和数据安全有序流动。营商环境更加优化，法律法规体系更加健全，风险防控体系更加严密，现代社会治理格局基本形成，成为我国开放型经济新高地。 35年达到成熟期，体制更加健全，相对机会就会越来越少。 到本世纪中叶全面建成具有较强国际影响力的高水平自由贸易港。 到50年基本全面建成，那么基本上资源会被头部占领，各种关系也都稳固了。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:3","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#到2025年"},{"categories":["policy"],"content":" （三）发展目标 到2025年初步建立以贸易自由便利和投资自由便利为重点的自由贸易港政策制度体系。营商环境总体达到国内一流水平，市场主体大幅增长，产业竞争力显著提升，风险防控有力有效，适应自由贸易港建设的法律法规逐步完善，经济发展质量和效益明显改善。 感觉25年目标主要还是建立合理的政策和体系制度，优化营商环境。那么这就是个淘金期了。 到2035年自由贸易港制度体系和运作模式更加成熟，以自由、公平、法治、高水平过程监管为特征的贸易投资规则基本构建，实现贸易自由便利、投资自由便利、跨境资金流动自由便利、人员进出自由便利、运输来往自由便利和数据安全有序流动。营商环境更加优化，法律法规体系更加健全，风险防控体系更加严密，现代社会治理格局基本形成，成为我国开放型经济新高地。 35年达到成熟期，体制更加健全，相对机会就会越来越少。 到本世纪中叶全面建成具有较强国际影响力的高水平自由贸易港。 到50年基本全面建成，那么基本上资源会被头部占领，各种关系也都稳固了。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:3","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#到2035年"},{"categories":["policy"],"content":" （三）发展目标 到2025年初步建立以贸易自由便利和投资自由便利为重点的自由贸易港政策制度体系。营商环境总体达到国内一流水平，市场主体大幅增长，产业竞争力显著提升，风险防控有力有效，适应自由贸易港建设的法律法规逐步完善，经济发展质量和效益明显改善。 感觉25年目标主要还是建立合理的政策和体系制度，优化营商环境。那么这就是个淘金期了。 到2035年自由贸易港制度体系和运作模式更加成熟，以自由、公平、法治、高水平过程监管为特征的贸易投资规则基本构建，实现贸易自由便利、投资自由便利、跨境资金流动自由便利、人员进出自由便利、运输来往自由便利和数据安全有序流动。营商环境更加优化，法律法规体系更加健全，风险防控体系更加严密，现代社会治理格局基本形成，成为我国开放型经济新高地。 35年达到成熟期，体制更加健全，相对机会就会越来越少。 到本世纪中叶全面建成具有较强国际影响力的高水平自由贸易港。 到50年基本全面建成，那么基本上资源会被头部占领，各种关系也都稳固了。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:3","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#到本世纪中叶"},{"categories":["policy"],"content":" （四）实施范围。海南自由贸易港的实施范围为海南岛全岛。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:1:4","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#四实施范围"},{"categories":["policy"],"content":" 二、制度设计以贸易投资自由化便利化为重点，以各类生产要素跨境自由有序安全便捷流动和现代产业体系为支撑，以特殊的税收制度安排、高效的社会治理体系和完备的法治体系为保障，在明确分工和机制措施、守住不发生系统性风险底线的前提下，构建海南自由贸易港政策制度体系。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:0","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#二制度设计"},{"categories":["policy"],"content":" （一）贸易自由便利。在实现有效监管的前提下，建设全岛封关运作的海关监管特殊区域。对货物贸易，实行以“零关税”为基本特征的自由化便利化制度安排。对服务贸易，实行以“既准入又准营”为基本特征的自由化便利化政策举措。 “一线”放开。在海南自由贸易港与中华人民共和国关境外其他国家和地区之间设立“一线”。“一线”进（出）境环节强化安全准入（出）监管，加强口岸公共卫生安全、国门生物安全、食品安全、产品质量安全管控。在确保履行我国缔结或参加的国际条约所规定义务的前提下，制定海南自由贸易港禁止、限制进出口的货物、物品清单，清单外货物、物品自由进出，海关依法进行监管。制定海南自由贸易港进口征税商品目录，目录外货物进入自由贸易港免征进口关税。以联运提单付运的转运货物不征税、不检验。从海南自由贸易港离境的货物、物品按出口管理。实行便捷高效的海关监管，建设高标准国际贸易“单一窗口”。 “二线”管住。在海南自由贸易港与中华人民共和国关境内的其他地区（以下简称内地）之间设立“二线”。货物从海南自由贸易港进入内地，原则上按进口规定办理相关手续，照章征收关税和进口环节税。对鼓励类产业企业生产的不含进口料件或者含进口料件在海南自由贸易港加工增值超过30%（含）的货物，经“二线”进入内地免征进口关税，（但是）照章征收进口环节增值税、消费税。行邮物品由海南自由贸易港进入内地，按规定进行监管，照章征税。对海南自由贸易港前往内地的运输工具，简化进口管理。货物、物品及运输工具由内地进入海南自由贸易港，按国内流通规定管理。内地货物经海南自由贸易港中转再运往内地无需办理报关手续，应在自由贸易港内海关监管作业场所（场地）装卸，与其他海关监管货物分开存放，并设立明显标识。场所经营企业应根据海关监管需要，向海关传输货物进出场所等信息。 岛内自由。海关对海南自由贸易港内企业及机构实施低干预、高效能的精准监管，实现自由贸易港内企业自由生产经营。由境外启运，经海南自由贸易港换装、分拣集拼，再运往其他国家或地区的中转货物，简化办理海关手续。货物在海南自由贸易港内不设存储期限，可自由选择存放地点。实施“零关税”的货物，海关免于实施常规监管。 推进服务贸易自由便利。实施跨境服务贸易负面清单制度，破除跨境交付、境外消费、自然人移动等服务贸易模式下存在的各种壁垒，给予境外服务提供者国民待遇。实施与跨境服务贸易配套的资金支付与转移制度。在告知、资格要求、技术标准、透明度、监管一致性等方面，进一步规范影响服务贸易自由便利的国内规制。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:1","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#一贸易自由便利"},{"categories":["policy"],"content":" （二）投资自由便利。大幅放宽海南自由贸易港市场准入，强化产权保护，保障公平竞争，打造公开、透明、可预期的投资环境，进一步激发各类市场主体活力。 实施市场准入承诺即入制。严格落实“非禁即入”，在“管得住”的前提下，对具有强制性标准的领域，原则上取消许可和审批，建立健全备案制度，市场主体承诺符合相关要求并提交相关材料进行备案，即可开展投资经营活动。备案受理机构从收到备案时起，即开始承担审查责任。对外商投资实施准入前国民待遇加负面清单管理制度，大幅减少禁止和限制条款。 创新完善投资自由制度。实行以过程监管为重点的投资便利制度。建立以电子证照为主的设立便利，以“有事必应”、“无事不扰”为主的经营便利，以公告承诺和优化程序为主的注销便利，以尽职履责为主的破产便利等政策制度。 建立健全公平竞争制度。强化竞争政策的基础性地位，确保各类所有制市场主体在要素获取、标准制定、准入许可、经营运营、优惠政策等方面享受平等待遇。政府采购对内外资企业一视同仁。加强和优化反垄断执法，打破行政性垄断，防止市场垄断，维护公平竞争市场秩序。 完善产权保护制度。依法保护私人和法人财产的取得、使用、处置和继承的权利，以及依法征收私人和法人财产时被征收财产所有人得到补偿的权利。落实公司法等法律法规，加强对中小投资者的保护。加大知识产权侵权惩罚力度，建立健全知识产权领域市场主体信用分类监管、失信惩戒等机制。加强区块链技术在知识产权交易、存证等方面应用，探索适合自由贸易港发展的新模式。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:2","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#二投资自由便利"},{"categories":["policy"],"content":" （三）跨境资金流动自由便利。坚持金融服务实体经济，重点围绕贸易投资自由化便利化，分阶段开放资本项目，有序推进海南自由贸易港与境外资金自由便利流动。 构建多功能自由贸易账户体系。以国内现有本外币账户和自由贸易账户为基础，构建海南金融对外开放基础平台。通过金融账户隔离，建立资金“电子围网”，为海南自由贸易港与境外实现跨境资金自由便利流动提供基础条件。 便利跨境贸易投资资金流动。进一步推动跨境货物贸易、服务贸易和新型国际贸易结算便利化，实现银行真实性审核从事前审查转为事后核查。在跨境直接投资交易环节，按照准入前国民待遇加负面清单模式简化管理，提高兑换环节登记和兑换的便利性（能否比肩香港？），探索适应市场需求新形态的跨境投资管理。在跨境融资领域，探索建立新的外债管理体制，试点合并交易环节外债管理框架，完善企业发行外债备案登记制管理，全面实施全口径跨境融资宏观审慎管理，稳步扩大跨境资产转让范围，提升外债资金汇兑便利化水平。在跨境证券投融资领域，重点服务实体经济投融资需求，扶持海南具有特色和比较优势的产业发展，并在境外上市、发债等方面给予优先支持，简化汇兑管理。 扩大金融业对内对外开放。率先在海南自由贸易港落实金融业扩大开放政策。支持建设国际能源、航运、产权、股权等交易场所。加快发展结算中心。 加快金融改革创新。支持住房租赁金融业务创新和规范发展，支持发展房地产投资信托基金（REITs）。稳步拓宽多种形式的产业融资渠道，放宽外资企业资本金使用范围。创新科技金融政策、产品和工具。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:3","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#三跨境资金流动自由便利"},{"categories":["policy"],"content":" （四）人员进出自由便利（人才引进） 按照学历，把人分成各种等级，唉~ 根据海南自由贸易港发展需要，针对高端产业人才，实行更加开放的人才和停居留政策，打造人才集聚高地。在有效防控涉外安全风险隐患的前提下，实行更加便利的出入境管理政策。 对外籍高层次人才投资创业、讲学交流、经贸活动方面提供出入境便利。完善国际人才评价机制，以薪酬水平为主要指标评估人力资源类别，建立市场导向的人才机制。对外籍人员赴海南自由贸易港的工作许可实行负面清单管理，放宽外籍专业技术技能人员停居留政策。允许符合条件的境外人员担任海南自由贸易港内法定机构、事业单位、国有企业的法定代表人（以后要叫啊sir）。实行宽松的商务人员临时出入境政策。 建立健全人才服务管理制度。实现工作许可、签证与居留信息共享和联审联检。推进建立人才服务中心，提供工作就业、教育生活服务，保障其合法权益。 实施更加便利的出入境管理政策。逐步实施更大范围适用免签入境政策，逐步延长免签停留时间。优化出入境边防检查管理，为商务人员、邮轮游艇提供出入境通关便利。 （### 五）运输来往自由便利。 实施高度自由便利开放的运输政策，推动建设西部陆海新通道国际航运枢纽和航空枢纽（东方、昌江和瞻洲？？），加快构建现代综合交通运输体系。 建立更加自由开放的航运制度。建设“中国洋浦港”船籍港。支持海南自由贸易港开展船舶登记。研究建立海南自由贸易港航运经营管理体制及海员管理制度。进一步放宽空域管制与航路航权限制，优化航运路线，鼓励增加运力投放，增开航线航班。 提升运输便利化和服务保障水平。推进船舶联合登临检查。构建高效、便捷、优质的船旗国特殊监管政策。为船舶和飞机融资提供更加优质高效的金融服务，取消船舶和飞机境外融资限制，探索以保险方式取代保证金。加强内地与海南自由贸易港间运输、通关便利化相关设施设备建设，合理配备人员，提升运输来往自由便利水平。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:4","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#四人员进出自由便利人才引进"},{"categories":["policy"],"content":" （六）数据安全有序流动。在确保数据流动安全可控的前提下，扩大数据领域开放，创新安全制度设计，实现数据充分汇聚，培育发展数字经济。 有序扩大通信资源和业务开放。开放增值电信业务，逐步取消外资股比等限制。允许实体注册、服务设施在海南自由贸易港内的企业，面向自由贸易港全域及国际开展在线数据处理与交易处理等业务，并在安全可控的前提下逐步面向全国开展业务。安全有序开放基础电信业务。开展国际互联网数据交互试点，建设国际海底光缆及登陆点，设立国际通信出入口局。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:5","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#六数据安全有序流动"},{"categories":["policy"],"content":" （七）现代产业体系。大力发展旅游业、现代服务业和高新技术产业，不断夯实实体经济基础，增强产业竞争力。 这里重点还是实体行业。结合前面的政策，这里的所谓的“现代服务业”应该是指加工行业，毕竟增值30%后就可以免关税输送内地了。“高新技术产业\"的话，我觉得新能源可能比较优先，航空航天业，毕竟文昌、海航在那。 旅游业。坚持生态优先、绿色发展，围绕国际旅游消费中心建设，推动旅游与文化体育、健康医疗、养老养生等深度融合，提升博鳌乐城国际医疗旅游先行区发展水平（那么博鳌可能会发展医疗和康养了），支持建设文化旅游产业园，发展特色旅游产业集群，培育旅游新业态新模式，创建全域旅游示范省。加快三亚向国际邮轮母港发展，支持建设邮轮旅游试验区，吸引国际邮轮注册。设立游艇产业改革发展创新试验区。支持创建国家级旅游度假区和5A级景区。 现代服务业。集聚全球创新要素，深化对内对外开放，吸引跨国公司设立区域总部。创新港口管理体制机制，推动港口资源整合，拓展航运服务产业链，推动保税仓储、国际物流配送、转口贸易、大宗商品贸易、进口商品展销、流通加工、集装箱拆拼箱等业务发展，提高全球供应链服务管理能力，打造国际航运枢纽，推动港口、产业、城市融合发展。建设海南： 国际设计岛 理工农医类国际教育创新岛 区域性国际会展中心 扩大专业服务业对外开放。 完善海洋服务基础设施，积极发展： - 海洋物流 - 海洋旅游 - 海洋信息服务 - 海洋工程咨询 - 涉海金融（游轮赌场和性感荷官吗？） - 涉海商务等， 构建具有国际竞争力的海洋服务体系。建设国家对外文化贸易基地。 高新技术产业。聚焦平台载体，提升产业能级，以物联网、人工智能、区块链、数字贸易等为重点发展信息产业。依托文昌国际航天城、三亚深海科技城，布局建设重大科技基础设施和平台，培育深海深空产业。围绕生态环保、生物医药、新能源汽车、智能汽车等壮大先进制造业。发挥国家南繁科研育种基地优势，建设全球热带农业中心和全球动植物种质资源引进中转基地。建设智慧海南。 ###（八） 税收制度。 按照零关税、低税率、简税制、强法治、分阶段的原则，逐步建立与高水平自由贸易港相适应的税收制度。 零关税。全岛封关运作前，对部分进口商品，免征进口关税、进口环节增值税和消费税。全岛封关运作、简并税制后，对进口征税商品目录以外、允许海南自由贸易港进口的商品，免征进口关税。 低税率。对在海南自由贸易港实质经营的企业，实行企业所得税优惠税率。对符合条件的个人，实行个人所得税优惠税率。 简税制。结合我国税制改革方向，探索推进简化税制。改革税种制度，降低间接税比例，实现税种结构简单科学、税制要素充分优化、税负水平明显降低、收入归属清晰、财政收支大体均衡。 强法治。税收管理部门按实质经济活动所在地和价值创造地原则对纳税行为进行评估和预警，制定简明易行的实质经营地、所在地居住判定标准，强化对偷漏税风险的识别，防范税基侵蚀和利润转移，避免成为“避税天堂”。积极参与国际税收征管合作，加强涉税情报信息共享。加强税务领域信用分类服务和管理，依法依规对违法失信企业和个人采取相应措施。 分阶段。按照海南自由贸易港建设的不同阶段，分步骤实施零关税、低税率、简税制的安排，最终形成具有国际竞争力的税收制度。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:6","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#七现代产业体系"},{"categories":["policy"],"content":" （九）社会治理着力推进政府机构改革和政府职能转变，鼓励区块链等技术集成应用于治理体系和治理能力现代化，构建系统完备、科学规范、运行有效的自由贸易港治理体系。 深化政府机构改革。进一步推动海南大部门制改革，整合分散在各部门相近或相似的功能职责，推动职能相近部门合并。控制行政综合类公务员比例，行政人员编制向监管部门倾斜，推行市场化的专业人员聘任制。 推动政府职能转变。强化监管立法和执法，加强社会信用体系应用，深化“双随机、一公开”的市场监管体制，坚持对新兴业态实行包容审慎监管。充分发挥“互联网+”、大数据、区块链等现代信息技术作用，通过政务服务等平台建设规范政府服务标准、实现政务流程再造和政务服务“一网通办”，加强数据有序共享，提升政府服务和治理水平。政府作出的承诺须认真履行，对于不能履行承诺或执行不到位而造成损失的，应及时予以赔偿或补偿。 打造共建共治共享的社会治理格局。深化户籍制度改革，进一步放宽户口迁移政策，实行以公民身份号码为唯一标识、全岛统一的居住证制度。赋予行业组织更大自主权，发挥其在市场秩序维护、标准制定实施、行业纠纷调处中的重要作用。赋予社区更大的基层治理权限，加快社区服务与治理创新。 创新生态文明体制机制。深入推进国家生态文明试验区（海南）建设，全面建立资源高效利用制度，健全自然资源产权制度和有偿使用制度。扎实推进国土空间规划体系建设，实行差别化的自然生态空间用途管制。健全自然保护地内自然资源资产特许经营权等制度，探索生态产品价值实现机制。建立热带雨林等国家公园，构建以国家公园为主体的自然保护地体系。探索建立政府主导、企业和社会参与、市场化运作、可持续的生态保护补偿机制。加快构建自然资源统一调查评价监测和确权登记制度。健全生态环境监测和评价制度。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:7","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#九社会治理"},{"categories":["policy"],"content":" （十）法治制度建立以海南自由贸易港法为基础，以地方性法规和商事纠纷解决机制为重要组成的自由贸易港法治体系，营造国际一流的自由贸易港法治环境。 制定实施海南自由贸易港法。以法律形式明确自由贸易港各项制度安排，为自由贸易港建设提供原则性、基础性的法治保障。 制定经济特区法规。在遵循宪法规定和法律、行政法规基本原则前提下，支持海南充分行使经济特区立法权，立足自由贸易港建设实际，制定经济特区法规。 建立多元化商事纠纷解决机制。完善国际商事纠纷案件集中审判机制，提供国际商事仲裁、国际商事调解等多种非诉讼纠纷解决方式。 从这里来看，法律行业有不错的机会。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:8","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#十法治制度"},{"categories":["policy"],"content":" （十一）风险防控体系制定实施有效措施，有针对性防范化解贸易、投资、金融、数据流动、生态和公共卫生等领域重大风险。 贸易风险防控。高标准建设开放口岸和“二线口岸”基础设施、监管设施，加大信息化系统建设和科技装备投入力度，实施智能精准监管，依托全岛“人流、物流、资金流”信息管理系统、社会管理监管系统、口岸监管系统“三道防线”，形成海南社会管理信息化平台，对非设关地实施全天候动态监控。加强特定区域监管，在未设立口岸查验机构的区域设立综合执法点，对载运工具、上下货物、物品实时监控和处理。海南自由贸易港与内地之间进出的货物、物品、人员、运输工具等均需从口岸进出。完善口岸监管设备设施的配置。海关负责口岸及其他海关监管区的监管和查缉走私工作。海南省政府负责全省反走私综合治理工作，对下级政府反走私综合治理工作进行考评。建立与广东省、广西壮族自治区等地的反走私联防联控机制。 投资风险防控。完善与投资规则相适应的过程监管制度，严格落实备案受理机构的审查责任和备案主体的备案责任。明确加强过程监管的规则和标准，压实监管责任，依法对投资经营活动的全生命周期实施有效监管，对新技术、新产业、新业态、新模式实行包容审慎监管，对高风险行业和领域实行重点监管。建立健全法律责任制度，针对备案主体提供虚假备案信息、违法经营等行为，制定严厉的惩戒措施。实施好外商投资安全审查，在创造稳定、透明和可预期的投资环境同时，有效防范国家安全风险。 金融风险防控。优化金融基础设施和金融法治环境，加强金融消费者权益保护，依托资金流信息监测管理系统，建立健全资金流动监测和风险防控体系。建立自由贸易港跨境资本流动宏观审慎管理体系，加强对重大风险的识别和系统性金融风险的防范。加强反洗钱、反恐怖融资和反逃税审查，研究建立洗钱风险评估机制，定期评估洗钱和恐怖融资风险。构建适应海南自由贸易港建设的金融监管协调机制。 网络安全和数据安全风险防控。深入贯彻实施网络安全等级保护制度，重点保障关键信息基础设施和数据安全，健全网络安全保障体系，提升海南自由贸易港建设相关的网络安全保障能力和水平。建立健全数据出境安全管理制度体系。健全数据流动风险管控措施。 公共卫生风险防控。加强公共卫生防控救治体系建设，建立传染病和突发公共卫生事件监测预警、应急响应平台和决策指挥系统，提高早期预防、风险研判和及时处置能力。加强疾病预防控制体系建设，高标准建设省级疾病预防控制中心，建立国家热带病研究中心海南分中心，加快推进各级疾病预防控制机构基础设施建设，优化实验室检验检测资源配置。加强公共卫生人才队伍建设，提升监测预警、检验检测、现场流行病学调查、应急处置和医疗救治能力。建设生物安全防护三级实验室和传染病防治研究所，强化全面检测、快速筛查能力，优化重要卫生应急物资储备和产能保障体系。健全优化重大疫情救治体系，建设传染病医疗服务网络，依托综合医院或专科医院建立省级和市级传染病医疗中心，改善传染病医疗中心和传染病医院基础设施和医疗条件。重点加强基层传染病医疗服务能力建设，提升县级综合医院传染病诊疗能力。构建网格化紧密型医疗集团，促进资源下沉、医防融合。完善基层医疗卫生机构标准化建设，强化常见病多发病诊治、公共卫生服务和健康管理能力。加强国际卫生检疫合作和国际疫情信息搜集与分析，提升口岸卫生检疫技术设施保障，建设一流的国际旅行卫生保健中心，严格落实出入境人员健康申报制度，加强对来自重点国家或地区的交通工具、人员和货物、物品的卫生检疫，强化联防联控，筑牢口岸检疫防线。加强对全球传染病疫情的监测，推进境外传染病疫情风险早期预警，严防重大传染病跨境传播。建立海关等多部门协作的境外疫病疫情和有害生物联防联控机制。提升进出口商品质量安全风险预警和快速反应监管能力，完善重点敏感进出口商品监管。 生态风险防控。实行严格的进出境环境安全准入管理制度，禁止洋垃圾输入。推进医疗废物等危险废物处置设施建设，提升突发生态环境事件应急准备与响应能力。建立健全环保信用评价制度。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:2:9","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#十一风险防控体系"},{"categories":["policy"],"content":" 三、分步骤分阶段安排","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:3:0","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#三分步骤分阶段安排"},{"categories":["policy"],"content":" （一）2025年前重点任务围绕贸易投资自由化便利化，在有效监管基础上，有序推进开放进程，推动各类要素便捷高效流动，形成早期收获，##适时启动全岛封关运作##。 加强海关特殊监管区域建设。在洋浦保税港区等具备条件的海关特殊监管区域率先实行“一线”放开、“二线”管住的进出口管理制度。根据海南自由贸易港建设需要，增设海关特殊监管区域。 实行部分进口商品零关税政策。除法律法规和相关规定明确不予免税、国家规定禁止进口的商品外，对企业进口自用的生产设备，实行“零关税”负面清单管理；对岛内进口用于交通运输、旅游业的船舶、航空器等营运用交通工具及游艇，实行“零关税”正面清单管理；对岛内进口用于生产自用或以“两头在外”模式进行生产加工活动（或服务贸易过程中）所消耗的原辅料，实行“零关税”正面清单管理；对岛内居民消费的进境商品，实行正面清单管理，允许岛内免税购买。对实行“零关税”清单管理的货物及物品，免征进口关税、进口环节增值税和消费税。清单内容由有关部门根据海南实际需要和监管条件进行动态调整。放宽离岛免税购物额度至每年每人10万元，扩大免税商品种类。 减少跨境服务贸易限制。在重点领域率先规范影响服务贸易自由便利的国内规制。制定出台海南自由贸易港跨境服务贸易负面清单，给予境外服务提供者国民待遇。建设海南国际知识产权交易所，在知识产权转让、运用和税收政策等方面开展制度创新，规范探索知识产权证券化。 实行“极简审批”投资制度。制定出台海南自由贸易港放宽市场准入特别清单、外商投资准入负面清单。对先行开放的特定服务业领域所设立的外商投资企业，明确经营业务覆盖的地域范围。建立健全国家安全审查、产业准入环境标准和社会信用体系等制度，全面推行“极简审批”制度。深化“证照分离”改革。建立健全以信用监管为基础、与负面清单管理方式相适应的过程监管体系。 试点改革跨境证券投融资政策。支持在海南自由贸易港内注册的境内企业根据境内外融资计划在境外发行股票，优先支持企业通过境外发行债券融资，将企业发行外债备案登记制管理下放至海南省发展改革部门。探索开展跨境资产管理业务试点，提高跨境证券投融资汇兑便利。试点海南自由贸易港内企业境外上市外汇登记直接到银行办理。 加快金融业对内对外开放。培育、提升海南金融机构服务对外开放能力，支持金融业对外开放政策在海南自由贸易港率先实施。支持符合条件的境外证券基金期货经营机构在海南自由贸易港设立独资或合资金融机构。支持金融机构立足海南旅游业、现代服务业、高新技术产业等重点产业发展需要，创新金融产品，提升服务质效。依托海南自由贸易港建设，推动发展相关的场外衍生品业务。支持海南在优化升级现有交易场所的前提下，推进产权交易场所建设，研究允许非居民按照规定参与交易和进行资金结算。支持海南自由贸易港内已经设立的交易场所在会员、交易、税负、清算、交割、投资者权益保护、反洗钱等方面，建立与国际惯例接轨的规则和制度体系。在符合相关法律法规的前提下，支持在海南自由贸易港设立财产险、人身险、再保险公司以及相互保险组织和自保公司。 增强金融服务实体经济能力。支持发行公司信用类债券、项目收益票据、住房租赁专项债券等。对有稳定现金流的优质旅游资产，推动开展证券化试点。支持金融机构在依法合规、有效防范风险的前提下，在服务贸易领域开展保单融资、仓单质押贷款、应收账款质押贷款、知识产权质押融资等业务。支持涉海高新技术企业利用股权、知识产权开展质押融资，规范、稳妥开发航运物流金融产品和供应链融资产品。依法有序推进人工智能、大数据、云计算等金融科技领域研究成果在海南自由贸易港率先落地。探索建立与国际商业保险付费体系相衔接的商业性医疗保险服务。支持保险业金融机构与境外机构合作开发跨境医疗保险产品。 实施更加便利的免签入境措施。将外国人免签入境渠道由旅行社邀请接待扩展为外国人自行申报或通过单位邀请接待免签入境。放宽外国人申请免签入境事由限制，允许外国人以商贸、访问、探亲、就医、会展、体育竞技等事由申请免签入境海南。实施外国旅游团乘坐邮轮入境15天免签政策。 实施更加开放的船舶运输政策。以“中国洋浦港”为船籍港，简化检验流程，逐步放开船舶法定检验，建立海南自由贸易港国际船舶登记中心，创新设立便捷、高效的船舶登记程序。取消船舶登记主体外资股比限制。在确保有效监管和风险可控的前提下，境内建造的船舶在“中国洋浦港”登记并从事国际运输的，视同出口并给予出口退税。对以洋浦港作为中转港从事内外贸同船运输的境内船舶，允许其加注本航次所需的保税油；对其加注本航次所需的本地生产燃料油，实行出口退税政策。对符合条件并经洋浦港中转离境的集装箱货物，试行启运港退税政策。加快推进琼州海峡港航一体化。 实施更加开放的航空运输政策。在对等基础上，推动在双边航空运输协定中实现对双方承运人开放往返海南的第三、第四航权，并根据我国整体航空运输政策，扩大包括第五航权在内的海南自由贸易港建设所必需的航权安排。支持在海南试点开放第七航权。允许相关国家和地区航空公司承载经海南至第三国（地区）的客货业务。实施航空国际中转旅客及其行李通程联运。对位于海南的主基地航空公司开拓国际航线给予支持。允许海南进出岛航班加注保税航油。 便利数据流动。在国家数据跨境传输安全管理制度框架下，开展数据跨境传输安全管理试点，探索形成既能便利数据流动又能保障安全的机制。 深化产业对外开放。支持发展总部经济。举办中国国际消费品博览会，国家级展会境外展品在展期内进口和销售享受免税政策，免税政策由有关部门具体制定。支持海南大力引进国外优质医疗资源（支持医保吗？）。总结区域医疗中心建设试点经验，研究支持海南建设区域医疗中心。允许境外理工农医类高水平大学、职业院校在海南自由贸易港独立办学，设立国际学校。推动国内重点高校引进国外知名院校在海南自由贸易港举办具有独立法人资格的中外合作办学机构（说的是北大青鸟吗）。建设海南国家区块链技术和产业创新发展基地。 优化税收政策安排。从本方案发布之日起，对注册在海南自由贸易港并实质性运营的鼓励类产业企业，减按15%征收企业所得税。对在海南自由贸易港设立的旅游业、现代服务业、高新技术产业企业，其2025年前新增境外直接投资取得的所得，免征企业所得税。对企业符合条件的资本性支出，允许在支出发生当期一次性税前扣除或加速折旧和摊销。对在海南自由贸易港工作的高端人才和紧缺人才，其个人所得税实际税负超过15%的部分，予以免征。对享受上述优惠政策的高端人才和紧缺人才实行清单管理，由海南省商财政部、税务总局制定具体管理办法。 加大中央财政支持力度。中央财政安排综合财力补助，对地方财政减收予以适当弥补。鼓励海南在国务院批准的限额内发行地方政府债券支持自由贸易港项目建设。在有效防范风险的前提下，稳步增加海南地方政府专项债券发行额度，用于支持重大基础设施建设。鼓励在海南自由贸易港向全球符合条件的境外投资者发行地方政府债券。由海南统筹中央资金和自有财力，设立海南自由贸易港建设投资基金，按政府引导、市场化方式运作。 给予充分法律授权。本方案提出的各项改革政策措施，凡涉及调整现行法律或行政法规的，经全国人大及其常委会或国务院统一授权后实施。研究简化调整现行法律或行政法规的工作程序，推动尽快落地。授权海南制定出台自由贸易港商事注销条例、破产条例、公平竞争条例、征收征用条例。加快推动制定出台海南自由贸易港法。 强化用地用海保障。授权海南在不突破海南省国土空间规划明确的生态保护红线、永久基本农田面积、耕地和林地保有量、建设用地总规模等重要指标并确保质量不降低的前提下，按照国家规定的条件，对全省耕地、永久基本农田、林地、建设用地布局调整进行审批并纳入海南省和市县国土空间规划。积极推进城乡及垦区一体化协调发展和小城镇建设用地新模式，推进农垦土地资产化。建立集约节约用地制度、评价标准以及存量建设用地盘活处置政策体系。总结推广文昌农村土地制度改革三项试点经验，支持海南在全省深入推进农村土地制度改革。依法保障国家重大项目用海需求。 做好封关运作准备工作。制定出台海南自由贸易港进口征税商品目录、限制进口货物物品清单、禁止进口货物物品清单、限制出口货物物品清单、禁止出口货物物品清单、运输工具管理办法，以及与内地海关通关单证格式规范、与内地海关通关操作规程、出口通关操作规程等，增加对外开放口岸，建设全岛封关运作的配套设施。 适时启动全岛封关运作。2025年前，适时全面开展全岛封关运作准备工作情况评估，查堵安全漏洞。待条件成熟后再实施全岛封关运作，不再保留洋浦保税港区、海口综合保税区等海关特殊监管区域。相关监管实施方案由有关部门另行制定。在全岛封关运作的同时，依法将现行增值税、消费税、车辆购置税、城市维护建设税及教育费附加等税费进行简并，启动在货物和服务零售环节征收销售税相关工作。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:3:1","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#一2025年前重点任务"},{"categories":["policy"],"content":" （二）2035年前重点任务进一步优化完善开放政策和相关制度安排，全面实现贸易自由便利、投资自由便利、跨境资金流动自由便利、人员进出自由便利、运输来往自由便利和数据安全有序流动，推进建设高水平自由贸易港。 实现贸易自由便利。进一步创新海关监管制度，建立与总体国家安全观相适应的非关税贸易措施体系，建立自由进出、安全便利的货物贸易管理制度，实现境外货物在海南自由贸易港进出自由便利。建立健全跨境支付业务相关制度，营造良好的支付服务市场环境，提升跨境支付服务效率，依法合规推动跨境服务贸易自由化便利化。 实现投资自由便利。除涉及国家安全、社会稳定、生态保护红线、重大公共利益等国家实行准入管理的领域外，全面放开投资准入。在具有强制性标准的领域，建立“标准制+承诺制”的投资制度，市场主体对符合相关要求作出承诺，即可开展投资经营活动。 实现跨境资金流动自由便利。允许符合一定条件的非金融企业，根据实际融资需要自主借用外债，最终实现海南自由贸易港非金融企业外债项下完全可兑换。 实现人员进出自由便利。进一步放宽人员自由进出限制。实行更加宽松的商务人员临时出入境政策、便利的工作签证政策，进一步完善居留制度。 实现运输来往自由便利。实行特殊的船舶登记审查制度。进一步放宽空域管制与航路航权限制。鼓励国内外航空公司增加运力投放，增开航线航班。根据双边航空运输协定，在审核外国航空公司国际航线经营许可时，优先签发至海南的国际航线航班许可。 实现数据安全有序流动。创新数据出境安全的制度设计，探索更加便利的个人信息安全出境评估办法。开展个人信息入境制度性对接，探索加入区域性国际数据跨境流动制度安排，提升数据传输便利性。积极参与跨境数据流动国际规则制定，建立数据确权、数据交易、数据安全和区块链金融的标准和规则。 进一步推进财税制度改革。对注册在海南自由贸易港并实质性运营的企业（负面清单行业除外），减按15%征收企业所得税。对一个纳税年度内在海南自由贸易港累计居住满183天的个人，其取得来源于海南自由贸易港范围内的综合所得和经营所得，按照3%、10%、15%三档超额累进税率征收个人所得税。扩大海南地方税收管理权限。企业所得税、个人所得税作为中央与地方共享收入，销售税及其他国内税种收入作为地方收入。授权海南根据自由贸易港发展需要，自主减征、免征、缓征除具有生态补偿性质外的政府性基金，自主设立涉企行政事业性收费项目。对中央级行政事业性收费，按照中央统一规定执行。中央财政支持政策结合税制变化情况相应调整，并加大支持力度。进一步研究改进补贴政策框架，为我国参与补贴领域国际规则制定提供参考。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:3:2","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#二2035年前重点任务"},{"categories":["policy"],"content":" 四、组织实施（一）加强党的全面领导。坚持用习近平新时代中国特色社会主义思想武装党员干部头脑，认真贯彻落实党中央、国务院决策部署，增强“四个意识”，坚定“四个自信”，做到“两个维护”。建立健全党对海南自由贸易港建设工作的领导体制机制，充分发挥党总揽全局、协调各方的作用，加强党对海南自由贸易港建设各领域各方面各环节的领导。以党的政治建设为统领，以提升组织力为重点，全面提高党的建设质量，为海南自由贸易港建设提供坚强政治保障。加强基层党组织建设，引导广大党员发挥先锋模范作用，把基层党组织建设成为海南推动自由贸易港建设的坚强战斗堡垒。完善体现新发展理念和正确政绩观要求的干部考核评价体系，建立激励机制和容错纠错机制，旗帜鲜明地为敢于担当、踏实做事、不谋私利的干部撑腰鼓劲。把社会主义核心价值观融入经济社会发展各方面。持之以恒正风肃纪，强化纪检监察工作，营造风清气正良好环境。 （二）健全实施机制。在推进海南全面深化改革开放领导小组指导下，海南省要切实履行主体责任，加强组织领导，全力推进海南自由贸易港建设各项工作。中央和国家机关有关单位要按照本方案要求，主动指导推动海南自由贸易港建设，进一步细化相关政策措施，制定出台实施方案，确保政策落地见效。推进海南全面深化改革开放领导小组办公室牵头成立指导海南推进自由贸易港建设工作小组，由国家发展改革委、财政部、商务部、中国人民银行、海关总署等部门分别派出干部驻海南实地指导开展自由贸易港建设工作，有关情况及时上报领导小组。国务院发展研究中心组织对海南自由贸易港建设开展全过程评估，牵头设立专家咨询委员会，为海南自由贸易港建设建言献策。 （三）稳步推进政策落地。加大督促落实力度，将各项政策举措抓实抓细抓出成效。认真研究和妥善解决海南自由贸易港建设中遇到的新情况新问题，对一些重大政策措施做好试点工作，积极稳妥推进方案实施。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:4:0","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#四组织实施"},{"categories":["policy"],"content":" 简单总结","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:0","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#简单总结"},{"categories":["policy"],"content":" 三大产业 旅游业 现代服务业 高新技术产业 旅游依然排在首位，再加上免税购物，那么基本物价应该会持续上涨。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:1","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#三大产业"},{"categories":["policy"],"content":" 关于免税 免税政策是“一线”的，意味着海南与内地之间贸易算作进出口； 但是如果是鼓励类企业并且在海南加工增值超过30%可以享受免税； 并不是所有商品都免税，存在《不免税商品清单》和《禁、限制进出口清单》 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:2","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#关于免税"},{"categories":["policy"],"content":" 关于海关货物进出口手续精简，进出方便。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:3","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#关于海关"},{"categories":["policy"],"content":" 关于支付新的支付流程，提高便利性，但是是否能比肩香港，还是个未知数。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:4","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#关于支付"},{"categories":["policy"],"content":" 关于金融其实发展金融业，还是为了促进资金流动。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:5","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#关于金融"},{"categories":["policy"],"content":" 关于人才利好政策，吸引外籍人员。 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:6","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#关于人才"},{"categories":["policy"],"content":" 产业 港口 航运 仓储 物流 转口贸易 大宗商品交易 商品展销 流通加工 集装箱拆拼箱 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:7","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#产业"},{"categories":["policy"],"content":" 税收优惠 企业所得税 符合条件的个人可享受个税优惠 ","date":"2021-03-24","objectID":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/:5:8","series":null,"tags":["海口政策"],"title":"研读自贸港政策","uri":"/%E7%A0%94%E8%AF%BB%E8%87%AA%E8%B4%B8%E6%B8%AF%E6%94%BF%E7%AD%96/#税收优惠"},{"categories":null,"content":" setContentView @Override public void setContentView(View v) { ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v); mAppCompatWindowCallback.getWrapped().onContentChanged(); } @Override public void setContentView(int resId) { ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mAppCompatWindowCallback.getWrapped().onContentChanged(); } @Override public void setContentView(View v, ViewGroup.LayoutParams lp) { ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v, lp); mAppCompatWindowCallback.getWrapped().onContentChanged(); } ","date":"2021-03-24","objectID":"/view%E7%9A%84%E5%89%8D%E5%89%8D%E5%90%8E%E5%90%8E/:1:0","series":null,"tags":null,"title":"View的前前后后","uri":"/view%E7%9A%84%E5%89%8D%E5%89%8D%E5%90%8E%E5%90%8E/#setcontentview"},{"categories":null,"content":" 三大流程 measure 用来测量View的宽高； layout 用来确定View在父容器中的放置位置； draw 负责绘制。 在ActivityThread中，当Activity创建完毕后，会将DecorView附加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl与DecorView建立关联。 ViewRootIml其实是DecorView的管理类。 View的绘制流程是从ViewRoot的performTraversals()方法开始的，经过measure、layout、draw三个过程才能最终将一个View绘制出来。 ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:1:0","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#三大流程"},{"categories":null,"content":" measure通过调用setMeasuredDimension决定View的宽高。 计算之后可以通过getMeasureWidth和getMeasureHeight获取测量后的结构。 ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:1:1","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#measure"},{"categories":null,"content":" measureChildren通过遍历调用measureChild(child,widthMeasureSpec,heightMeasureSpec)方法完成所有子View的测量。 ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:1:2","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#measurechildren"},{"categories":null,"content":" layout用来确定子元素的位置。需要遍历子元素，调用其layout方法。 决定了View的四个顶点的坐标和实际的View的宽和高。 getTop getLeft getRight getBottom getWidth getHeight getWidth和getHeight才是View的最终宽高。 ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:1:3","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#layout"},{"categories":null,"content":" onDraw 绘制背景background.draw(canvas)。 绘制自己（onDraw）。 绘制children（dispatchDraw）。 绘制装饰（onDrawScrollBars）。 ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:2:0","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#ondraw"},{"categories":null,"content":" DecorViewDecorView作为顶级的View，包含一个竖直的LinnerLayout，内部含有标题栏和内容栏.setContentView就是把View附加到内容栏。内容栏是个FrameLayout，他的的id是content，所以是setContentView。 //获取content内容栏 ViewGroup content= findViewById (R.android.id.content)； //获取我们自己的顶级View View rootView = content.getChildAt(0); ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:0","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#decorview"},{"categories":null,"content":" MeasureSpec这是一个32位的int，高2位代表SpecMode，低30位代表SpecSize。 通过将SpecMode和SpecSize打包成一个int，避免过多的内存分配。 UNSPECIFIED 父容器不做任何闲置，子View可以任意大； EXACTLY 父容器测出View所需大小，对应match_parent和精确的值； AT_MOST 父容器制定了一个可用大小SpecSize，View的大小不能大于这个值，用于wrap_content。 ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:0","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#measurespec"},{"categories":null,"content":" 获取View的宽高view的measure过程和Activitu生命周期不同步，所有在onCreate、onStart、onResume中都不能获取到View的宽高。 Activity/View#onWindowFocusChanged； view.post(runnable)； ViewtreeObserver view.measure(int widthMeasureSpec,int heightMeasureSpec)(手动测量); ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:5:0","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#获取view的宽高"},{"categories":null,"content":" 生命周期 Constructors构造函数； onFinishInflate当该View及其子View从XML文件中填充完成后会被调用； onAttachedToWindow附加到窗口; onMeasure计算尺寸时调用； onSizeChanged当前view尺寸变化时调用; onLayout调用所有子view的layout方法为每一个子view确定位置； onDraw绘图时调用； onDetackedFromWindow脱离窗口时调用。 ","date":"2021-03-22","objectID":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:6:0","series":null,"tags":["Android","View"],"title":"View的工作原理","uri":"/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#生命周期"},{"categories":null,"content":" 位置参数","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:1:0","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#位置参数"},{"categories":null,"content":" 主要位置参数 View的位置主要由它的四个顶点(相对父容器)来决定： getLeft() getTop() getRight() getBottom() ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:1:1","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#主要位置参数"},{"categories":null,"content":" 用于移动的参数 x/y View左上角相对父容器的坐标； translationX/translationY View左上角相对父容器的偏移量。 x = left + translationX; y = top + translationY; 在View移动中，top和left不会变，xy,translation系列会变。 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:1:2","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#用于移动的参数"},{"categories":null,"content":" 用户交互","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:0","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#用户交互"},{"categories":null,"content":" MotionEvent事件： ACTION_DOWN ACTION_MOVE ACTION_UP 触发点： getX/getY 相对当前View左上角的x和y坐标； getRawX/getRawY 相对于手机屏幕左上角的x和y坐标。 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:1","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#motionevent"},{"categories":null,"content":" TouchSlop系统能识别出的滑动最小距离。是个常量。 ViewConfiguration. get(getContext()).getScaledTouchSlop() 可以利用这个常量来做过滤。 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:2","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#touchslop"},{"categories":null,"content":" VelocityTracker速度追踪，用于追踪手指在一定时间内滑动过的像素数。 VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); //事件定位1000毫秒，也就是1秒 velocityTracker.computeCurrentVelocity(1000); int xVelocity = (int) velocityTracker.getXVelocity(); int yVelocity = (int) velocityTracker.getYVelocity(); //回收 velocityTracker.clear(); velocityTracker.recycle(); ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:3","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#velocitytracker"},{"categories":null,"content":" GestureDetector手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。 GestureDetector mGestureDetector = new GestureDetector(this); //解决长按屏幕后无法拖动的现象 mGestureDetector.setIsLongpressEnabled(false) 然后在View的onTouchEvent(event)方法中接管事件： boolean consume = mGestureDetector.onTouchEvent(event); return consume; 然后实现OnGestureListener和OnDoubleTapListener方法。 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:4","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#gesturedetector"},{"categories":null,"content":" Scroller在View滑动时，可以调用scrollTo/scrollBy方法，但是这两个方法会瞬间完成，没有过度动画，Scroller可解决这个问题。 Scroller scroller = new Scroller(mContext); // 缓慢滚动到指定位置 private void smoothScrollTo(int destX,int destY) { int scrollX = getScrollX(); int delta = destX -scrollX; // 1000ms内滑向destX，效果就是慢慢滑动 mScroller.startScroll(scrollX,0,delta,0,1000); invalidate(); } @Override public void computeScroll() { if (mScroller.computeScrollOffset()) { scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); } } ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:5","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#scroller"},{"categories":null,"content":" View的滑动 scrollTo/scrollBy 使内容滑动 动画实现平移效果 改变View的LayoutParams使View重新布局。 scrollTo/scrollBy scrollTo 绝对滑动。 scrollBy 基于当前位置相对滑动。 scrollBy实际上也是调用scrollTo方法实现的。 获取当前滑动位置： getScrollX getScrollY 在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元在水平方向的距离。而mScrollY的值总是等于View上边缘和内容上边缘在竖直方向的距离。 scrollTo和scrollBy只改变View内容的位置。 动画操作translationX/translationYView动画是对view的影像做操作，并不能真正改变View的位置参数。所以在新的位置单击等操作会无效。解决方式是使用属性动画。 改布局参数 MarginLayoutParams params = (MarginLayoutParams)mButton1.getLayoutParams(); params.width += 100; params.leftMargin += 100; mButton1.requestLayout(); //或者mButton1.setLayoutParams(params); ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:6","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#view的滑动"},{"categories":null,"content":" View的滑动 scrollTo/scrollBy 使内容滑动 动画实现平移效果 改变View的LayoutParams使View重新布局。 scrollTo/scrollBy scrollTo 绝对滑动。 scrollBy 基于当前位置相对滑动。 scrollBy实际上也是调用scrollTo方法实现的。 获取当前滑动位置： getScrollX getScrollY 在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元在水平方向的距离。而mScrollY的值总是等于View上边缘和内容上边缘在竖直方向的距离。 scrollTo和scrollBy只改变View内容的位置。 动画操作translationX/translationYView动画是对view的影像做操作，并不能真正改变View的位置参数。所以在新的位置单击等操作会无效。解决方式是使用属性动画。 改布局参数 MarginLayoutParams params = (MarginLayoutParams)mButton1.getLayoutParams(); params.width += 100; params.leftMargin += 100; mButton1.requestLayout(); //或者mButton1.setLayoutParams(params); ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:6","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#scrolltoscrollby"},{"categories":null,"content":" View的滑动 scrollTo/scrollBy 使内容滑动 动画实现平移效果 改变View的LayoutParams使View重新布局。 scrollTo/scrollBy scrollTo 绝对滑动。 scrollBy 基于当前位置相对滑动。 scrollBy实际上也是调用scrollTo方法实现的。 获取当前滑动位置： getScrollX getScrollY 在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元在水平方向的距离。而mScrollY的值总是等于View上边缘和内容上边缘在竖直方向的距离。 scrollTo和scrollBy只改变View内容的位置。 动画操作translationX/translationYView动画是对view的影像做操作，并不能真正改变View的位置参数。所以在新的位置单击等操作会无效。解决方式是使用属性动画。 改布局参数 MarginLayoutParams params = (MarginLayoutParams)mButton1.getLayoutParams(); params.width += 100; params.leftMargin += 100; mButton1.requestLayout(); //或者mButton1.setLayoutParams(params); ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:6","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#动画操作translationxtranslationy"},{"categories":null,"content":" View的滑动 scrollTo/scrollBy 使内容滑动 动画实现平移效果 改变View的LayoutParams使View重新布局。 scrollTo/scrollBy scrollTo 绝对滑动。 scrollBy 基于当前位置相对滑动。 scrollBy实际上也是调用scrollTo方法实现的。 获取当前滑动位置： getScrollX getScrollY 在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元在水平方向的距离。而mScrollY的值总是等于View上边缘和内容上边缘在竖直方向的距离。 scrollTo和scrollBy只改变View内容的位置。 动画操作translationX/translationYView动画是对view的影像做操作，并不能真正改变View的位置参数。所以在新的位置单击等操作会无效。解决方式是使用属性动画。 改布局参数 MarginLayoutParams params = (MarginLayoutParams)mButton1.getLayoutParams(); params.width += 100; params.leftMargin += 100; mButton1.requestLayout(); //或者mButton1.setLayoutParams(params); ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:6","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#改布局参数"},{"categories":null,"content":" 事件分发机制","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:3:0","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#事件分发机制"},{"categories":null,"content":" 点击事件的传递规则 dispatchTouchEvent onInterceptTouchEvent onTouchEvent dispatchTouchEvent用来用来做事件的分发，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent影像。返回值表示是否小号掉当前的事件。 onInterceptTouchEvent用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 onTouchEvent在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 public boolean dispatchTouchEvent(MotionEvent ev) { boolean consume = false; if (onInterceptTouchEvent(ev)) { //如果拦截到，调用onTouchEvent consume = onTouchEvent(ev); } else { // 如果不拦截，透传到子View的dispatchTouchEvent consume = child.dispatchTouchEvent(ev); } return consume; } 在这里可以看出，子View是事件的最终处理者，所以不需要在子View内进行拦截了，因而在自定义View中不需要重写onInterceptTouchEvent。 当一个View设置了onTouchListener，事件先被onTouchListener处理，其中的onTouch()方法先被回调，如果返回false，则当前View的onTouchEvent方法才会被调用；如果返回true，onTouchEvent()方法就不会被调用。在onTouchEvent()方法中，如果当前View设置了onClickListener，那么最后才会调用onClick()方法。onClickListener的优先级最低，处于事件传递的尾端。 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:3:1","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#点击事件的传递规则"},{"categories":null,"content":" 事件传递的层级顺序 Activity Window ViewGroup View 事件从上倒下传递，如果其中一环的onTouchEvent返回false，则回传到父容器的onTouchEvent方法。如果所有的View都不处理事件，最终将会回传给Activity的onTouchEvent()方法处理。 MotionEvent代表一系列事件，基本上会被一个View统一处理，也可以在通过调用其他View的onTouchEvent处理。 如果View一旦开始处理事件，如果它不消耗掉当前事件，那么同一事件序列中的其他事件都不会再交给他处理，eg:View收到了ACTION_DOWN，如果不消耗掉，那么后面的ACTION_MOVE和ACTION_UP都不会再交给他处理。 如果View不消耗掉除了ACTION_DOWN以外的其他事件，那么这个点击事件就会消失，父级容器的onTouchEvent()并不会调用。并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。onInterceptTouchEvent()方法默认返回false。 View的onTouchEvent默认返回true，即默认消耗事件（除非不可点击）。 View的enable属性不影像onTouchEvent的默认返回值。 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:3:2","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#事件传递的层级顺序"},{"categories":null,"content":" 滑动冲突 内外滑动方向不一致在外层根据滑动方向判断，如果与自己方向一致，就拦截，否则传递给子View处理并消耗掉。 判断方法： 水平方向与竖直方向的夹角； 水平方向与竖直方向的距离差 内外滑动方向一致 根据业务需求来做判断 根据ACTION_DOWN的落点坐标来判断 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:3:3","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#滑动冲突"},{"categories":null,"content":" 滑动冲突 内外滑动方向不一致在外层根据滑动方向判断，如果与自己方向一致，就拦截，否则传递给子View处理并消耗掉。 判断方法： 水平方向与竖直方向的夹角； 水平方向与竖直方向的距离差 内外滑动方向一致 根据业务需求来做判断 根据ACTION_DOWN的落点坐标来判断 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:3:3","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#内外滑动方向不一致"},{"categories":null,"content":" 滑动冲突 内外滑动方向不一致在外层根据滑动方向判断，如果与自己方向一致，就拦截，否则传递给子View处理并消耗掉。 判断方法： 水平方向与竖直方向的夹角； 水平方向与竖直方向的距离差 内外滑动方向一致 根据业务需求来做判断 根据ACTION_DOWN的落点坐标来判断 ","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:3:3","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#内外滑动方向一致"},{"categories":null,"content":" requestDisallowInterceptTouchEvent","date":"2021-03-22","objectID":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:4:0","series":null,"tags":["Android","View"],"title":"View事件体系","uri":"/view%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/#requestdisallowintercepttouchevent"},{"categories":null,"content":" 并发三大特性 原子性 操作要么成功，要么失败，中途不可被中断。 可见性 共享变量的变更立即可见。 有序性 程序执行依照代码的先后顺序来执行。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:1:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#并发三大特性"},{"categories":null,"content":" JMM模型JMM的原则是数据拷贝，会从主存拷贝到CPU缓存，再拷贝到CPU寄存器。CPU寄存器的速度远高于缓存，缓存的读写速度远高于主存。当一个线程在寄存器中修改了数据，而没有同步到主存时，另一线程从主存读取了过期的数据，造成数据不同步问题。解决方式是同步访问（加锁）或者通过volatile强制刷写到主存。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:2:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#jmm模型"},{"categories":null,"content":" 指令重排序如果不存在数据依赖性，为了提高性能，编译器和cpu会在不改变程序执行结果的前提下对指令重新排序。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:3:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#指令重排序"},{"categories":null,"content":" JMM内存屏障 LoadLoad 可保障：在执行屏障后面的所有读取操作之前，屏障前面的读取操作全部完成。 StoreStore 可保障：在执行屏障后面的所有写入操作之前，屏障前面的写入操作全部完成。 LoadStore 可保障：在执行屏障后面的所有写入操作之前，屏障前面的读取操作全部完成。 StoreLoad 可保障：在执行屏障后面的所有读取操作之前，屏障前面的写入操作全部完成。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:4:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#jmm内存屏障"},{"categories":null,"content":" volatile符合可见性和有序性，不保证原子性。 通过在编译器生成字节码时，在指令序列中添加内存读写屏障来禁止指令重排序，保障了可见性和有序性，不能保证原子性。 JVM会在volatile修饰的变量前后都加上内存屏障，保证有序性： LoadLoadBarrier volatile读操作 LoadStoreBarrier StoreStoreBarrier volatile写操作 StoreLoadBarrier ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:5:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#volatile"},{"categories":null,"content":" synchronized符合并发编程的三大特征。 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁; 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁; 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 原理是对象头中存在访问计数、偏向锁、轻量锁。 从jvm层面锁就是监视器monitor。持有或者重入monitor会使计数器自加1。释放时计数器归0，其他线程才能持有monitor。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:6:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#synchronized"},{"categories":null,"content":" 对象锁操作 void wait() 导致一个线程进入等待状态，直到它得到通知。该方法只能在一个同步方法或同步块中调用。如果当前线程不是对象锁的持有者，会抛出异常。 void notify() 随机选择一个在这个对象上调用wait方法的线程，接触其阻塞状态。 void notifyAll() 解除所有被wait阻塞的线程。 用法： public class MainActivity extends AppCompatActivity { private final Data data = new Data(); Runnable runnable1 = new Runnable() { @Override public void run() { synchronized (data) { try { if(!Thread.currentThread().isInterrupted() \u0026\u0026 data.getNum() \u003c 1){ data.wait(); } Log.d(\"子线程\", \"run: 收到了通知，此时num值为\" + data.getNum()); } catch (InterruptedException e) { e.printStackTrace(); } } } }; Runnable runnable2 = new Runnable() { @Override public void run() { synchronized (data) { data.setNum(1); data.notifyAll(); } } }; private Thread t1, t2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); t1 = new Thread(this.runnable1); t1.start(); } public void start(View v) { t2 = new Thread(this.runnable2); t2.start(); } private static class Data { private int num; public int getNum() { return num; } public void setNum(int num) { this.num = num; } } } ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:7:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#对象锁操作"},{"categories":null,"content":" 原子类型 AtomicInteger AtomicIntegerArray AtomicIntegerFieldUpdater AtomicLong AtomicBoolean AtomicReference 原理： private volatile int value; 内部值带有 volatile保证可见性和有序性，通过Unsafe的底层能力保证原子性。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:8:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#原子类型"},{"categories":null,"content":" 重入锁ReentrantLocak重入锁：线程可以反复获得已拥有的锁。 //构造一个重入锁 new reentrantLocak(); //构造一个公平锁 new reentrantLocak(boolean fair); 公平锁倾向于等待时间最长的吓成，可能严重影响性能。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:9:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#重入锁reentrantlocak"},{"categories":null,"content":" 读写锁ReadWriteLock。","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:10:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#读写锁readwritelock"},{"categories":null,"content":" 锁分类 公平锁、非公平锁：公平锁指多个线程按照申请锁的顺序来获取锁，非公平锁就是没有顺序完全随机，所以能会造成优先级反转或者饥饿现象；synchronized 就是非公平锁，ReentrantLock（使用 CAS 和 AQS 实现） 通过构造参数可以决定是非公平锁还是公平锁，默认构造是非公平锁；非公平锁的吞吐量性能比公平锁大好。 可重入锁：又名递归锁，指在同一个线程在外层方法获取锁的时候在进入内层方法会自动获取锁，synchronized 和 ReentrantLock 都是可重入锁，可重入锁可以在一定程度避免死锁。 独占锁、共享锁：独享锁是指该锁一次只能被一个线程持有，共享锁指该锁可以被多个线程持有；synchronized 和 ReentrantLock 都是独享锁，ReadWriteLock 的读锁是共享锁，写锁是独占锁；ReentrantLock 的独享锁和共享锁也是通过 AQS 来实现的。 互斥锁、读写锁：其实就是独享锁、共享锁的具体说法；互斥锁实质就是 ReentrantLock，读写锁实质就是 ReadWriteLock。 乐观锁、悲观锁：这个分类不是具体锁的分类，而是看待并发同步的角度；悲观锁认为对于同一个数据的并发操作一定是会发生修改的（哪怕实质没修改也认为会修改），因此对于同一个数据的并发操作，悲观锁采取加锁的形式，因为悲观锁认为不加锁的操作一定有问题；乐观锁则认为对于同一个数据的并发操作是不会发生修改的，在更新数据的时候会采用不断的尝试更新，乐观锁认为不加锁的并发操作是没事的；由此可以看出悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升，悲观锁在 java 中很常见，乐观锁其实就是基于 CAS 的无锁编程，譬如 java 的原子类就是通过 CAS 自旋实现的。 分段锁：实质是一种锁的设计策略，不是具体的锁，对于 ConcurrentHashMap 而言其并发的实现就是通过分段锁的形式来实现高效并发操作；当要 put 元素时并不是对整个 hashmap 加锁，而是先通过 hashcode 知道它要放在哪个分段，然后对分段进行加锁，所以多线程 put 元素时只要放在的不是同一个分段就做到了真正的并行插入，但是统计 size 时就需要获取所有的分段锁才能统计；分段锁的设计是为了细化锁的粒度。 偏向锁、轻量级锁、重量级锁：这种分类是按照锁状态来归纳的，并且是针对 synchronized 的，java 1.6 为了减少获取锁和释放锁带来的性能问题而引入的一种状态，其状态会随着竞争情况逐渐升级，锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后无法降为偏向锁，这种升级无法降级的策略目的就是为了提高获得锁和释放锁的效率。 自旋锁：其实是相对于互斥锁的概念，互斥锁线程会进入 WAITING 状态和 RUNNABLE 状态的切换，涉及上下文切换、cpu 抢占等开销，自旋锁的线程一直是 RUNNABLE 状态的，一直在那循环检测锁标志位，机制不重复，但是自旋锁加锁全程消耗 cpu，起始开销虽然低于互斥锁，但随着持锁时间加锁开销是线性增长。 可中断锁：synchronized 是不可中断的，Lock 是可中断的，这里的可中断建立在阻塞等待中断，运行中是无法中断的。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:11:0","series":null,"tags":null,"title":"Java线程安全","uri":"/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#锁分类"},{"categories":null,"content":" 状态 new 新建 Runnable 可运行 Blocaked 阻塞 Waiting 等待 Timed waiting 计时等待 Terminated 终止 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:1:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#状态"},{"categories":null,"content":" 核心方法 void start()启动 void run()调用内部Runnable的run()。 public static void sleep(long millis)休眠指定的毫秒数。 static void yield()使当前运行的线程向另一个线程交出运行权。 getState()获取当前线程状态。 void stop() 终止线程，已废弃。 void suspend() 暂停线程，已废弃。 void resume() 恢复已暂停的线程，已废弃。 void interrupt() 请求终止线程，变更标记为，需要用isInterrupted()判断。还会抛出InterruptedException。 public static boolean interrupted() 检查是否被中断，会重置中断状态为false。 boolean isInterrupted() 作用同上，但是不会重置状态。 static Thread currentThread()获取当前正在执行的线程对象。 void setName(String name) 给线程起个名。 void setDaemon(boolean isDaemon) 转为守护线程。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:2:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#核心方法"},{"categories":null,"content":" 阻塞 当一个线程要访问对象时（参与竞争对象锁），而该对象锁被正在被其他线程持有，此线程就会阻塞，直到其他线程释放对象锁，并且线程调度器允许此线程持有对象锁。 当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。比如调用了Object.wait()或Thread.join()方法，或者是java.util.concurrent库中的Lock.tryLock()、Condition.await。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:3:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#阻塞"},{"categories":null,"content":" 终止 任务执行完毕，run方法正常退出，线程正常终止。 抛出异常终止。 调用stop()方法。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:4:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#终止"},{"categories":null,"content":" 中断 mThread.interrupt()可中断线程，但并不会终止，而只是变更了中断状态。 Thread.currentThread().isInterrupted()可以检查中断状态。 如果线程正在阻塞中，调用interrupt()方法会抛出InterruptedException异常。捕获这个异常后，可以在线程内部的catch里面在此调用interrupt()方法变更状态。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:5:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#中断"},{"categories":null,"content":" 守护线程守护线程是为其他线程提供服务的线程。JVM退出时会自动回收守护线程。 mThread.setDaemon(true); 典型的就是GC线程。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:6:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#守护线程"},{"categories":null,"content":" 未捕获异常处理器线程的run方法不能包抛出任何检查型异常，但是非检查型异常会导致线程终止。 可以通过实现Thread.UncaughtExceptionHandler接口，自定义一个未捕获异常处理器： //创建线程 Thread t = new Thread(); //创建处理器 UncaughtExceptionHandler handler = new UncaughtExceptionHandler(); //设置处理器 t.setUncaughtExceptionHandler(handler); //设置全局默认处理器 Thread.setDefaultUncaughtExceptionHandler(handler); static class UncaughtExceptionHandler implements Thread.UncaughtExceptionHandler{ @Override public void uncaughtException(@NonNull Thread t, @NonNull Throwable e) { //可以做异常采集、打印日志 } } ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:7:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#未捕获异常处理器"},{"categories":null,"content":" 线程优先级可以使用void setPriority(int newPriority)设置线程优先级，值在1~10，默认为5。系统自带的常量如下： MIN_PRIORITY = 1 最小优先级 NORM_PRIORITY = 5 默认优先级 MAX_PRIORITY = 10 最大优先级 默认情况下，线程会继承创建他自身的线程的优先级。 当线程调度器有机会选择新线程时，优先选择高优先级。 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:8:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#线程优先级"},{"categories":null,"content":" 线程间通信 wait()、notifyAll() Handler+Message 共享变量 信号量 ","date":"2021-03-19","objectID":"/java%E7%BA%BF%E7%A8%8B/:9:0","series":null,"tags":null,"title":"Java线程","uri":"/java%E7%BA%BF%E7%A8%8B/#线程间通信"},{"categories":null,"content":" 阻塞队列 BlockingQueue生产者\u0026消费者模型 队列的意义： 生产者与消费者解耦 平衡生产与消费速度 可应用于消息中心 默认实现： 队列 界限 特点 ArrayBlockingQueue 有 一个由数组结构组成的有界 LinkedBlockingQueue 有 链表结构 PriorityBlockingQueue 无 支持优先级排序，可以传入比较器 DelayQueue 无 支持优先级，支持元素的延迟获取 SynchronousQueue 不储存元素，用来解耦 LinkedTransferQueue 无 链表结构 LinkedBlockingQueue 双向链表 有界\u0026无界 有界：长度有限，满了会阻塞； 无界：可以随意放东西，不会阻塞； ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:1:0","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#阻塞队列-blockingqueue"},{"categories":null,"content":" 核心方法　1.放入数据 offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）；　offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。 put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续. poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null; poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。 take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 下面几个方法要记住 方法 阻塞 作用 offer no 添加元素成功返回true，如果队列已满返回false，重载方法可以设置等待时间。 put yes 添加元素，如果空间已满，会阻塞线程直到添加成功 poll no 取走队列首位元素，可以设定等待时间，失败返回false take yes 取走队列首位元素，如果没有就会阻塞线程直到有了为止 drainTo 一次性获取多个或全部元素 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:1:1","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#核心方法"},{"categories":null,"content":" 核心方法　1.放入数据 offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）；　offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。 put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续. poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null; poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。 take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 下面几个方法要记住 方法 阻塞 作用 offer no 添加元素成功返回true，如果队列已满返回false，重载方法可以设置等待时间。 put yes 添加元素，如果空间已满，会阻塞线程直到添加成功 poll no 取走队列首位元素，可以设定等待时间，失败返回false take yes 取走队列首位元素，如果没有就会阻塞线程直到有了为止 drainTo 一次性获取多个或全部元素 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:1:1","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#下面几个方法要记住"},{"categories":null,"content":" Java默认线程池 Executors.newCachedThreadPool()，创建一个可缓存的无界线程池，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程。当线程空闲超过60秒自动回收，当任务超过线程池的线程数，可无限创建新线程； Executors.newFixedThreadPool(int nThreads)，创建一个指定大小的线程池，可控制线程的最大并发数，超出的线程会在LinkedBlockingQueue阻塞队列中等待； Executors.newScheduledThreadPool，创建一个定长的线程池，可以指定线程池核定线程数，支持定时及周期性任务的执行； Executors.newSingleThreadExecutor，创建一个单线程的线程池。 Executors.newWorkStealingPool（java8引入），创建一个更加高效的线程池，不同于以上四种线程池，这个线程池拓展于ForkJoinPool，适合用于非常耗时或自任务众多的场景。 前四种是我们一般用到的线程池，都是拓展自ThreadPoolExecutor类。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:0","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#java默认线程池"},{"categories":null,"content":" 自定义线程池与ThreadPoolExecutor我们也可以通过使用ThreadPoolExecutor类实现自定义线程池。 public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u003cRunnable\u003e workQueue, ThreadFactory threadFactory ) 参数解析： corePoolSize 线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果通过allowCoreThreadTimeOut(boolean value)方法设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime后，核心线程就会被终止。 maximumPoolSize 线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。 keepAliveTime 非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPool-Executor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程。 unit 用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit. MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）以及TimeUnit.MINUTES（分钟）等。 workQueue 线程池中的阻塞队列，用来容纳超出core线程数的runnable。 threadFactory 线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r)，一般使用默认的，也可以自定义用来设置thread-name。 Rejected-ExecutionHandler handler 当线程池无法执行新任务时，比如线程全忙并且队列已满，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecution-Exception。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值。 ThreadPoolExecutor执行任务时大致遵循如下规则： 如果当前线程数小于core，那就创建线程直接执行； 如果core满了，就会把task放入BlockingQueue中排队； 如果BlockingQueue也满了，就新建线程直接执行； 如果当前线程数量超过maxPoolSizie，就拒绝。 默认实现的拒绝策略： AbortPolicy 直接抛出异常（抛异常）； DiscardPolicy 把新的任务直接扔掉（后进先出）。 DiscardOldestPolicy 直接丢弃最旧的还没执行的任务（先进先出）； CallerRunsPolicy 让调用者所在线程去执行任务，比如调用者是主线程，就会切回主线程（扯皮）； ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:0","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#自定义线程池与threadpoolexecutor"},{"categories":null,"content":" 参数配置AsyncTask支持并发时的配置： 通过以下代码获取CPU核心数： Runtime.getRuntime().availableProcessors() 配置原则： CPU密集型：大规模运算，没有阻塞，为减少cpu轮转次数，尽量减少线程数量，公式：CPU核心数+1; IO密集型：阻塞多，尽量多给线程提高速度，公式：CPU核心数*2； 混合型：如果密集计算耗时与IO耗时差不多，就拆分成两个线程池来玩。 AsyncTask的配置： 核心线程数等于CPU核心数+1； 线程池的最大线程数为CPU核心数的2倍+1； 核心线程无超时机制，非核心线程在闲置时的超时时间为1秒； 任务队列的容量为128。 为什么要加1？因为在硬盘上有虚拟内存，为了在发生“页缺失”现象时，不让CPU核心闲置，所以要加1。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:1","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#参数配置"},{"categories":null,"content":" 参数配置AsyncTask支持并发时的配置： 通过以下代码获取CPU核心数： Runtime.getRuntime().availableProcessors() 配置原则： CPU密集型：大规模运算，没有阻塞，为减少cpu轮转次数，尽量减少线程数量，公式：CPU核心数+1; IO密集型：阻塞多，尽量多给线程提高速度，公式：CPU核心数*2； 混合型：如果密集计算耗时与IO耗时差不多，就拆分成两个线程池来玩。 AsyncTask的配置： 核心线程数等于CPU核心数+1； 线程池的最大线程数为CPU核心数的2倍+1； 核心线程无超时机制，非核心线程在闲置时的超时时间为1秒； 任务队列的容量为128。 为什么要加1？因为在硬盘上有虚拟内存，为了在发生“页缺失”现象时，不让CPU核心闲置，所以要加1。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:1","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#配置原则"},{"categories":null,"content":" 线程池的关闭 shutDown 关闭线程池，然后尝试中断当前没有执行任务的线程； shutDownNow 尝试中断所有的线程。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:2","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#线程池的关闭"},{"categories":null,"content":" 原理","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:0","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#原理"},{"categories":null,"content":" execute任务调度： //当前线程数 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); public void execute(Runnable command) { //当前运行的任务数 int c = ctl.get(); //如果小于核心数，就addWork if (workerCountOf(c) \u003c corePoolSize) { //如果当前活跃线程数小于设置的核心线程数，直接执行任务 if (addWorker(command, true)) return; c = ctl.get(); } //如果大于核心数，并且线程池还在运行，就添加到队列中 if (isRunning(c) \u0026\u0026 workQueue.offer(command)) { int recheck = ctl.get(); //如果线程池已经停止运行，就移除任务 if (! isRunning(recheck) \u0026\u0026 remove(command)) //移除成功就执行拒绝策略 reject(command); else if (workerCountOf(recheck) == 0) //线程池不在运行状态，或者移除失败，并且当前没有任务，就开启一个空任务 addWorker(null, false); } //如果添加任务失败，就执行拒绝策略 else if (!addWorker(command, false)) reject(command); } execute方法主要用来调度任务，据当前原子计数器c的状态和任务数， 如果当前任务数小于核心线程数，就直接addWorker； 如果大于核心线程数，就把任务添加到阻塞队列； 如果队列已满，尝试addworker; 如果队列满，addWorker失败，则执行拒绝策略。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:1","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#execute任务调度"},{"categories":null,"content":" addWorker线程调度 //我才是真正的线程池子 private final HashSet\u003cWorker\u003e workers = new HashSet\u003c\u003e(); private boolean addWorker(Runnable firstTask, boolean core) { //使用cas失败自旋来保证线程竞争问题 retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs \u003e= SHUTDOWN \u0026\u0026 ! (rs == SHUTDOWN \u0026\u0026 firstTask == null \u0026\u0026 !workQueue.isEmpty()) ) return false; for (;;) { int wc = workerCountOf(c); if (wc \u003e= CAPACITY || wc \u003e= (core ? corePoolSize : maximumPoolSize)) return false; //CAS操作 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { //Worker是对runnable和Thread的装箱，构造方法会调用ThreadFactory生成一个Thread w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { final ReentrantLock mainLock = this.mainLock; mainLock.lock();//上锁， try { int rs = runStateOf(ctl.get()); if (rs \u003c SHUTDOWN || (rs == SHUTDOWN \u0026\u0026 firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //添加进线程栈 workers.add(w); int s = workers.size(); if (s \u003e largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { //core线程直接运行 t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; } addWorker主要用来调度线程。首先创建work，然后把work添加进线程池workers，并通过主锁mainLock保证线程池workers的安全。最后启动worker的线程。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:2","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#addworker线程调度"},{"categories":null,"content":" work //ThreadPoolExecutor的匿名内部类，满足AQS实现不可重入的锁，满足Runnable，内部包含Thread private final class Worker extends AbstractQueuedSynchronizer implements Runnable { //可以序列化 private static final long serialVersionUID = 6138294804551838833L; //线程 final Thread thread; //任务 Runnable firstTask; volatile long completedTasks; //构造方法，调用时从ThreadFactory创建新的线程 Worker(Runnable firstTask) { setState(-1); this.firstTask = firstTask; //注意这里，给线程传入的是当前Worker this.thread = getThreadFactory().newThread(this); } //线程运行时会执行这个 public void run() { runWorker(this); } //尝试Acquire protected boolean tryAcquire(int unused) { if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } //尝试释放 protected boolean tryRelease(int unused) { setExclusiveOwnerThread(null); setState(0); return true; } public void lock() { acquire(1); } public boolean tryLock() { return tryAcquire(1); } public void unlock() { release(1); } public boolean isLocked() { return isHeldExclusively(); } //尝试中断 void interruptIfStarted() { Thread t; if (getState() \u003e= 0 \u0026\u0026 (t = thread) != null \u0026\u0026 !t.isInterrupted()) { try { t.interrupt(); } catch (SecurityException ignore) { } } } } work是ThreadPoolExecutor的内部类，是一个满足AQS的Runnable，在构造方法中通过factory创建一个线程并传入他自身，那么当addWork时会启动这个线程，而线程会执行他自己的run方法，run方法又调用了外层类ThreadPoolExecutor的runWorker方法。 work还提供了AQS操作和中断线程的方法，由此可见，work是Thread的装饰者。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:3","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#work"},{"categories":null,"content":" runWorker：复用线程 final void runWorker(Worker w) { //拿到线程 Thread wt = Thread.currentThread(); //拿到work构造方法传入的runnable Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { //循环执行任务 //如果firstTask有值,就直接执行这个任务 //如果没有具体的任务,就执行getTask()方法从队列中获取任务，当然这个操作是阻塞的 while (task != null || (task = getTask()) != null) { w.lock(); //检查线程池是否shutDown了，确保线程中断 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() \u0026\u0026 runStateAtLeast(ctl.get(), STOP))) \u0026\u0026 !wt.isInterrupted()) wt.interrupt(); try { beforeExecute(wt, task); Throwable thrown = null; try { //执行任务 task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } runWorker方法主要是对线程的控制，会循环调用getTask方法从任务队列中取出任务交给线程执行，达到线程复用的目的。当线程池shutDown时会中断线程。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:4","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#runworker复用线程"},{"categories":null,"content":" getTask阻塞队列取值 private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? //死循环 for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs \u003e= SHUTDOWN \u0026\u0026 (rs \u003e= STOP || workQueue.isEmpty())) { decrementWorkerCount(); return null; } //当前任务数 int wc = workerCountOf(c); // 如果当前任务数大于core，或者core线程也允许超时回收 boolean timed = allowCoreThreadTimeOut || wc \u003e corePoolSize; if ((wc \u003e maximumPoolSize || (timed \u0026\u0026 timedOut)) \u0026\u0026 (wc \u003e 1 || workQueue.isEmpty())) { if (compareAndDecrementWorkerCount(c)) return null; continue; } try { //如果当前任务数大于core就等着拿，超时就返回null；否则就阻塞等，一直等到有了为止 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } getTask主要用于从任务队列中取值，如果当前任务数大于核心线程数就直接拿，否则会阻塞等。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:5","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#gettask阻塞队列取值"},{"categories":null,"content":" 总结线程池的原理线程池我们从execute方法入手，execute方法主要用来调度任务，据当前原子计数器c的状态和任务数， 如果当前任务数小于核心线程数，就直接addWorker； 如果大于核心线程数，就把任务添加到阻塞队列； 如果队列已满，还是addworker; 如果队列满，addWorker失败，则执行拒绝策略。 addWorker主要用来调度线程。首先创建worker，然后把work添加进线程池workers，并通过主锁mainLock保证线程池workers的安全。最后启动worker的线程。 work是runnable的装饰者,除了具备runnable功能特性之外还提供AQS操作和中断线程的功能。它内部持有一个线程，由于他自己是runnable，所以线程会执行他自己，并再它自己的run方法内调用线程池的runWorker方法。 runWorker通过循环调用getTask()方法取出阻塞队列中的runnable来执行，当线程池shutdown的时候会尽量中断线程。 而getTask()方法会从阻塞队列中取出首位任务。如果队列中有任务会poll等待取出，等待的时间为线程池参数keepAliveTime，否则就会调用take一直阻塞等待任务。 ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:6","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#总结线程池的原理"},{"categories":null,"content":" retry标记上面的addWork方法中出现了retry:标记，这个标记主要是用于在多重循环中标记需要中断的循环层，也可以用其他字母+：的方式： //声明中断标记 aaa: //第一层循环f1 for (int i = 0; i \u003c 100; i++) { //第二层循环f2 for (int j = 0; j \u003c 200; j++) { if（j == 100) //将使f1跳过并继续 continue aaa; } } ","date":"2021-03-18","objectID":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/:5:0","series":null,"tags":null,"title":"Java线程池","uri":"/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#retry标记"},{"categories":null,"content":" 用法 // 步骤1：创建HandlerThread实例对象 // 传入参数 = 线程名字，作用 = 标记该线程 HandlerThread mHandlerThread = new HandlerThread(\"handlerThread\"); // 步骤2：启动线程 mHandlerThread.start(); // 步骤3：创建工作线程Handler \u0026 复写handleMessage（） // 作用：关联HandlerThread的Looper对象、实现消息处理操作 \u0026 与其他线程进行通信 // 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行 Handler workHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(@NonNull Message msg) { super.handleMessage(msg); Log.d(\"handler\", \"收到消息: \" + msg.obj); // 注意，不能在此处修改UI,因为workHandler还是位于工作线程，需要切换到主线程去修改UI } }; Message msg = Message.obtain(workHandler); msg.obj = \"我发了一条消息\"; // 消息的存放 msg.sendToTarget(); // 步骤5：结束线程，即停止线程的消息循环 mHandlerThread.quit(); ","date":"2021-03-18","objectID":"/handlerthread%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":null,"title":"HandlerThread解读","uri":"/handlerthread%E8%A7%A3%E8%AF%BB/#用法"},{"categories":null,"content":" 原理 //继承Thread，本身就是线程 public class HandlerThread extends Thread { int mPriority; int mTid = -1; //内部持有looper Looper mLooper; //内部持有handler private @Nullable Handler mHandler; public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; } public HandlerThread(String name, int priority) { super(name); mPriority = priority; } /** * Call back method that can be explicitly overridden if needed to execute some * setup before Looper loops. */ protected void onLooperPrepared() { } @Override public void run() { //Process是进程的帮助类，可提供进程信息 mTid = Process.myTid(); //初始化loop Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); //完成之后唤醒需要使用looper的线程，主要是针对getLooper()方法 notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); //开启循环 Looper.loop(); mTid = -1; } public Looper getLooper() { if (!isAlive()) { return null; } // 确保Looper一定能实例化 synchronized (this) { // 自旋 while (isAlive() \u0026\u0026 mLooper == null) { try { // 阻塞调用的线程，直到run方法中looper初始化完成 wait(); } catch (InterruptedException e) { } } } return mLooper; } //初始化内部Handler，但是外部不能调用此方法 @NonNull public Handler getThreadHandler() { if (mHandler == null) { mHandler = new Handler(getLooper()); } return mHandler; } //关闭 public boolean quit() { Looper looper = getLooper(); if (looper != null) { looper.quit(); return true; } return false; } //安全关闭 public boolean quitSafely() { Looper looper = getLooper(); if (looper != null) { looper.quitSafely(); return true; } return false; } //返回线程id public int getThreadId() { return mTid; } } ","date":"2021-03-18","objectID":"/handlerthread%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":null,"title":"HandlerThread解读","uri":"/handlerthread%E8%A7%A3%E8%AF%BB/#原理"},{"categories":null,"content":" 总结 HandlerThread本身就是一个线程，只不过它持有Looper,在run()方法内部实现了Looper.prepary()和Looper.loop()。所以任务也只能串行。 由于Looper是异步创建的，通过锁机制配合wait/notifyAll实现了一个阻塞唤醒机制，保证Looper在异步状态下必定能创建成功。 使用完要手动退出，否则线程一直存在。 ","date":"2021-03-18","objectID":"/handlerthread%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":null,"title":"HandlerThread解读","uri":"/handlerthread%E8%A7%A3%E8%AF%BB/#总结"},{"categories":null,"content":" 使用 public class MainActivity extends AppCompatActivity { TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = findViewById(R.id.tv); } public void start(View v) { MyTask task = new MyTask(this.tv); task.execute(\"我是\"); } @SuppressWarnings(\"deprecation\") private static class MyTask extends AsyncTask\u003cString, Float, String\u003e { WeakReference\u003cTextView\u003e tv; MyTask(TextView tv) { this.tv = new WeakReference\u003cTextView\u003e(tv); } @Override protected void onPreExecute() { super.onPreExecute(); // 任务执行前回调 tv.get().setText(\"即将开始任务\"); } @Override protected String doInBackground(String... strings) { //后台任务逻辑 if (strings.length \u003e 0) { try { for (int i = 0; i \u003c 5; i++) { Thread.sleep(2000L); //报告进度 publishProgress(0.2f * (i+1)); } } catch (InterruptedException e) { e.printStackTrace(); } return strings[0] + \"结果\"; } return null; } @Override protected void onProgressUpdate(Float... values) { super.onProgressUpdate(values); tv.get().setText(\"任务已执行\"+values[0]); } @Override protected void onPostExecute(String s) { super.onPostExecute(s); //刷新UI tv.get().setText(s); } } } 几个重要方法： 方法 线程 执行 onPreExecute 主线程 任务开始前执行 doInBackground 子线程 后台任务执行时调用 onProgressUpdate 主线程 publishProgress调用时回调 onPostExecute 主线程 任务完成后调用 onCancelled 主线程 cancell调用时回调 核心就这几个方法，只有doInBackground在子线程中调用。然后创建一个AsyncTask的实例，执行execute方法，并传入相应参数就开始执行了。 同时为避免内存泄露，需要用弱引用关联UI。 ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#使用"},{"categories":null,"content":" 原理","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#原理"},{"categories":null,"content":" 构造方法 public AsyncTask() { this((Looper) null); } public AsyncTask(@Nullable Handler handler) { this(handler != null ? handler.getLooper() : null); } /** * 最终构造方法 **/ public AsyncTask(@Nullable Looper callbackLooper) { //拿到Handler，默认拿到主线程Handler mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); //定义Callable，其中调用了doInBackground方法 mWorker = new WorkerRunnable\u003cParams, Result\u003e() { public Result call() throws Exception { mTaskInvoked.set(true); Result result = null; try { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //调用doInBackground result = doInBackground(mParams); Binder.flushPendingCommands(); } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { //发送Message postResult(result); } return result; } }; //用FutureTask包装Callable，提供启动、取消、监听功能 mFuture = new FutureTask\u003cResult\u003e(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 从这里可以看出，Async的主要流程在构造方法中就已经定义好了。 其中有个mWorker是WorkerRunnable类型： private static abstract class WorkerRunnable\u003cParams, Result\u003e implements Callable\u003cResult\u003e { Params[] mParams; } 查看源码才发现，这玩意并不是一个Runnable，而是个Callable，google跟我开了个玩笑。 接下来就是用FutureTask包装Callable，这样就可以具备启动、取消、完成监听功能。接下来我们去看execute方法。 ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:1","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#构造方法"},{"categories":null,"content":" execute //静态final类型的线程池 public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); //默认的线程池 private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; @MainThread public final AsyncTask\u003cParams, Progress, Result\u003e execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } //方法重载 @MainThread public static void execute(Runnable runnable) { sDefaultExecutor.execute(runnable); } 这里可以看出execute方法只能在主线程中调用。这就是AsyncTask的局限性了：只能用于主线程。 executeOnExecutor方法传入了默认的线程池。这个线程池是在AsyncTask类首次加载时初始化的。它是个static final类型。 @MainThread public final AsyncTask\u003cParams, Progress, Result\u003e executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); } } //改状态 mStatus = Status.RUNNING; //在MainThread回调onPreExecute onPreExecute(); mWorker.mParams = params; //真正的执行任务 exec.execute(mFuture); return this; } 从switch判断可以知道，AsyncTask是一次性的，不能复用，只有PENDING状态的AsyncTask才能运行。而状态是在类加载时定义的，而且不支持修改： @UnsupportedAppUsage private volatile Status mStatus = Status.PENDING; 在这个方法里，首先改变了全局的状态为「执行中」，然后通过exec.execute(mFuture)真正开始执行线程。在这里查看源码，发现FutureTask这个类同时遵循Runnable和Future接口，所以他可以被线程池execute，也能接收到callable的返回值。这也是Callable转Runnable的一种方式。 然后来看AsyncTask的三种状态： public enum Status { //未执行 PENDING, //执行中 RUNNING, //执行完 FINISHED, } ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:2","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#execute"},{"categories":null,"content":" publishProgress @WorkerThread protected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult\u003cProgress\u003e(this, values)).sendToTarget(); } } 报告消息是基于Handler+message的形式实现的。 这个消息的what是MESSAGE_POST_PROGRESS这个常量。obj是new了一个AsyncTaskResult\u003cProgress\u003e(this, values)： private static class AsyncTaskResult\u003cData\u003e { final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) { mTask = task; mData = data; } } 接收消息的Handler，依靠这个Handler切换回主线程: private static class InternalHandler extends Handler { public InternalHandler(Looper looper) { super(looper); } @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"}) @Override public void handleMessage(Message msg) { AsyncTaskResult\u003c?\u003e result = (AsyncTaskResult\u003c?\u003e) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:3","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#publishprogress"},{"categories":null,"content":" onPostExecute这个方法是在构造方法的WorkerRunnable中的逻辑执行完毕，最后finally里面调用的。 mWorker = new WorkerRunnable\u003cParams, Result\u003e() { public Result call() throws Exception { mTaskInvoked.set(true); Result result = null; try { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { postResult(result); } return result; } }; 在这个方法当然也是通过发送消息的方式达到线程间通信的目的： private Result postResult(Result result) { @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult\u003cResult\u003e(this, result)); message.sendToTarget(); return result; } 最后在Handler的handleMessage中通过what做判断，如果是postResult，就调用finish()方法： private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } AsyncTask的流程已经通了，最后再来看一下它是怎么玩线程池的。 ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:4","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#onpostexecute"},{"categories":null,"content":" AsyncTask工作线程池的实现它这里是自定义了一个线程池代理： private static class SerialExecutor implements Executor { //可作为栈或队列使用，性能较高 final ArrayDeque\u003cRunnable\u003e mTasks = new ArrayDeque\u003cRunnable\u003e(); Runnable mActive; public synchronized void execute(final Runnable r) { //在队尾添加元素 mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { //poll()拿出队首元素 if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 这货实际上是THREAD_POOL_EXECUTOR这个线程池的代理，作用就是维护任务队列。 ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:5","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#asynctask工作线程池的实现"},{"categories":null,"content":" 线程池参数 //核心线程数，一直处于活动状态 private static final int CORE_POOL_SIZE = 1; //最大线程数，当一个任务提交到线程池中时，如果线程数量达到了核心线程数，并且任务队列已满，不能再向任务队列中添加任务时，这时会检查任务是否达到了最大线程数，如果未达到，则创建新线程，执行任务，否则，执行拒绝策略。 private static final int MAXIMUM_POOL_SIZE = 20; //活跃时间，线程池中大于核心线程数的那部分线程，在执行完任务之后，在线程池中存活的时间 private static final int KEEP_ALIVE_SECONDS = 3; //线程工厂 private static final ThreadFactory sThreadFactory = new ThreadFactory() { private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) { return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); } }; public static final Executor THREAD_POOL_EXECUTOR; static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e(), sThreadFactory); threadPoolExecutor.setRejectedExecutionHandler(sRunOnSerialPolicy); THREAD_POOL_EXECUTOR = threadPoolExecutor; } 首先执行这个静态代码块，初始化线程池。 我们看这里的线程池最大核心数只有1，那就是只能串行，最大线程数20，最多能有19个线程排队等待。 ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:6","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#线程池参数"},{"categories":null,"content":" 线程池拒绝策略 //核心线程数\u0026最大线程数 private static final int BACKUP_POOL_SIZE = 5; private static final RejectedExecutionHandler sRunOnSerialPolicy = new RejectedExecutionHandler() { public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { android.util.Log.w(LOG_TAG, \"Exceeded ThreadPoolExecutor pool size\"); synchronized (this) { if (sBackupExecutor == null) { sBackupExecutorQueue = new LinkedBlockingQueue\u003cRunnable\u003e(); sBackupExecutor = new ThreadPoolExecutor( BACKUP_POOL_SIZE, BACKUP_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sBackupExecutorQueue, sThreadFactory); sBackupExecutor.allowCoreThreadTimeOut(true); } } sBackupExecutor.execute(r); } }; 如果被拒绝，就新创建一个线程池去执行，这都可以？ ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:2:7","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#线程池拒绝策略"},{"categories":null,"content":" 总结AsyncTask类首次加载的时候初始化两个静态的线程池，SerialExecutor是个代理，内部维护着Runnable队列，实际通过调用threadPoolExecutor来执行任务。由于线程池不能保证线程执行的先后，所以AsyncTask通过加入外部队列的方式保障了任务执行的顺序。 AsyncTask的构造方法内部初始化了Callable，AsyncTask的主要流程都定义在Callable的call()方法内部，然后通过FutureTask包装Callable转换为Runnable传给线程池执行，同时可以取消任务或者获取返回值，最后通过内部的Handler发送消息切换回主线程。 由于内部的Handler在创建时传入Looper.getMainLooper()，所以默认线程就是主线程，并且execute()方法带有@MainThread注解，导致AsyncTask只能在主线程中使用。 AsyncTask初始化时状态为pending，在任务执行过程中变换为Running或finished，不可手动更改状态，导致AsyncTask不能复用。 ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#总结"},{"categories":null,"content":" 如何正确配置线程池的参数前面我们讲到了手动创建线程池涉及到的几个参数，那么我们要如何设置这些参数才算是正确的应用呢？实际上，需要根据任务的特性来分析。 任务的性质：CPU密集型、IO密集型和混杂型 任务的优先级：高中低 任务执行的时间：长中短 任务的依赖性：是否依赖数据库或者其他系统资源 不同的性质的任务，我们采取的配置将有所不同。在《Java并发编程实践》中有相应的计算公式。 通常来说，如果任务属于CPU密集型，那么我们可以将线程池数量设置成CPU的个数，以减少线程切换带来的开销。如果任务属于IO密集型，我们可以将线程池数量设置得更多一些，比如CPU个数*2。 PS：我们可以通过Runtime.getRuntime().availableProcessors()来获取CPU的个数。 作者：juconcurrent 链接：https://www.jianshu.com/p/7ab4ae9443b9 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-03-17","objectID":"/asynctask%E8%A7%A3%E8%AF%BB/:3:1","series":null,"tags":["Android","AsyncTask"],"title":"AsyncTask解读","uri":"/asynctask%E8%A7%A3%E8%AF%BB/#如何正确配置线程池的参数"},{"categories":null,"content":" 从Set方法入手 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 从这里可以看出，threadLocal的核心其实是ThreadLocalMap对象。 set方法的作用是初始化内部的ThreadLocalMap，并将元素放入ThreadLocalMap中暂存，当前的ThreadLocal对象为key。 然后关注createMap()方法： void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } ThreadLocalMap(ThreadLocal\u003c?\u003e firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode \u0026 (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } 每个线程中都有一个threadLocals对象，每次调用createMap()方法时都会给线程的threadLocals创建一个新的ThreadLocalMap，那么每次调用set()方法，其实是set给当前线程的ThreadLocalMap。 结论：ThreadLocal的set方法其实是把值存到了当前线程内部的threadLocals，而threadLocals是一个ThreadLocalMap类型的map（map嵌套），key就是当前的ThreadLocal。 ","date":"2021-03-17","objectID":"/threadlocal%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":null,"title":"ThreadLocal解读","uri":"/threadlocal%E8%A7%A3%E8%AF%BB/#从set方法入手"},{"categories":null,"content":" Get public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } //ThreadLocal内部方法 private Entry getEntry(ThreadLocal\u003c?\u003e key) { int i = key.threadLocalHashCode \u0026 (table.length - 1); Entry e = table[i]; if (e != null \u0026\u0026 e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } ","date":"2021-03-17","objectID":"/threadlocal%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":null,"title":"ThreadLocal解读","uri":"/threadlocal%E8%A7%A3%E8%AF%BB/#get"},{"categories":null,"content":" ThreadLocalMapThreadLocalMap其实是个简化的HashMap，内部是个Entry类型的数组。 static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } ","date":"2021-03-17","objectID":"/threadlocal%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":null,"title":"ThreadLocal解读","uri":"/threadlocal%E8%A7%A3%E8%AF%BB/#threadlocalmap"},{"categories":null,"content":" 真的线程安全？大部分博客都说ThreadLocal是把变量在每个线程生成变量副本，线程只能操作属于自己的副本，从而不会相互影响，并且线程安全。 但是我翻来覆去的看代码，也没有看到打破引用的代码啊，没有clone，没有new，那怎么能叫副本呢？那应该不管怎么赋值，都是共享变量的引用才对啊。那么在不同线程中操作同一共享变量，又没加锁，还谈什么线程安全？ 那就写个例子来印证一下： public class MainActivity extends AppCompatActivity { //随便创建一个线程池 private final ThreadPoolExecutor tpe = new ThreadPoolExecutor(8, 8, 1, TimeUnit.SECONDS, new LinkedBlockingDeque\u003cRunnable\u003e()); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } //点击按钮后让线程池执行两个任务 Data data; public void start(View v) { data = new Data(); tpe.execute(new MyRunnable1(data)); tpe.execute(new MyRunnable2(data)); } //等10秒之后点第二个按钮展示结果 public void toastResult(View v) { Log.d(\"我试试\", \"toastResult: \" + data); Toast.makeText(this, \"toastResult: \" + data, Toast.LENGTH_SHORT).show(); } //任务1 static class MyRunnable1 implements Runnable { private final ThreadLocal\u003cData\u003e mThreadLocal = new ThreadLocal\u003c\u003e(); Data data; MyRunnable1(Data data) { this.data = data; } @Override public void run() { mThreadLocal.set(data); mThreadLocal.get().name = \"李四\"; mThreadLocal.get().age = 10; try { Thread.sleep(10*1000); Log.d(\"我试试\", \"线程1： \" + data); } catch (InterruptedException e) { e.printStackTrace(); } } } // 任务2 static class MyRunnable2 implements Runnable { private ThreadLocal\u003cData\u003e mThreadLocal = new ThreadLocal\u003c\u003e(); Data data; MyRunnable2(Data data) { this.data = data; } @Override public void run() { try { Thread.sleep(3000); Log.d(\"我试试\", \"线程2：\" + data); mThreadLocal.set(data); mThreadLocal.get().name = \"王五\"; mThreadLocal.get().age = 20; } catch (InterruptedException e) { e.printStackTrace(); } } } static class Data { int age = 1; String name = \"张三\"; Data(int age, String name) { this.age = age; this.name = name; } Data() { } @NonNull @Override public String toString() { return this.name + this.age; } } } 上面代码的逻辑：创建一个变量，然后分别在两个线程中用set进各自的ThreadLocal，然后get各自的变量副本，修改值，打印当前值。最后等个20秒以后点一下获取结果按钮。 但是当我最后获取结果的时候，发现原始的Data数据变了，变成了任务2中的赋值结果！而且在两个任务执行期间，threadLocal.get()也能看到其他变量对data的修改结果，果然跟我的猜测不错！ 通过印证，我发现ThreadLocal并不能解决线程安全问题，也并不是什么共享变量的副本。他的作用只是把数据与线程绑定，而且通过弱引用的方式避免线程作用域内的对象内存泄露。 ","date":"2021-03-17","objectID":"/threadlocal%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":null,"title":"ThreadLocal解读","uri":"/threadlocal%E8%A7%A3%E8%AF%BB/#真的线程安全"},{"categories":null,"content":" 为什么Looper采用ThreadLocal？因为一般我们操作线程的变量，都要在线程里面去改它。我们可能new一个Thread或者new一个Runnable，通过构造方法或者在run方法里面去写变量赋值。那么问题来了，如果你拿不到线程，不能修改线程呢？比如ActivityThread。 而Looper的源码里面没有一句操作线程的代码，而是巧用了ThreadLocal完成了Looper自己与线程的绑定！！！ 所以ThreadLocal的应用场景是：不需要在线程中做操作，只需要把变量与线程绑定时就用ThreadLocal!ThreadLocal就是个中介者模式！ ","date":"2021-03-17","objectID":"/threadlocal%E8%A7%A3%E8%AF%BB/:5:0","series":null,"tags":null,"title":"ThreadLocal解读","uri":"/threadlocal%E8%A7%A3%E8%AF%BB/#为什么looper采用threadlocal"},{"categories":null,"content":" class Data implements Parcelable { /** * 字段 */ private String name; /** * 构造方法内读取 * @param in */ protected Data(Parcel in) { name = in.readString(); } /** * 写入 */ @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); } /** * 生成器常量 */ public static final Creator\u003cData\u003e CREATOR = new Creator\u003cData\u003e() { /** * 调用构造方法生成一个实例 * @param in * @return */ @Override public Data createFromParcel(Parcel in) { return new Data(in); } /** * 生成对应类型的数组 * @param size * @return */ @Override public Data[] newArray(int size) { return new Data[size]; } }; @Override public int describeContents() { return 0; } //===========以下是getter和setter访问器 public String getName() { return name; } public void setName(String name) { this.name = name; } } Parcelable使用： 继承Parcelable接口； 声明构造方法，从Parcel中序列化数据； 重写writeToParcel(Parcel dest, int flags)方法，用来反序列化； 创建Creator\u003cData\u003e类型的CREATOR，其内部实现了反序列化对象和数组的方法； 重写describeContents()方法。 ","date":"2021-03-12","objectID":"/parcelable%E8%A7%A3%E8%AF%BB/:0:0","series":null,"tags":["Android"],"title":"Parcelable解读","uri":"/parcelable%E8%A7%A3%E8%AF%BB/#"},{"categories":null,"content":" Parcel我们知道，序列化和反序列化都离不开Parcel对象，那他是个啥？ 序列化的调用顺序： //在我们的自定义类中： @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); } //最终调用Parcel类中： public void writeString16NoHelper(@Nullable String val) { nativeWriteString16(mNativePtr, val); } //本地JNI方法 @FastNative private static native void nativeWriteString16(long nativePtr, String val); Parcel用来包装数据，并且提供了大量的read/write方法，最终会调用本地方法通过Binder读写数据到一块共享内存。 这里就与Serializable有很大的不同。Serializable的原理是通过IO将数据写到一个文件中。 那么而这对比，肯定内存的读写性能要高于硬盘文件系统啊，这就是为什么Parcelable比Serializable快很多的原因。 ","date":"2021-03-12","objectID":"/parcelable%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":["Android"],"title":"Parcelable解读","uri":"/parcelable%E8%A7%A3%E8%AF%BB/#parcel"},{"categories":null,"content":" Parcel的创建 //池子内最大6个 private static final int POOL_SIZE = 6; private static final Parcel[] sOwnedPool = new Parcel[POOL_SIZE]; private static final Parcel[] sHolderPool = new Parce[POOL_SIZE]; @NonNull public static Parcel obtain() { final Parcel[] pool = sOwnedPool; synchronized (pool) { Parcel p; for (int i=0; i\u003cPOOL_SIZE; i++) { p = pool[i]; if (p != null) { //池子中取出一个 pool[i] = null; //重置属性 p.mReadWriteHelper = ReadWriteHelper.DEFAULT; //返回 return p; } } } //如果池子是空的则new一个 return new Parcel(0); } ","date":"2021-03-12","objectID":"/parcelable%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":["Android"],"title":"Parcelable解读","uri":"/parcelable%E8%A7%A3%E8%AF%BB/#parcel的创建"},{"categories":null,"content":" Parcel的回收 public final void recycle() { if (DEBUG_RECYCLE) mStack = null; freeBuffer(); final Parcel[] pool; if (mOwnsNativeParcelObject) { pool = sOwnedPool; } else { mNativePtr = 0; pool = sHolderPool; } synchronized (pool) { for (int i=0; i\u003cPOOL_SIZE; i++) { if (pool[i] == null) { pool[i] = this; return; } } } } 啥意思呢？本来这个Parcel是自由的，有个民警同志带着这个parcel去看守所转了一圈，一旦发现有空牢房，就把Parcel扔进去，就算回收了。等刑满社会需要Parcel的时候再放出来给社会做贡献。 ","date":"2021-03-12","objectID":"/parcelable%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":["Android"],"title":"Parcelable解读","uri":"/parcelable%E8%A7%A3%E8%AF%BB/#parcel的回收"},{"categories":null,"content":" Parcel的销毁 @Override protected void finalize() throws Throwable { if (DEBUG_RECYCLE) { if (mStack != null) { Log.w(TAG, \"Client did not call Parcel.recycle()\", mStack); } } destroy(); } private void destroy() { resetSqaushingState(); if (mNativePtr != 0) { if (mOwnsNativeParcelObject) { nativeDestroy(mNativePtr); updateNativeSize(0); } mNativePtr = 0; } } 竟然是重写finalize()方法手动销毁的！ finalize()方法会在GC时回调，用来释放非Java对象，比如JNI中的C/C++对象。此处是为了调用nativeDestroy(mNativePtr)方法释放本地C++对象。 ","date":"2021-03-12","objectID":"/parcelable%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":["Android"],"title":"Parcelable解读","uri":"/parcelable%E8%A7%A3%E8%AF%BB/#parcel的销毁"},{"categories":null,"content":" Binder是什么 进程间通讯机制 系统驱动 Binder.java跨进程能力 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:1:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#binder是什么"},{"categories":null,"content":" 为何要多进程 申请更多内存 安全性隔离 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:2:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#为何要多进程"},{"categories":null,"content":" Binder的优势 机制 性能 特点 安全性 Binder 一次拷贝 CS架构易用 为每个App分配UID，支持实名和匿名 共享内存 零拷贝 控制复杂 差 socket 双拷贝 CS架构，传输率低开销大 差 信号量 双拷贝 缓存-转发 差 管道 双拷贝 缓存-转发 差 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:3:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#binder的优势"},{"categories":null,"content":" 进程之间如何通讯","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:4:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#进程之间如何通讯"},{"categories":null,"content":" 用户空间与内核空间 操作系统内部分为用户空间与内核空间。 从图中看，应用的进程处于用户空间，系统中同时存在多个应用相当于同时存在多个用户空间。而所有的用户空间都对应同一个内核空间。用户空间相互之间不共享，但是内核空间是共享的。 所有系统资源的管理都是在内核空间进行的，那我们应用程序需要访问磁盘，读取网卡的数据，新建一个线程都需要通过系统调用接口，完成从用户态到内存态的切换。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。 比如我们 Java 中需要新建一个线程，new Thread( Runnable …) 之后调用 start() 方法时, 看Hotspot Linux 的JVM 源码实现，最终是调pthread_create 系统方法来创建的线程，这里会从用户态切换到内核态完成系统资源的分配，线程的创建。 那么不共享的用户空间之间怎么进行通信呢？传统的linux的IPC是使用双拷贝进行的，即不同用户空间中，不能简单的通过引用指针传递数据，而是必须在内核空间中调用copy_from_user先把数据拷贝到内核空间，再调用copy_to_user把数据拷贝到client所在的用户空间B。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:4:1","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#用户空间与内核空间"},{"categories":null,"content":" Binder通讯机制 这就很像我们在家里访问百度，我们先从浏览器输入百度的域名回车，然后请求会先到达附近的DNS，DNS负责把域名解析成对应的IP地址，然后转发请求到这个IP的服务器上。 server，负责创建Binder实体，并且把Binder实体以名称的形式字注册到ServiceManager； ServiceManager，是一个独立的进程，提供Binder的注册和查询功能；ServiceManager自己其实也是个server，自己带有一个特殊的Binder实体（0号），而其他进程都可以看作是client。当我们的server创建Binder实体后，通过这个特殊的binder通信实现注册。而client也通过这个特殊的Binder，去查询目标Binder的名字，查到就返回Binder的引用。 Binder驱动，真正的通信是由Binder驱动来完成的，提供了用户空间到内核空间切换（数据拷贝）线程管理，PID、UID管理等功能。 这里要注意的是，SM位于用户空间，而BinderDriver位于内核空间。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#binder通讯机制"},{"categories":null,"content":" BinderDriver的作用主要是用来创建Binder实体，并且控制实体的访问，包括多线程对实体的访问安全，Client的访问权限，进程的中断等待等。 当有进程通过BINDERSETCONTEXT_MGR 命令把自己注册成为ServiceManager时，会通过BinderDriver创建一个默认的Binder实体，并置于0号位，并且后面的新创建的Client都默认持有这个0号位的Binder实体（zygote不断fork自己，所以都带有0号位）。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:1","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#binderdriver的作用"},{"categories":null,"content":" ServiceManager的宏观作用SM是一个独立的守护进程，是Android系统中各个服务的管理者。系统中的所有server都通过名称-引用的方式在SM中注册，而client全都要通过SM查询服务名找到目标server之后再使用server提供的功能。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:2","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#servicemanager的宏观作用"},{"categories":null,"content":" Binder机制的宏观作用从上面我们看SM的作用，就知道整个Binder机制的宏观作用，他就是Android系统的心脏，负责驱动Android系统的所有功能。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:3","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#binder机制的宏观作用"},{"categories":null,"content":" Binder的通信过程 ioctl函数是linux系统中驱动程序对外提供的调用接口。 注册过程 Server进程启动之后，通过ioctl函数向Driver发起请求，并指明需要0号位binder引用对应的进程来处理； 驱动收到请求后，通过SM内部的红黑树查询是否注册过binder实体，由于0号位已注册过了，就不需要再创建实体和添加引用了，直接把Binder实体转发给对应的进程，在这里就是SM进程； SM收到请求之后，将Server的binder引用添加到内部的单链表中，完成注册； 通信过程 client通过ioctl函数向Driver发起请求（包含binder名称）； Driver将请求转发给SM； SM在引用单链表中根据名称查询Server的引用； 通过Driver返回Binder的引用； Client收到引用之后，创建一个Server的代理； Client调用代理的接口，通过Driver与真正的Server进行交互。 总结整个通信过程，其实就是创建远程代理与调用远程代理的过程。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#binder的通信过程"},{"categories":null,"content":" Binder的通信过程 ioctl函数是linux系统中驱动程序对外提供的调用接口。 注册过程 Server进程启动之后，通过ioctl函数向Driver发起请求，并指明需要0号位binder引用对应的进程来处理； 驱动收到请求后，通过SM内部的红黑树查询是否注册过binder实体，由于0号位已注册过了，就不需要再创建实体和添加引用了，直接把Binder实体转发给对应的进程，在这里就是SM进程； SM收到请求之后，将Server的binder引用添加到内部的单链表中，完成注册； 通信过程 client通过ioctl函数向Driver发起请求（包含binder名称）； Driver将请求转发给SM； SM在引用单链表中根据名称查询Server的引用； 通过Driver返回Binder的引用； Client收到引用之后，创建一个Server的代理； Client调用代理的接口，通过Driver与真正的Server进行交互。 总结整个通信过程，其实就是创建远程代理与调用远程代理的过程。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#注册过程"},{"categories":null,"content":" Binder的通信过程 ioctl函数是linux系统中驱动程序对外提供的调用接口。 注册过程 Server进程启动之后，通过ioctl函数向Driver发起请求，并指明需要0号位binder引用对应的进程来处理； 驱动收到请求后，通过SM内部的红黑树查询是否注册过binder实体，由于0号位已注册过了，就不需要再创建实体和添加引用了，直接把Binder实体转发给对应的进程，在这里就是SM进程； SM收到请求之后，将Server的binder引用添加到内部的单链表中，完成注册； 通信过程 client通过ioctl函数向Driver发起请求（包含binder名称）； Driver将请求转发给SM； SM在引用单链表中根据名称查询Server的引用； 通过Driver返回Binder的引用； Client收到引用之后，创建一个Server的代理； Client调用代理的接口，通过Driver与真正的Server进行交互。 总结整个通信过程，其实就是创建远程代理与调用远程代理的过程。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#通信过程"},{"categories":null,"content":" Binder的通信过程 ioctl函数是linux系统中驱动程序对外提供的调用接口。 注册过程 Server进程启动之后，通过ioctl函数向Driver发起请求，并指明需要0号位binder引用对应的进程来处理； 驱动收到请求后，通过SM内部的红黑树查询是否注册过binder实体，由于0号位已注册过了，就不需要再创建实体和添加引用了，直接把Binder实体转发给对应的进程，在这里就是SM进程； SM收到请求之后，将Server的binder引用添加到内部的单链表中，完成注册； 通信过程 client通过ioctl函数向Driver发起请求（包含binder名称）； Driver将请求转发给SM； SM在引用单链表中根据名称查询Server的引用； 通过Driver返回Binder的引用； Client收到引用之后，创建一个Server的代理； Client调用代理的接口，通过Driver与真正的Server进行交互。 总结整个通信过程，其实就是创建远程代理与调用远程代理的过程。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:5:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#总结"},{"categories":null,"content":" AIDL","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#aidl"},{"categories":null,"content":" 定义AIDL的全称是：Android接口定义语言(即 Android Interface Definition Language)，他定义的只不过是一套模板，实际起作用的是AS通过解释这个模板自动生成的android.os.IInterface的子类接口。作用是依靠Service中转，通过Binder机制来做IPC。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:1","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#定义"},{"categories":null,"content":" 数据类型AIDL支持的数据类型： byte char short int long float double boolean Parcelable List Map ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:2","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#数据类型"},{"categories":null,"content":" 定向Tag interface BookController { List\u003cBook\u003e getBookList(); void addBookInOut(inout Book book); void addBookIn(in Book book); void addBookOut(out Book book); } in 数据只能由客户端流向服务端 out 数据只能由服务端流向客户端 inout 数据可在服务端与客户端之间双向流通 如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。 引自https://www.jianshu.com/p/29999c1a93cd ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:3","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#定向tag"},{"categories":null,"content":" 源码 //包名与项目包名一致 package com.vee.aidltest; /** * 自动生成的接口 **/ public interface IMyAidlInterface extends android.os.IInterface{ /** * 我们自己声明的业务函数 **/ public java.lang.String getName() throws android.os.RemoteException; /** * 本接口的默认实现，其中业务方法`getName`返回null; **/ public static class Default implements com.vee.aidltest.IMyAidlInterface{ ... } /** * 静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口 **/ public static abstract class Stub extends android.os.Binder implements com.vee.aidltest.IMyAidlInterface{ /** * 用来标记当前Binder，所以采用全类名表示 **/ private static final java.lang.String DESCRIPTOR = \"com.vee.aidltest.IMyAidlInterface\"; /** * 构造方法中调用对象方法。 **/ public Stub(){ this.attachInterface(this, DESCRIPTOR); } /** * 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 */ public static com.vee.aidltest.IMyAidlInterface asInterface(android.os.IBinder obj){ if ((obj==null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)\u0026\u0026(iin instanceof com.vee.aidltest.IMyAidlInterface))) { return ((com.vee.aidltest.IMyAidlInterface)iin); } return new com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj); } /** * 返回当前Binder对象 **/ @Override public android.os.IBinder asBinder(){ return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException{ java.lang.String descriptor = DESCRIPTOR; switch (code){ case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getName: { data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); java.lang.String _result = this.getName(_arg0); reply.writeNoException(); reply.writeString(_result); return true; } default: { return super.onTransact(code, data, reply, flags); } } } /** * 自动生成的静态代理，在客户端回调 **/ private static class Proxy implements com.vee.aidltest.IMyAidlInterface{ private android.os.IBinder mRemote; Proxy(android.os.IBinder remote){ mRemote = remote; } @Override public android.os.IBinder asBinder(){ return mRemote; } public java.lang.String getInterfaceDescriptor(){ return DESCRIPTOR; } @Override public java.lang.String getName() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); if (!_status \u0026\u0026 getDefaultImpl() != null) { return getDefaultImpl().getName(); } _reply.readException(); _result = _reply.readString(); } finally { _reply.recycle(); _data.recycle(); } return _result; } public static com.vee.aidltest.IMyAidlInterface sDefaultImpl; } /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); /** * 当处于客户端时调用，这里就是生成代理 **/ public static boolean setDefaultImpl(com.vee.aidltest.IMyAidlInterface impl) { if (Stub.Proxy.sDefaultImpl != null) { throw new IllegalStateException(\"setDefaultImpl() called twice\"); } if (impl != null) { Stub.Proxy.sDefaultImpl = impl; return true; } return false; } /** * 当处于客户端时用来获取代理对象 **/ public static com.vee.aidltest.IMyAidlInterface getDefaultImpl() { return Stub.Proxy.sDefaultImpl; } } DESCRIPTORBinder的唯一标识，一般用当前Binder的类名表示，比如本例中的com.ryg.chapter_2.aidl.IBookManager。 asInterface(android.os.IBinder obj)用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBinder此方法用于返回当前Binder对象。 onTransact:重要这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗： /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); 接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。 然后执行目标方法。","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#源码"},{"categories":null,"content":" 源码 //包名与项目包名一致 package com.vee.aidltest; /** * 自动生成的接口 **/ public interface IMyAidlInterface extends android.os.IInterface{ /** * 我们自己声明的业务函数 **/ public java.lang.String getName() throws android.os.RemoteException; /** * 本接口的默认实现，其中业务方法`getName`返回null; **/ public static class Default implements com.vee.aidltest.IMyAidlInterface{ ... } /** * 静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口 **/ public static abstract class Stub extends android.os.Binder implements com.vee.aidltest.IMyAidlInterface{ /** * 用来标记当前Binder，所以采用全类名表示 **/ private static final java.lang.String DESCRIPTOR = \"com.vee.aidltest.IMyAidlInterface\"; /** * 构造方法中调用对象方法。 **/ public Stub(){ this.attachInterface(this, DESCRIPTOR); } /** * 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 */ public static com.vee.aidltest.IMyAidlInterface asInterface(android.os.IBinder obj){ if ((obj==null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)\u0026\u0026(iin instanceof com.vee.aidltest.IMyAidlInterface))) { return ((com.vee.aidltest.IMyAidlInterface)iin); } return new com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj); } /** * 返回当前Binder对象 **/ @Override public android.os.IBinder asBinder(){ return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException{ java.lang.String descriptor = DESCRIPTOR; switch (code){ case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getName: { data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); java.lang.String _result = this.getName(_arg0); reply.writeNoException(); reply.writeString(_result); return true; } default: { return super.onTransact(code, data, reply, flags); } } } /** * 自动生成的静态代理，在客户端回调 **/ private static class Proxy implements com.vee.aidltest.IMyAidlInterface{ private android.os.IBinder mRemote; Proxy(android.os.IBinder remote){ mRemote = remote; } @Override public android.os.IBinder asBinder(){ return mRemote; } public java.lang.String getInterfaceDescriptor(){ return DESCRIPTOR; } @Override public java.lang.String getName() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); if (!_status \u0026\u0026 getDefaultImpl() != null) { return getDefaultImpl().getName(); } _reply.readException(); _result = _reply.readString(); } finally { _reply.recycle(); _data.recycle(); } return _result; } public static com.vee.aidltest.IMyAidlInterface sDefaultImpl; } /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); /** * 当处于客户端时调用，这里就是生成代理 **/ public static boolean setDefaultImpl(com.vee.aidltest.IMyAidlInterface impl) { if (Stub.Proxy.sDefaultImpl != null) { throw new IllegalStateException(\"setDefaultImpl() called twice\"); } if (impl != null) { Stub.Proxy.sDefaultImpl = impl; return true; } return false; } /** * 当处于客户端时用来获取代理对象 **/ public static com.vee.aidltest.IMyAidlInterface getDefaultImpl() { return Stub.Proxy.sDefaultImpl; } } DESCRIPTORBinder的唯一标识，一般用当前Binder的类名表示，比如本例中的com.ryg.chapter_2.aidl.IBookManager。 asInterface(android.os.IBinder obj)用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBinder此方法用于返回当前Binder对象。 onTransact:重要这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗： /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); 接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。 然后执行目标方法。","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#descriptor"},{"categories":null,"content":" 源码 //包名与项目包名一致 package com.vee.aidltest; /** * 自动生成的接口 **/ public interface IMyAidlInterface extends android.os.IInterface{ /** * 我们自己声明的业务函数 **/ public java.lang.String getName() throws android.os.RemoteException; /** * 本接口的默认实现，其中业务方法`getName`返回null; **/ public static class Default implements com.vee.aidltest.IMyAidlInterface{ ... } /** * 静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口 **/ public static abstract class Stub extends android.os.Binder implements com.vee.aidltest.IMyAidlInterface{ /** * 用来标记当前Binder，所以采用全类名表示 **/ private static final java.lang.String DESCRIPTOR = \"com.vee.aidltest.IMyAidlInterface\"; /** * 构造方法中调用对象方法。 **/ public Stub(){ this.attachInterface(this, DESCRIPTOR); } /** * 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 */ public static com.vee.aidltest.IMyAidlInterface asInterface(android.os.IBinder obj){ if ((obj==null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)\u0026\u0026(iin instanceof com.vee.aidltest.IMyAidlInterface))) { return ((com.vee.aidltest.IMyAidlInterface)iin); } return new com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj); } /** * 返回当前Binder对象 **/ @Override public android.os.IBinder asBinder(){ return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException{ java.lang.String descriptor = DESCRIPTOR; switch (code){ case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getName: { data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); java.lang.String _result = this.getName(_arg0); reply.writeNoException(); reply.writeString(_result); return true; } default: { return super.onTransact(code, data, reply, flags); } } } /** * 自动生成的静态代理，在客户端回调 **/ private static class Proxy implements com.vee.aidltest.IMyAidlInterface{ private android.os.IBinder mRemote; Proxy(android.os.IBinder remote){ mRemote = remote; } @Override public android.os.IBinder asBinder(){ return mRemote; } public java.lang.String getInterfaceDescriptor(){ return DESCRIPTOR; } @Override public java.lang.String getName() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); if (!_status \u0026\u0026 getDefaultImpl() != null) { return getDefaultImpl().getName(); } _reply.readException(); _result = _reply.readString(); } finally { _reply.recycle(); _data.recycle(); } return _result; } public static com.vee.aidltest.IMyAidlInterface sDefaultImpl; } /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); /** * 当处于客户端时调用，这里就是生成代理 **/ public static boolean setDefaultImpl(com.vee.aidltest.IMyAidlInterface impl) { if (Stub.Proxy.sDefaultImpl != null) { throw new IllegalStateException(\"setDefaultImpl() called twice\"); } if (impl != null) { Stub.Proxy.sDefaultImpl = impl; return true; } return false; } /** * 当处于客户端时用来获取代理对象 **/ public static com.vee.aidltest.IMyAidlInterface getDefaultImpl() { return Stub.Proxy.sDefaultImpl; } } DESCRIPTORBinder的唯一标识，一般用当前Binder的类名表示，比如本例中的com.ryg.chapter_2.aidl.IBookManager。 asInterface(android.os.IBinder obj)用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBinder此方法用于返回当前Binder对象。 onTransact:重要这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗： /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); 接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。 然后执行目标方法。","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#asinterfaceandroidosibinder-obj"},{"categories":null,"content":" 源码 //包名与项目包名一致 package com.vee.aidltest; /** * 自动生成的接口 **/ public interface IMyAidlInterface extends android.os.IInterface{ /** * 我们自己声明的业务函数 **/ public java.lang.String getName() throws android.os.RemoteException; /** * 本接口的默认实现，其中业务方法`getName`返回null; **/ public static class Default implements com.vee.aidltest.IMyAidlInterface{ ... } /** * 静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口 **/ public static abstract class Stub extends android.os.Binder implements com.vee.aidltest.IMyAidlInterface{ /** * 用来标记当前Binder，所以采用全类名表示 **/ private static final java.lang.String DESCRIPTOR = \"com.vee.aidltest.IMyAidlInterface\"; /** * 构造方法中调用对象方法。 **/ public Stub(){ this.attachInterface(this, DESCRIPTOR); } /** * 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 */ public static com.vee.aidltest.IMyAidlInterface asInterface(android.os.IBinder obj){ if ((obj==null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)\u0026\u0026(iin instanceof com.vee.aidltest.IMyAidlInterface))) { return ((com.vee.aidltest.IMyAidlInterface)iin); } return new com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj); } /** * 返回当前Binder对象 **/ @Override public android.os.IBinder asBinder(){ return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException{ java.lang.String descriptor = DESCRIPTOR; switch (code){ case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getName: { data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); java.lang.String _result = this.getName(_arg0); reply.writeNoException(); reply.writeString(_result); return true; } default: { return super.onTransact(code, data, reply, flags); } } } /** * 自动生成的静态代理，在客户端回调 **/ private static class Proxy implements com.vee.aidltest.IMyAidlInterface{ private android.os.IBinder mRemote; Proxy(android.os.IBinder remote){ mRemote = remote; } @Override public android.os.IBinder asBinder(){ return mRemote; } public java.lang.String getInterfaceDescriptor(){ return DESCRIPTOR; } @Override public java.lang.String getName() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); if (!_status \u0026\u0026 getDefaultImpl() != null) { return getDefaultImpl().getName(); } _reply.readException(); _result = _reply.readString(); } finally { _reply.recycle(); _data.recycle(); } return _result; } public static com.vee.aidltest.IMyAidlInterface sDefaultImpl; } /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); /** * 当处于客户端时调用，这里就是生成代理 **/ public static boolean setDefaultImpl(com.vee.aidltest.IMyAidlInterface impl) { if (Stub.Proxy.sDefaultImpl != null) { throw new IllegalStateException(\"setDefaultImpl() called twice\"); } if (impl != null) { Stub.Proxy.sDefaultImpl = impl; return true; } return false; } /** * 当处于客户端时用来获取代理对象 **/ public static com.vee.aidltest.IMyAidlInterface getDefaultImpl() { return Stub.Proxy.sDefaultImpl; } } DESCRIPTORBinder的唯一标识，一般用当前Binder的类名表示，比如本例中的com.ryg.chapter_2.aidl.IBookManager。 asInterface(android.os.IBinder obj)用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBinder此方法用于返回当前Binder对象。 onTransact:重要这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗： /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); 接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。 然后执行目标方法。","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#asbinder"},{"categories":null,"content":" 源码 //包名与项目包名一致 package com.vee.aidltest; /** * 自动生成的接口 **/ public interface IMyAidlInterface extends android.os.IInterface{ /** * 我们自己声明的业务函数 **/ public java.lang.String getName() throws android.os.RemoteException; /** * 本接口的默认实现，其中业务方法`getName`返回null; **/ public static class Default implements com.vee.aidltest.IMyAidlInterface{ ... } /** * 静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口 **/ public static abstract class Stub extends android.os.Binder implements com.vee.aidltest.IMyAidlInterface{ /** * 用来标记当前Binder，所以采用全类名表示 **/ private static final java.lang.String DESCRIPTOR = \"com.vee.aidltest.IMyAidlInterface\"; /** * 构造方法中调用对象方法。 **/ public Stub(){ this.attachInterface(this, DESCRIPTOR); } /** * 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 */ public static com.vee.aidltest.IMyAidlInterface asInterface(android.os.IBinder obj){ if ((obj==null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)\u0026\u0026(iin instanceof com.vee.aidltest.IMyAidlInterface))) { return ((com.vee.aidltest.IMyAidlInterface)iin); } return new com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj); } /** * 返回当前Binder对象 **/ @Override public android.os.IBinder asBinder(){ return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException{ java.lang.String descriptor = DESCRIPTOR; switch (code){ case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getName: { data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); java.lang.String _result = this.getName(_arg0); reply.writeNoException(); reply.writeString(_result); return true; } default: { return super.onTransact(code, data, reply, flags); } } } /** * 自动生成的静态代理，在客户端回调 **/ private static class Proxy implements com.vee.aidltest.IMyAidlInterface{ private android.os.IBinder mRemote; Proxy(android.os.IBinder remote){ mRemote = remote; } @Override public android.os.IBinder asBinder(){ return mRemote; } public java.lang.String getInterfaceDescriptor(){ return DESCRIPTOR; } @Override public java.lang.String getName() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); if (!_status \u0026\u0026 getDefaultImpl() != null) { return getDefaultImpl().getName(); } _reply.readException(); _result = _reply.readString(); } finally { _reply.recycle(); _data.recycle(); } return _result; } public static com.vee.aidltest.IMyAidlInterface sDefaultImpl; } /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); /** * 当处于客户端时调用，这里就是生成代理 **/ public static boolean setDefaultImpl(com.vee.aidltest.IMyAidlInterface impl) { if (Stub.Proxy.sDefaultImpl != null) { throw new IllegalStateException(\"setDefaultImpl() called twice\"); } if (impl != null) { Stub.Proxy.sDefaultImpl = impl; return true; } return false; } /** * 当处于客户端时用来获取代理对象 **/ public static com.vee.aidltest.IMyAidlInterface getDefaultImpl() { return Stub.Proxy.sDefaultImpl; } } DESCRIPTORBinder的唯一标识，一般用当前Binder的类名表示，比如本例中的com.ryg.chapter_2.aidl.IBookManager。 asInterface(android.os.IBinder obj)用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBinder此方法用于返回当前Binder对象。 onTransact:重要这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗： /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); 接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。 然后执行目标方法。","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#ontransact重要"},{"categories":null,"content":" 源码 //包名与项目包名一致 package com.vee.aidltest; /** * 自动生成的接口 **/ public interface IMyAidlInterface extends android.os.IInterface{ /** * 我们自己声明的业务函数 **/ public java.lang.String getName() throws android.os.RemoteException; /** * 本接口的默认实现，其中业务方法`getName`返回null; **/ public static class Default implements com.vee.aidltest.IMyAidlInterface{ ... } /** * 静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口 **/ public static abstract class Stub extends android.os.Binder implements com.vee.aidltest.IMyAidlInterface{ /** * 用来标记当前Binder，所以采用全类名表示 **/ private static final java.lang.String DESCRIPTOR = \"com.vee.aidltest.IMyAidlInterface\"; /** * 构造方法中调用对象方法。 **/ public Stub(){ this.attachInterface(this, DESCRIPTOR); } /** * 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 */ public static com.vee.aidltest.IMyAidlInterface asInterface(android.os.IBinder obj){ if ((obj==null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)\u0026\u0026(iin instanceof com.vee.aidltest.IMyAidlInterface))) { return ((com.vee.aidltest.IMyAidlInterface)iin); } return new com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj); } /** * 返回当前Binder对象 **/ @Override public android.os.IBinder asBinder(){ return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException{ java.lang.String descriptor = DESCRIPTOR; switch (code){ case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getName: { data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); java.lang.String _result = this.getName(_arg0); reply.writeNoException(); reply.writeString(_result); return true; } default: { return super.onTransact(code, data, reply, flags); } } } /** * 自动生成的静态代理，在客户端回调 **/ private static class Proxy implements com.vee.aidltest.IMyAidlInterface{ private android.os.IBinder mRemote; Proxy(android.os.IBinder remote){ mRemote = remote; } @Override public android.os.IBinder asBinder(){ return mRemote; } public java.lang.String getInterfaceDescriptor(){ return DESCRIPTOR; } @Override public java.lang.String getName() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); if (!_status \u0026\u0026 getDefaultImpl() != null) { return getDefaultImpl().getName(); } _reply.readException(); _result = _reply.readString(); } finally { _reply.recycle(); _data.recycle(); } return _result; } public static com.vee.aidltest.IMyAidlInterface sDefaultImpl; } /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); /** * 当处于客户端时调用，这里就是生成代理 **/ public static boolean setDefaultImpl(com.vee.aidltest.IMyAidlInterface impl) { if (Stub.Proxy.sDefaultImpl != null) { throw new IllegalStateException(\"setDefaultImpl() called twice\"); } if (impl != null) { Stub.Proxy.sDefaultImpl = impl; return true; } return false; } /** * 当处于客户端时用来获取代理对象 **/ public static com.vee.aidltest.IMyAidlInterface getDefaultImpl() { return Stub.Proxy.sDefaultImpl; } } DESCRIPTORBinder的唯一标识，一般用当前Binder的类名表示，比如本例中的com.ryg.chapter_2.aidl.IBookManager。 asInterface(android.os.IBinder obj)用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 asBinder此方法用于返回当前Binder对象。 onTransact:重要这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗： /** * 用来标记我们自己定义的方法，前缀确定 **/ static final int TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + 0); 接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。 然后执行目标方法。","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:6:4","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#proxygetname"},{"categories":null,"content":" 提取一下重点两个端： server client 两个标记： DESCRIPTOR：当前Binder的唯一标志 TRANSACTION_getName：方法的唯一标志 两个类型： abstract class Stub extends android.os.Binder implements IMyAidlInterface static class Proxy implements IMyAidlInterface 5个方法： asInterface asBinder 业务方法 transact onTransact ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:7:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#提取一下重点"},{"categories":null,"content":" 梳理流程 服务端向ServiceManager注册Binder。 客户端(通过bindService()回调)拿到Binder，调用Stub.asInterface(binderObj)。在这个方法中通过DESCRIPTOR标志在ServiceManager中去找Binder，如果找到直接返回，找不到就创建这个binder的Proxy对象。Proxy对象中包含被代理的业务方法。 客户端调用Proxy中代理的业务方法，此时创建两个Parcel：_data和_reply。然后调用代理中的binder的transact()方法，传入TRANSACTION_getName方法标记、_data、_reply，这样就执行了服务端binder中的业务逻辑方法，此时线程挂起。 客户端调用服务端的transact()方法会回调服务端的onTransact()方法。在这个方法中会根据TRANSACTION_getName判断应该调用哪个业务逻辑方法，然后挂起线程，执行对应的业务逻辑方法，最后在reply中写入异常或结果。 客户端继续执行transact()方法，从_reply中读取异常或返回值，再继续线程，最后回收_data和_reply并返回_reply中读到的结果。 ","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:8:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#梳理流程"},{"categories":null,"content":" Binder连接池","date":"2021-03-12","objectID":"/binder%E8%A7%A3%E6%9E%90/:9:0","series":null,"tags":["Android","binder"],"title":"Binder解析","uri":"/binder%E8%A7%A3%E6%9E%90/#binder连接池"},{"categories":null,"content":" 初始化 Looper.prepare(); Handler mHandler = new Handler(Looper.myLooper()); Looper.loop(); Looper.prepare()源码： private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } Looper的构造方法： private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 初始化阶段主要做了四件事： 依赖ThreadLocal给当前线程创建Looper的独立对象； 在Looper构造方法中创建MessageQueue； 创建Handler对象; 启动循环获取消息。 ","date":"2021-03-09","objectID":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/:1:0","series":null,"tags":["Android","handler","Message","Looper"],"title":"Android中Message的一辈子","uri":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/#初始化"},{"categories":null,"content":" 创建消息 //方式1: Message.obtain(); //方式2： mHandler.obtainMessage(); ","date":"2021-03-09","objectID":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/:2:0","series":null,"tags":["Android","handler","Message","Looper"],"title":"Android中Message的一辈子","uri":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/#创建消息"},{"categories":null,"content":" 发送 //方式1: mHandler.sendMessage(msg); //方式2: msg.sendToTarget(); 最终调用MessageQueue.enqueueMessage(Message msg, long when)。 所谓的发送消息，其实是干了3件事： 把消息的状态改为inUse； 重组MessageQueue中的mMessages链条，把新消息放在队首； 唤醒Looper所在线程，开始循环处理消息。 ","date":"2021-03-09","objectID":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/:3:0","series":null,"tags":["Android","handler","Message","Looper"],"title":"Android中Message的一辈子","uri":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/#发送"},{"categories":null,"content":" 接收Looper的looper方法中循环调用MessageQueue的next方法读取新的message，如果有新消息，就调用handler的dispatchMessage(msg)，进而调用handleCallback()或者调用handleMessage方法。最后通过msg的msg.recycleUnchecked();完成消息的回收复用。 而此时，如果没有消息，或者下一个消息是延迟消息且还没到时间，looper会回调所有的idleHandler，然后通过linux的epoll机制进入休眠，降低cpu负载，直到调用Looper对象的quitSafely()，进一步调MessageQueue的quit()方法，更改mQuitting标记，使MessageQueue的next方法返回null，跳出Lopper的loop循环，释放了线程。 明天补一张生命周期时序图吧，今天先到这了 ","date":"2021-03-09","objectID":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/:4:0","series":null,"tags":["Android","handler","Message","Looper"],"title":"Android中Message的一辈子","uri":"/android%E4%B8%ADmessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/#接收"},{"categories":null,"content":" 回顾handler发送消息： private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);//最后调用的是queue.enqueueMessage } Looper循环读取消息并发送给Handler: for (;;) { Message msg = queue.next(); // 从MessageQueue中取出Message try { msg.target.dispatchMessage(msg);//调用Handler的dispatchMessage } catch (Exception exception) { //... } finally { //... } //回收消息 msg.recycleUnchecked(); } ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:1","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#回顾"},{"categories":null,"content":" enqueueMessage Message mMessages; boolean enqueueMessage(Message msg, long when) { synchronized (this) { if (msg.isInUse()) {//发送的消息必须是闲置状态的 throw new IllegalStateException(msg + \" This message is already in use.\"); } if (mQuitting) { //mQuitting是一个状态，只有MessageQueue的quit方法调用时才这个状态才会为true msg.recycle();//回收 return false; } msg.markInUse(); //改状态为使用中 msg.when = when;//注意这里赋值 Message p = mMessages; boolean needWake; //重点是时间的比较，如果新的msg的时间早于当前的message，那么就把新的msg放在头部。 if (p == null || when == 0 || when \u003c p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { needWake = mBlocked \u0026\u0026 p.target == null \u0026\u0026 msg.isAsynchronous();//如果是异步消息 Message prev; for (;;) {//又一个死循环，用来向下遍历队列， prev = p;//把当前的msg设为前一个msg p = p.next;//当前的msg指向下一个msg if (p == null || when \u003c p.when) {//如果我们设置时间的早于msg的时间，那么就停止遍历 break; } if (needWake \u0026\u0026 p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } if (needWake) { nativeWake(mPtr);//唤醒线程处理消息 } } return true; } 简而言之，enqueueMessage的作用是采用synchronized同步阻塞的方式操作Message链条，依据Message的延迟时间，打断链条重新排序，同时修改msg的状态，利用共享内存（mMessages）达到线程间通信的目的。 那么所谓的Handler.sendMessage(msg)是真的发送消息吗？并不是！它只是修改了Looper中持有的MessageQueue中的mMessages的链条顺序，然后等待Looper不断循环获取，再传递回mHandler.dispatchMessage(msg)而已。但这一改加一取，就能达到线程间通信的效果，并让我一直误以为是真的通过序列化之后发送出去，而这种方式叫做共享内存。 不看不知道，一看好鸡贼！ ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:2","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#enqueuemessage"},{"categories":null,"content":" next方法 @UnsupportedAppUsage Message next() { //当loop执行了quit后，程序可能会重启looper，就会返回到这里。 final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; //只有在第一次遍历时是-1 int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { //用来在线程要进入阻塞之前跟内核线程发送消息，防止用户线程长时间的持有某个对象 Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis);//告诉linux的epoll：你丫可以睡nextPollTimeoutMillis这么长时间了！直到handler发送消息调用`mQueue.enqueueMessage()`方法时会被唤醒，或者当前消息到时间时也会被唤醒。 synchronized (this) { // 尝试检索下一个msg，找到就返回 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null \u0026\u0026 msg.target == null) { //靠栅栏停滞，找到下一个非异步msg do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026\u0026 !msg.isAsynchronous()); } if (msg != null) { if (now \u003c msg.when) { //下一个消息还没到时间。设置一个唤醒时段 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // 获取一条消息 mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else {//如果不是异步消息，prevMsg就是null mMessages = msg.next;//往上提一位 } msg.next = null;//打断链条单独取出 if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse();//改变状态为使用中 return msg;//返回 } } else { //如果当前没有消息，把唤醒时钟设为-1，那么意味着线程会沉睡Integer.MaxValue nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } ///接下来就是喜闻乐见的idleHandler了 if (pendingIdleHandlerCount \u003c 0 \u0026\u0026 (mMessages == null || now \u003c mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size();//如果没有添加过idleHandler，那么就是0 } if (pendingIdleHandlerCount \u003c= 0) { //如果没有idleHandler需要执行，那就继续loop mBlocked = true; continue; } //初始化一个固定长度的数组 if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // 遍历执行所有的idleHandler. //只有在第一次循环时才会执行到这个代码块 for (int i = 0; i \u003c pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // 强行释放数组中的idleHandler，不会影响ArrayList中的idleHandler和当前正在使用的idleHandler。 boolean keep = false; try { keep = idler.queueIdle();//回调queueIdle方法 } catch (Throwable t) { Log.wtf(TAG, \"IdleHandler threw exception\", t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } //重置计数 pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; } } ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:3","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#next方法"},{"categories":null,"content":" IdleHandler /** * Callback interface for discovering when a thread is going to block * waiting for more messages. * 当线程将要锁定（等待更多消息）时就会回调queueIdle方法 */ public static interface IdleHandler { /** * 当MessqgeQueue已经处理完所有的message，并且将要进入睡眠和等待时这个方法才会被调用。 * 返回true可以使IdleHandler保持激活状态，那么当下次线程空闲了还会调用，返回false就会移除IdleHandler。 */ boolean queueIdle(); } 原来这玩意根本不是什么Handler的子类，而是MessageQueue的一个内部静态类而已！ 然后我就不太明白这个玩意了，去百了个度，拿到答案如下： 之前做过冷启动优化，在冷启动的场景有很多的任务其实并不需要马上启动，通常的做法就是做一个延迟启动，如下所示 Handler mHandler = new Handler(); mHandler.postDelayed(() -\u003e { //do something }, 1000); 将任务延迟启动1000ms，但是这个延迟启动的时间不好确定，只能是自己预估的，对于一些高端手机1000ms可能多了，一些低端手机可能1000ms还不够。这个时候IdelHandler就可以解决这个问题，它能够在CPU空闲的时候再执行指定的任务。 使用方法也很简单，如下所示，调用addIdleHandler方法就可以了: MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() { @Override public boolean queueIdle() { //do something return false; } }; Looper.getMainLooper().getQueue().addIdleHandler(idleHandler); 引自这里 我惊叹啊，还能这么玩啊～～想到以前面试官问过我怎么做延迟启动，我回答ContentProvider和StartUp，我觉得是没错的，但是她想要的应该就是这个IdleHandler。 public void addIdleHandler(@NonNull IdleHandler handler) { if (handler == null) { throw new NullPointerException(\"Can't add a null IdleHandler\"); } synchronized (this) { mIdleHandlers.add(handler); } } 添加时有非空判断和线程安全。 然后具体的操作也是在MessqgeQueue的next方法中进行的。那么IdleHandler怎么判断线程是否空闲呢？看next方法中这一部分： //条件1:没有msg或msg还没到执行的时候 if (msg != null) { if (now \u003c msg.when) { //msg时间晚于当前时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } //条件2:looper没有停止 if (mQuitting) { dispose(); return null; } //条件3:不存在IdleHandler的话就重新遍历 if (pendingIdleHandlerCount \u003c= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } 所以判断线程是否将进入空闲，也就是IdleHandler的执行时机，是依据： MessageQueue中没有消息或当前消息不必马上执行； Looper没有释放； 队列中存在IdleHandler。 ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:4","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#idlehandler"},{"categories":null,"content":" 同步屏障与异步消息前面经常提到异步消息，对于异步消息的处理如下： 在enqueueMessage方法中判断是异步消息的话，会让cpu保持唤醒状态； 在next方法中，依靠同步屏障来优先查找异步消息返回处理。 检索并使用同步屏障MessageQueue的next()方法： if (msg != null \u0026\u0026 msg.target == null) { // 如果target为空，则判定为遇到了栅栏，此时便利后面的所有消息，找到异步消息优先处理 do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026\u0026 !msg.isAsynchronous()); } 插入同步屏障 @UnsupportedAppUsage @TestApi public int postSyncBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); } private int postSyncBarrier(long when) { synchronized (this) { // 缓存token final int token = mNextBarrierToken++; // 创建一个无target的消息 final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; 插入到指定时间 if (when != 0) { while (p != null \u0026\u0026 p.when \u003c= when) { prev = p; p = p.next; } } if (prev != null) { // invariant: p == prev.next msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } } 总结 MessageQueue是一个由单链表实现的优先级队列； 屏障消息和普通消息区别在于屏幕没有target，普通消息有target是因为它需要将消息分发给对应的target，而屏障不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的； 屏障和普通消息一样可以根据时间来插入到消息队列中的适当位置，并且只会挡住它后面的同步消息的分发； postSyncBarrier会返回一个token，利用这个token可以撤销屏障； postSyncBarrier是hide的，使用它得用反射； 插入普通消息会唤醒消息队列，但插入屏障不会。 ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:5","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#同步屏障与异步消息"},{"categories":null,"content":" 同步屏障与异步消息前面经常提到异步消息，对于异步消息的处理如下： 在enqueueMessage方法中判断是异步消息的话，会让cpu保持唤醒状态； 在next方法中，依靠同步屏障来优先查找异步消息返回处理。 检索并使用同步屏障MessageQueue的next()方法： if (msg != null \u0026\u0026 msg.target == null) { // 如果target为空，则判定为遇到了栅栏，此时便利后面的所有消息，找到异步消息优先处理 do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026\u0026 !msg.isAsynchronous()); } 插入同步屏障 @UnsupportedAppUsage @TestApi public int postSyncBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); } private int postSyncBarrier(long when) { synchronized (this) { // 缓存token final int token = mNextBarrierToken++; // 创建一个无target的消息 final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; 插入到指定时间 if (when != 0) { while (p != null \u0026\u0026 p.when \u003c= when) { prev = p; p = p.next; } } if (prev != null) { // invariant: p == prev.next msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } } 总结 MessageQueue是一个由单链表实现的优先级队列； 屏障消息和普通消息区别在于屏幕没有target，普通消息有target是因为它需要将消息分发给对应的target，而屏障不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的； 屏障和普通消息一样可以根据时间来插入到消息队列中的适当位置，并且只会挡住它后面的同步消息的分发； postSyncBarrier会返回一个token，利用这个token可以撤销屏障； postSyncBarrier是hide的，使用它得用反射； 插入普通消息会唤醒消息队列，但插入屏障不会。 ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:5","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#检索并使用同步屏障"},{"categories":null,"content":" 同步屏障与异步消息前面经常提到异步消息，对于异步消息的处理如下： 在enqueueMessage方法中判断是异步消息的话，会让cpu保持唤醒状态； 在next方法中，依靠同步屏障来优先查找异步消息返回处理。 检索并使用同步屏障MessageQueue的next()方法： if (msg != null \u0026\u0026 msg.target == null) { // 如果target为空，则判定为遇到了栅栏，此时便利后面的所有消息，找到异步消息优先处理 do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026\u0026 !msg.isAsynchronous()); } 插入同步屏障 @UnsupportedAppUsage @TestApi public int postSyncBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); } private int postSyncBarrier(long when) { synchronized (this) { // 缓存token final int token = mNextBarrierToken++; // 创建一个无target的消息 final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; 插入到指定时间 if (when != 0) { while (p != null \u0026\u0026 p.when \u003c= when) { prev = p; p = p.next; } } if (prev != null) { // invariant: p == prev.next msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } } 总结 MessageQueue是一个由单链表实现的优先级队列； 屏障消息和普通消息区别在于屏幕没有target，普通消息有target是因为它需要将消息分发给对应的target，而屏障不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的； 屏障和普通消息一样可以根据时间来插入到消息队列中的适当位置，并且只会挡住它后面的同步消息的分发； postSyncBarrier会返回一个token，利用这个token可以撤销屏障； postSyncBarrier是hide的，使用它得用反射； 插入普通消息会唤醒消息队列，但插入屏障不会。 ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:5","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#插入同步屏障"},{"categories":null,"content":" 同步屏障与异步消息前面经常提到异步消息，对于异步消息的处理如下： 在enqueueMessage方法中判断是异步消息的话，会让cpu保持唤醒状态； 在next方法中，依靠同步屏障来优先查找异步消息返回处理。 检索并使用同步屏障MessageQueue的next()方法： if (msg != null \u0026\u0026 msg.target == null) { // 如果target为空，则判定为遇到了栅栏，此时便利后面的所有消息，找到异步消息优先处理 do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026\u0026 !msg.isAsynchronous()); } 插入同步屏障 @UnsupportedAppUsage @TestApi public int postSyncBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); } private int postSyncBarrier(long when) { synchronized (this) { // 缓存token final int token = mNextBarrierToken++; // 创建一个无target的消息 final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; 插入到指定时间 if (when != 0) { while (p != null \u0026\u0026 p.when \u003c= when) { prev = p; p = p.next; } } if (prev != null) { // invariant: p == prev.next msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } } 总结 MessageQueue是一个由单链表实现的优先级队列； 屏障消息和普通消息区别在于屏幕没有target，普通消息有target是因为它需要将消息分发给对应的target，而屏障不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的； 屏障和普通消息一样可以根据时间来插入到消息队列中的适当位置，并且只会挡住它后面的同步消息的分发； postSyncBarrier会返回一个token，利用这个token可以撤销屏障； postSyncBarrier是hide的，使用它得用反射； 插入普通消息会唤醒消息队列，但插入屏障不会。 ","date":"2021-03-04","objectID":"/messagequeue%E8%A7%A3%E8%AF%BB/:0:5","series":null,"tags":["Android","Handler","Looper","Message","MessageQueue"],"title":"MessageQueue解读","uri":"/messagequeue%E8%A7%A3%E8%AF%BB/#总结"},{"categories":null,"content":" Handler的原理内存共享方案，并且通过加锁避免线程之间的相互干扰。 为何不用wait/notify 答案： 通过阅读main()函数，会发现主线程完全就是基于loop来运行的，所以的Android完全就是在handler+loop+message上面玩的。那么Handler机制最核心的用途是：维持程序的运行！，而消息机制反而是次要用途。 ","date":"2021-03-04","objectID":"/handler%E9%AB%98%E7%BA%A7/:1:0","series":null,"tags":null,"title":"Handler的原理","uri":"/handler%E9%AB%98%E7%BA%A7/#handler的原理"},{"categories":null,"content":" MessageQueue的数据结构由单链表实现的优先级队列。 优先级队列，根据时间优先级的插入排序算法的单链表。 ","date":"2021-03-04","objectID":"/handler%E9%AB%98%E7%BA%A7/:2:0","series":null,"tags":null,"title":"Handler的原理","uri":"/handler%E9%AB%98%E7%BA%A7/#messagequeue的数据结构"},{"categories":null,"content":" ThreadLocalThreadLocal是线程上下文的存储便变量， [] 需要看一下ThreadLocal源码 ","date":"2021-03-04","objectID":"/handler%E9%AB%98%E7%BA%A7/:3:0","series":null,"tags":null,"title":"Handler的原理","uri":"/handler%E9%AB%98%E7%BA%A7/#threadlocal"},{"categories":null,"content":" 面试题 一个线程有几个Handler? 无数个。 一个线程有几个Looper?如何保证？ 1个，ThreadLocal. Handler内存泄露的原因？ 匿名创建时，持有外部Activity的强引用，导致Activity不能GC。 在子线程new Handler(); 需要自己调用Looper.prepary()和Looper.loop()。 子线程中维护的Looper当无消息的时候如何处理？ 需要自己Looper.quit()，否则线程一直运行。 生产者消费者模型中的阻塞机制 使用epoll机制，当msg没到时间时，会epoll睡眠一段时间；当没有msg时，睡眠默认时间（很长）。当调用到enqueueMessage时，会调用nativeWake来唤醒。 消息队列无消息如何处理？ epoll机制睡眠，当enqueueMessage()时通过nativeWake()唤醒。整个过程是阻塞进行的。在子线程中，需要自己调用quit退出。 多个Handler向MessageQueue中添加数据，但是他们处于不同的线程中，怎么确保数据安全？ sysnchronized锁了this，锁的是当前的MessageQueue对象，他的所有的函数和代码块都会受限。 主线程是否允许quit？ 主线程不允许，一旦调用就会抛异常。Zygote会fork自身，给每一个应用创建JVM，然后启动AcitivityThread，在后者执行的main方法中会调用Looper.preparyMainLooper()和Looper.loop()，应用的所有的代码都是在这个loop方法中运行的。 夸线程通信的原理？ 通过共享内存实现。 为什么线程间不会干扰？ 通过锁。 为什么不用wait/notify? 因为Java的wait/notify底层调用c++实现，Android自己实现了一个基于linux的epoll机制，效率更高？ ","date":"2021-03-04","objectID":"/handler%E9%AB%98%E7%BA%A7/:4:0","series":null,"tags":null,"title":"Handler的原理","uri":"/handler%E9%AB%98%E7%BA%A7/#面试题"},{"categories":null,"content":" TODO ThreadLocal原理进一步了解 ","date":"2021-03-04","objectID":"/handler%E9%AB%98%E7%BA%A7/:5:0","series":null,"tags":null,"title":"Handler的原理","uri":"/handler%E9%AB%98%E7%BA%A7/#todo"},{"categories":null,"content":" 构造方法 public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 构造方法中可以看到，handler持有Looper的MessageQueue。 ","date":"2021-03-04","objectID":"/handler%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":null,"title":"Handler解读","uri":"/handler%E8%A7%A3%E8%AF%BB/#构造方法"},{"categories":null,"content":" obtainMessage public final Message obtainMessage(){ return Message.obtain(this); } Handler的obtainMessage()其实还是调用Message.obtain()方法，所以直接调用后者反而效率更高。那么来看一下Message.obtain()干了什么： public static Message obtain(Handler h) { Message m = obtain(); m.target = h; return m; } 没错，就是设置了一个target。 ","date":"2021-03-04","objectID":"/handler%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":null,"title":"Handler解读","uri":"/handler%E8%A7%A3%E8%AF%BB/#obtainmessage"},{"categories":null,"content":" sendMessage public final boolean sendMessage(@NonNull Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { if (delayMillis \u003c 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } /** * 核心在这里 */ private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);//最后调用的是queue.enqueueMessage } sendMessage最后是通过MessageQueue的enqueueMessage实现消息的发送。那么我知道message有个sendToTarget方法，其实也是通过handler去发消息的。 public void sendToTarget() { target.sendMessage(this); } 当消息发出后，就进入了生产者模型中。 ","date":"2021-03-04","objectID":"/handler%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":null,"title":"Handler解读","uri":"/handler%E8%A7%A3%E8%AF%BB/#sendmessage"},{"categories":null,"content":" postpost其实也是基于消息实现的，但与发送消息不同的是，post是先创建个消息，然后把Runnable类型的参数赋值给msg的callback。前面解读Message的时候了解到，callback是在handler接收到消息的时候才执行，它与handler在同一线程。 /** * 把Runnable添加到message中，并且在handler所在线程运行 */ public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } private static Message getPostMessage(Runnable r) { Message m = Message.obtain();//从message回收池中取一个闲置msg m.callback = r;//赋值callback return m; } ","date":"2021-03-04","objectID":"/handler%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":null,"title":"Handler解读","uri":"/handler%E8%A7%A3%E8%AF%BB/#post"},{"categories":null,"content":" postDelayed public final boolean postDelayed(@NonNull Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { if (delayMillis \u003c 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } 一般面试的会考这个方法，我感觉也没啥啊，无非就是个SystemClock.uptimeMillis()加上设定的延迟时间。 SystemClock.uptimeMillis()是从系统启动后开始累计的时间，并且在系统进入深度睡眠的时候暂停累计。 ","date":"2021-03-04","objectID":"/handler%E8%A7%A3%E8%AF%BB/:5:0","series":null,"tags":null,"title":"Handler解读","uri":"/handler%E8%A7%A3%E8%AF%BB/#postdelayed"},{"categories":null,"content":" 接收消息前面在Looper解读里了解到，Looper在loop方法中死循环读取message，然后通过msg.target.dispatchMessage(msg);方法发送消息： /** * Handle system messages here. */ public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 这里就可以看到，如果msg的callback不为空，那么就处理callback,反之则处理msg。这就是为什么给msg添加了callback之后，Handler的handleMessage不会再回调的原因。 handleCallback: private static void handleCallback(Message message) { message.callback.run(); } 直接在当前线程去跑Runnable类型的callback。 ","date":"2021-03-04","objectID":"/handler%E8%A7%A3%E8%AF%BB/:6:0","series":null,"tags":null,"title":"Handler解读","uri":"/handler%E8%A7%A3%E8%AF%BB/#接收消息"},{"categories":null,"content":" 创建我们都知道创建Message的时候有两种方式： 构造方法创建（不推荐）。 Message.obtain();（推荐）. 为了防止OOM，我们一般都是直接用第二种方式，直接从回收池里面拿闲置。那么这个闲置的Message是从哪创建的呢？为什么我们不用先new一个Message，回收池里面就有呢？ public static final Object sPoolSync = new Object(); /** * 池子 * / private static Message sPool; private static int sPoolSize = 0; private static final int MAX_POOL_SIZE = 50; @UnsupportedAppUsage /*package*/ Message next; public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null;//打断了链条 m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message(); } 由上面代码可以看出，obtain()方法检查池子为null,就会自动new一个message出来。而如果不为空，则抽取出来清一下状态返回，并把原来的next前置给sPool，最后把size自减1。 这里的sPoll比较有意思，叫池子，但其实是个单向链，我觉得叫队列更合适。但是看到后面会发现还是应该叫池子。 所以，Message的实质是单向链+Size整数，最多不能超过50个！ ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:1","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#创建"},{"categories":null,"content":" 回收复用指定的Message /** * Same as {@link #obtain()}, but copies the values of an existing * message (including its target) into the new one. * @param orig Original message to copy. * @return A Message object from the global pool. */ public static Message obtain(Message orig) { Message m = obtain(); m.what = orig.what; m.arg1 = orig.arg1; m.arg2 = orig.arg2; m.obj = orig.obj; m.replyTo = orig.replyTo; m.sendingUid = orig.sendingUid; m.workSourceUid = orig.workSourceUid; if (orig.data != null) { m.data = new Bundle(orig.data); } m.target = orig.target; m.callback = orig.callback; return m; } 如果需要回收并且复用指定的Message，那么就把该message传递到obtain方法中。在方法内部，其实是通过copy值给回收的message来完成。 ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:2","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#回收复用指定的message"},{"categories":null,"content":" targetobtain方法可以传递一个Handler对象。 /** * Same as {@link #obtain()}, but sets the value for the \u003cem\u003etarget\u003c/em\u003e member on the Message returned. * @param h Handler to assign to the returned Message object's \u003cem\u003etarget\u003c/em\u003e member. * @return A Message object from the global pool. */ public static Message obtain(Handler h) { Message m = obtain(); m.target = h; return m; } 如果指定了对象，就可以通过sendToTarget()方法直接发送Message了。 ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:3","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#target"},{"categories":null,"content":" callback /** * Same as {@link #obtain(Handler)}, but assigns a callback Runnable on * the Message that is returned. * @param h Handler to assign to the returned Message object's \u003cem\u003etarget\u003c/em\u003e member. * @param callback Runnable that will execute when the message is handled. * @return A Message object from the global pool. */ public static Message obtain(Handler h, Runnable callback) { Message m = obtain(); m.target = h; m.callback = callback; return m; } obtain方法还可以传递一个Runnable，作用是当message发送到Handler时就会执行这个runnable。而且这个callback竟然与Handler在同一线程中！！！ 但是一旦给消息设置了callback，实测Handler的handleMessage会失效，这是为啥，要想一想了。 ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:4","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#callback"},{"categories":null,"content":" 传递 mHandler.send(msg); msg.sendToTarget(); Parcelable ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:5","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#传递"},{"categories":null,"content":" 异步设置消息是否异步，这意味着它不受{@link Looper}同步障碍的约束。 public void setAsynchronous(boolean async) { if (async) { flags |= FLAG_ASYNCHRONOUS; } else { flags \u0026= ~FLAG_ASYNCHRONOUS; } } 异步方式我平时很少使用，听说是可以提升消息的重要性，如果标明异步，那么MessageQueue将会由近及远优先处理异步消息，然后再处理同步消息。 ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:6","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#异步"},{"categories":null,"content":" 回收 public void recycle() { if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException(\"This message cannot be recycled because it is still in use.\"); } return; } recycleUnchecked(); } 先检测是否在使用中，检测通过才真正的回收： /** * 回收一个可能正在使用中的Message。 * 当队列中的Message被释放时，由MessageQueue 和 Looper在内部调用此方法。 */ @UnsupportedAppUsage void recycleUnchecked() { // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) { if (sPoolSize \u003c MAX_POOL_SIZE) { next = sPool; // 添加入链条 sPool = this; sPoolSize++; } } } 这个方法的作用是把当前的Message对象回滚到初始状态，并且标记为「正在使用」。把当前的Message赋值给了next，并且sPoolSize++,表示多了个闲置。 MAX_POOL_SIZE常量的值为50，那么就是一个App最多能有50个闲置的message。 ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:7","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#回收"},{"categories":null,"content":" 总结Message的原理是整数sPoolSize+静态单向链sPoll，平时我们使用的message都是从sPoll中取队首，状态改为闲置，回收后把状态改成「使用中」，并插回到队首，遵循「后进先出」原则，并在填充和回收时通过synchronized保障线程安全。 ","date":"2021-03-03","objectID":"/message%E8%A7%A3%E8%AF%BB/:0:8","series":null,"tags":["Android","message"],"title":"Message解读","uri":"/message%E8%A7%A3%E8%AF%BB/#总结"},{"categories":null,"content":" 类图 ","date":"2021-03-02","objectID":"/looper%E8%A7%A3%E8%AF%BB/:1:0","series":null,"tags":["Android"],"title":"Looper解读","uri":"/looper%E8%A7%A3%E8%AF%BB/#类图"},{"categories":null,"content":" prepare public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { // 如果线程已经有了Looper就会报错 if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } /** * 构造方法中创建MessageQueue，并引用当前线程。 */ private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } Looper.prepare()方法只是为了创建MessageQueue和初始化ThreadLocal。 之前了解过，ThreadLocal可以保证多线程访问共享变量的线程安全问题。他不像synchronized靠阻塞实现线程安全，而是通过对变量拷贝的方式，使每一个线程都操作自己的拷贝，实现线程安全，所以效率要优于synchronized。详情看这里和这里 ThreadLocal在此处的使用是为了保证每个线程都只能分配到一个Looper对象，多次调用Looper.prepary()方法会抛出异常。而且在其他线程去操作这个Looper对象可以保证线程安全，比如在主线程中调用mHandler.getLooper().quitSafely()来终止子线程的Looper对象的loop()循环。 ","date":"2021-03-02","objectID":"/looper%E8%A7%A3%E8%AF%BB/:2:0","series":null,"tags":["Android"],"title":"Looper解读","uri":"/looper%E8%A7%A3%E8%AF%BB/#prepare"},{"categories":null,"content":" loop只看核心： public static void loop() { final Looper me = myLooper();//其实就是从threadLocal中取出looper //省略判空 me.mInLoop = true; //改变状态 final MessageQueue queue = me.mQueue;//拿到MessageQueue ... //接下来就是启动个死循环，为什么不用while而用for呢？ for (;;) { Message msg = queue.next(); // 从MessageQueue中取出Message if (msg == null) { //如果池子里面没有msg了则终止循环，所以这里并不是一个真正的死循环 return; } try { msg.target.dispatchMessage(msg);//调用Handler的dispatchMessage } catch (Exception exception) { //... } finally { //... } //回收消息 msg.recycleUnchecked(); } 这里死循环的写法比较特殊，为什么不用while(true)或者do-while(true)呢？一开始总是想不明白。后来发现，用while系列循环，无论如何都要传递个表达式进去，那么就涉及到了内存占用和CPU运算。而用空for循环，则不必创建任何变量或结构体，能够最大限度的降低内存和CPU占用，真是学到了。 今天又突然想到，既然涉及到表达式，那么每次循环的时候都需要判断表达式是否成立，无可避免浪费了cpu，同时带来了cpu计算单元做无效计算带来的性能损失。 上面的代码中可以看到，当没有msg时，loop就会退出，那么问题来了，什么时候会没有msg呢？并且一旦loop退出，那么主线程不也就跟着退出了吗？目前我的猜想是，当没有消息时，Android通过epool机制让cpu休眠，当有了新的msg时又会唤醒cpu，从而保证一直存在msg。而休眠的时机是在messageQueue的next()方法中进行的： if (msg != null) { ... } else { //如果当前没有消息，把唤醒时钟设为-1，那么意味着线程会沉睡Integer.MaxValue nextPollTimeoutMillis = -1; } ","date":"2021-03-02","objectID":"/looper%E8%A7%A3%E8%AF%BB/:3:0","series":null,"tags":["Android"],"title":"Looper解读","uri":"/looper%E8%A7%A3%E8%AF%BB/#loop"},{"categories":null,"content":" 主线程中为何不ANR也不会内存泄露我们都知道线程一旦运行完毕就会回收，那么主线程中没有执行任何动作时为何不会回收呢？原因就是因为looper在死循环，阻塞了主线程的回收，那么相应的一旦不再死循环，程序也就退出了。Android同时利用Looper的死循环，发送消息，比如通知View重绘等等。 ","date":"2021-03-02","objectID":"/looper%E8%A7%A3%E8%AF%BB/:4:0","series":null,"tags":["Android"],"title":"Looper解读","uri":"/looper%E8%A7%A3%E8%AF%BB/#主线程中为何不anr也不会内存泄露"},{"categories":null,"content":" 会不会阻塞子线程呢？ class MyRunnable implements Runnable { @Override public void run() { Looper.prepare(); Handler handler = new Handler(); Message msg = Message.obtain(handler, new Runnable() { @Override public void run() { Log.d(\"\", \"run: \"); } }); msg.sendToTarget(); Looper.loop(); Log.d(\"这里永远都不会执行\", \"run:\"); int i = 0; } } 我用Profile持续观察之后发现：答案是会！CPU会一直被占用，线程池也无法回收该线程！ ","date":"2021-03-02","objectID":"/looper%E8%A7%A3%E8%AF%BB/:5:0","series":null,"tags":["Android"],"title":"Looper解读","uri":"/looper%E8%A7%A3%E8%AF%BB/#会不会阻塞子线程呢"},{"categories":null,"content":" 终止loop所以为了尽可能减少CPU浪费，应该调用handler.getLooper().quitSafely(); public void quitSafely() { mQueue.quit(true); } 再来看mQueue.quit(true)： void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(\"Main thread not allowed to quit.\"); } synchronized (this) { if (mQuitting) { return; } mQuitting = true; if (safe) { removeAllFutureMessagesLocked(); } else { removeAllMessagesLocked(); } // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); } } 主要是修改了mQuitting = true;，这就是个标记，用来判断是否终止死循环。造成的效果呢当然是在loop方法的死循环中调用mqueue.next()时，会受到下面代码的影响： if (mQuitting) { dispose(); return null; } private void dispose() { if (mPtr != 0) { nativeDestroy(mPtr); mPtr = 0; } } private native static void nativeDestroy(long ptr); 直接返回null，而在Looper的loop方法的死循环中有这样的判断： ... Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. me.mLogging.println(\"注意啦，真的停啦～～～\"); return; } ... 如果queue.next返回null那么就终止循环。 ","date":"2021-03-02","objectID":"/looper%E8%A7%A3%E8%AF%BB/:6:0","series":null,"tags":["Android"],"title":"Looper解读","uri":"/looper%E8%A7%A3%E8%AF%BB/#终止loop"},{"categories":null,"content":" 总结Looper其实比较简单，核心就两个方法： prepary()方法用来创建MessageQueue和ThreadLocal； loop()方法就是永动机，不断从message中拿出msg来消费。 只有调用quitSafely()或者quit()这两个方法修改mQuitting这个标记位，使MessageQueue的next()方法返回null，才能退出loop()方法。 一个线程只有一个Looper，是通过ThreadLocal实现的。 ","date":"2021-03-02","objectID":"/looper%E8%A7%A3%E8%AF%BB/:6:1","series":null,"tags":["Android"],"title":"Looper解读","uri":"/looper%E8%A7%A3%E8%AF%BB/#总结"},{"categories":null,"content":" 记忆方式Fragment的onAttach,onCreate,onCreateView,onViewCreated在附加到Activity时执行，如setContentView或者add,replace时。 Fragment的onResume是在Activity的onResume执行完之后才会执行，而其他生命周期都在Activity的super.onXXX内执行。 跳转时，前一个页面的生命周期走到onPause时暂停，等待后一个页面的生命周期走到onResume之后，再继续执行onStop；同理，返回时后一个页面走到onPause时暂停，前一个页面onRestart,onStart,onResume之后，再继续执行剩下的onStop,onDestory。 ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:1:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#记忆方式"},{"categories":null,"content":" 懒加载Fragment的懒加载主要是用于ViewPager中，ViewPager会在加载fragment之前调用其setUserVisibleHint()方法。所以setUserVisibleHint()是在onActtch()方法之前调用。 ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:2:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#懒加载"},{"categories":null,"content":" 流程图 ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:3:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#流程图"},{"categories":null,"content":" 启动 D: FirstActivity's super.onCreate: 前 D: FirstActivity's super.onCreate: 后 D: FirstActivity's setContentView: 前 D: FirstFragment's onAttach: D: FirstFragment's onCreate: D: FirstFragment's onCreateView: D: FirstFragment's onViewCreated: D: FirstActivity's setContentView: 后 D: FirstActivity's super.onStart: 前 D: FirstFragment's onActivityCreated: D: FirstFragment's onStart: D: FirstActivity's super.onStart: 后 D: FirstActivity's super.onResume: 前 D: FirstActivity's super.onResume: 后 D: FirstFragment's onResume: fragment的onAttach，onCreate，onCreateView，onViewCreated是在Activity的setContentView中执行的。 想一下就知道，Activity的setContentView的目的是从xml中加载View，而我把fragment写在了xml里面。 这里有个小插曲，事实证明，Activity的super.onCreate可以写在setContentView之后，但是xml中存在fragment时就会报错。 fragment的onActivityCreated、onStart是在Activity的super.onStart方法中执行。 fragment的onResume是在activity的super.onResume之后执行。 ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:4:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#启动"},{"categories":null,"content":" 跳转 D: FirstActivity's super.onPause: 前 D: FirstFragment's onPause: D: FirstActivity's super.onPause: 后 D: SecondActivity's super.onCreate: 前 D: SecondActivity's super.onCreate: 后 D: SecondActivity's setContentView: 前 D: SecondFragment's onAttach: D: SecondFragment's onCreate: D: SecondFragment's onCreateView: D: SecondFragment's onViewCreated: D: SecondActivity's setContentView: 后 D: SecondActivity's super.onStart: 前 D: SecondFragment's onActivityCreated: D: SecondFragment's onStart: D: SecondActivity's super.onStart: 后 D: SecondActivity's super.onResume: 前 D: SecondActivity's super.onResume: 后 D: SecondFragment's onResume: D: FirstActivity's super.onStop: 前 D: FirstFragment's onStop: D: FirstActivity's super.onStop: 后 fragment的onPause是在Activity的super.onPause中执行。 当第二个含有fragment的Activity可见后，上一个Activity的生命周期才会继续。 然后上一个fragment的onStop在Activity的onStop中执行。 注意，前一个Activity执行到onPause，然后第二个Activity生命周期完成后，前一个Activity才会执行onStop。 ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:5:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#跳转"},{"categories":null,"content":" 返回 D: SecondActivity's super.onPause: 前 D: SecondFragment's onPause: D: SecondActivity's super.onPause: 后 D: FirstActivity's super.onRestart: 前 D: FirstActivity's super.onRestart: 后 D: FirstActivity's super.onStart: 前 D: FirstFragment's onStart: D: FirstActivity's super.onStart: 后 D: FirstActivity's super.onResume: 前 D: FirstActivity's super.onResume: 后 D: FirstFragment's onResume: D: SecondActivity's super.onStop: 前 D: SecondFragment's onStop: D: SecondActivity's super.onStop: 后 D: SecondActivity's super.onDestroy: 前 D: SecondFragment's onDestroyView: D: SecondFragment's onDestroy: D: SecondFragment's onDetach: D: SecondActivity's super.onDestroy: 后 先执行第二个Activity的onPause。 再回调前一个Activity的onRestart。 fragment的onStart在Activity的super.onStart中执行。 fragment的onResume在Activity的super.onResume中执行。 fragment的onStop在Activity的super.onStop中执行。 fragment的onDestroyView、onDestroy、onDetach在Activity的super.onDestroy中执行。 注意fragment的onResume是在Activity的onResume之后执行的！！！ ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:5:1","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#返回"},{"categories":null,"content":" 退入后台 D: FirstActivity's super.onPause: 前 D: FirstFragment's onPause: D: FirstActivity's super.onPause: 后 D: FirstActivity's super.onStop: 前 D: FirstFragment's onStop: D: FirstActivity's super.onStop: 后 ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:6:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#退入后台"},{"categories":null,"content":" 回到前台 D: FirstActivity's super.onRestart: 前 D: FirstActivity's super.onRestart: 后 D: FirstActivity's super.onStart: 前 D: FirstFragment's onStart: D: FirstActivity's super.onStart: 后 D: FirstActivity's super.onResume: 前 D: FirstActivity's super.onResume: 后 D: FirstFragment's onResume: ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:7:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#回到前台"},{"categories":null,"content":" 退出 D: FirstActivity's super.onPause: 前 D: FirstFragment's onPause: D: FirstActivity's super.onPause: 后 D: FirstActivity's super.onStop: 前 D: FirstFragment's onStop: D: FirstActivity's super.onStop: 后 D: FirstActivity's super.onDestroy: 前 D: FirstFragment's onDestroyView: D: FirstFragment's onDestroy: D: FirstFragment's onDetach: D: FirstActivity's super.onDestroy: 后 ","date":"2021-02-26","objectID":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:8:0","series":null,"tags":["Android","生命周期","fragment","activity"],"title":"Fragment在Activity中的生命周期","uri":"/fragment%E5%9C%A8activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#退出"},{"categories":null,"content":" GraphQL如何获取数据每个field都有一个graphql.schema.DataFetcher与之对应。 一些File会使用特定的data fetcher，这种DataFetcher知道怎么去访问数据库获取field的信息，然后大多数的dataFetcher则是简单的从内存中的object获取数据。在获取数据时，会参照field的名字and Plain Old Java Object (POJO) patterns to get the data. 所以可以像这样来声明一个type: type Query { products(match : String) : [Product] # a list of products } type Product { id : ID name : String description : String cost : Float tax : Float launchDate(dateFormat : String = \"dd, MMM, yyyy') : String } Query.products这个field有一个data fetcher，用来获取从数据库中获取Product类型的fields集合。它带有一个match参数，可以过滤出我们想要的product： DataFetcher productsDataFetcher = new DataFetcher\u003cList\u003cProductDTO\u003e\u003e() { @Override public List\u003cProductDTO\u003e get(DataFetchingEnvironment environment) { DatabaseSecurityCtx ctx = environment.getContext(); List\u003cProductDTO\u003e products; String match = environment.getArgument(\"match\"); if (match != null) { products = fetchProductsFromDatabaseWithMatching(ctx, match); } else { products = fetchAllProductsFromDatabase(ctx); } return products; } }; 每个DataFetcher相互之间传递着一个graphql.schema.DataFetchingEnvironment对象，这个对象包含正在获取的field、传递给field的参数arguments、和其他信息诸如field的类型，它父级的类型query root object或者query context object。 要注意的是，data fetcher的编码是基于context object作为一个安全程序来处理数据库的访问。这是一个基本技术来提供一个底层调用上下文。 当我们有一个ProductDTO的列表，我们不需要为每一个field都搞一个data fetcher。graphql-java 有一个聪明的graphql.schema.PropertyDataFetcher知道怎么去根据名称追踪POJO的结构。在本例中就是有个带有name的field，然后graphql.schema.PropertyDataFetcher将尝试通过POJO的public String getName()方法来获取数据。 graphql.schema.PropertyDataFetcher是默认的DataFetcher。 你仍然可以在DTO的方法中使用graphql.schema.PropertyDataFetcher来访问。这允许你在数据发送出去之前先做修改。比如，我们有个launchDate字段携带者一个可选的dateFormat参数。我们可以在ProductDTO中写个逻辑做日期时间的格式化。 class ProductDTO { private ID id; private String name; private String description; private Double cost; private Double tax; private LocalDateTime launchDate; // ... public String getName() { return name; } // ... public String getLaunchDate(DataFetchingEnvironment environment) { String dateFormat = environment.getArgument(\"dateFormat\"); return yodaTimeFormatter(launchDate,dateFormat); } } ","date":"2021-01-23","objectID":"/graphql-java%E4%BA%8Cdatafetcher/:1:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(二)DataFetching","uri":"/graphql-java%E4%BA%8Cdatafetcher/#graphql如何获取数据"},{"categories":null,"content":" 定制PropertyDataFetcher像之前讲的一样，graphql.schema.PropertyDataFetcher是默认的data fetcher，并且它在获取数据时使用标准结构。 它支持POJO和map。假设有个field叫fieldX，它将会寻找一个POJO也叫做fieldX，或者在Map中去找一个key也叫做fieldX。 然而，你在定义的schema与POJO有一点不通，比如Product.description对应着POJO中的getDesc(). 你可以在SDL中使用@fetch注解来做匹配： directive @fetch(from : String!) on FIELD_DEFINITION type Product { id : ID name : String description : String @fetch(from:\"desc\") cost : Float tax : Float } 这将告诉graphql.schema.PropertyDataFetcher在获取数据时应该使用名为desc的属性来对应SDL中的description字段。 如果你不用SDL,而是喜欢手写代码，那么可以直接指定Data Fetcher: GraphQLFieldDefinition descriptionField = GraphQLFieldDefinition.newFieldDefinition() .name(\"description\") .type(Scalars.GraphQLString) .build(); GraphQLCodeRegistry codeRegistry = GraphQLCodeRegistry.newCodeRegistry() .dataFetcher( coordinates(\"ObjectType\", \"description\"), PropertyDataFetcher.fetching(\"desc\")) .build(); ","date":"2021-01-23","objectID":"/graphql-java%E4%BA%8Cdatafetcher/:2:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(二)DataFetching","uri":"/graphql-java%E4%BA%8Cdatafetcher/#定制propertydatafetcher"},{"categories":null,"content":" DataFetchingEnvironment中有意思的部分每一个data fetcher都传递了一个graphql.schema.DataFetchingEnvironment对象。它知道我们正在获取什么东西，并且知道提供了哪些参数。 \u003cT\u003e T getSource()-获取field的信息。这个对象就是父级获取到的结果，他一个内存中的DTO对象，并且通过POJO的getters获取到值。在复杂的场景中，你可以通过检查它来获取field的特定信息。当graphql的field tree执行后返回的每一个field的值，都会成为子级的source。 \u003cT\u003e T getRoot()-用来查看graphql的查询query。在顶层级中，root和source是一样的。root object在查询期间是不会改变的，它可能为null，所以尽量不要用这玩意。 Map\u003cString, Object\u003e getArguments()-用来获取field提供的参数。 \u003cT\u003e T getContext()-当query第一次执行时，才会设置好context，并让其停留在query的生命周期上。所以context的生命周期与query一致。context可以是任何值，主要是data fetcher在获取数据时需要这玩意。所以只需要把它注入给data fetcher就行了，其他场景都用不到。（日了狗了，讲了这么长一串，最后特么没点鸟用） ExecutionStepInfo getExecutionStepInfo()-用来获取ExecutionStepInfo。当query执行后，ExecutionStepInfo存放了所有field的类型信息。 DataFetchingFieldSelectionSet getSelectionSet()-用来获取选项集。所谓「选项集」就是当前执行中的field之后的哪些被「选中」的子filed们。这对于展望接下来将要执行的field的信息。（我感觉就像是音乐播放器在播放收藏的专辑一样，比如当前播放到了费玉清的《天之大》，那么我们就可以通过这个方法去查看《天之大》下面有哪些歌将要被播放了）。 ExecutionId getExecutionId()-所有的查询都有一个unique id。可以把id作为log日志的tag，用来打印特定的query。 ","date":"2021-01-23","objectID":"/graphql-java%E4%BA%8Cdatafetcher/:3:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(二)DataFetching","uri":"/graphql-java%E4%BA%8Cdatafetcher/#datafetchingenvironment中有意思的部分"},{"categories":null,"content":" ExecutionStepInfo好玩的地方一个graphql query在执行时会生成一个call tree，就是「调用树」。graphql.execution.ExecutionStepInfo.getParentTypeInfo允许你向上导航，看到是什么类型的field被带到了当前的执行过程。 在整个执行期间，就形成了一个树形path，graphql.execution.ExecutionStepInfo.getPath方法可以返回这个树形path的描述。这在日志打印和调试query时比较有用。而且可以查看到非空类型的名称和折叠后的列表。 一句话总结就是，主要用于调试和排错。 ","date":"2021-01-23","objectID":"/graphql-java%E4%BA%8Cdatafetcher/:3:1","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(二)DataFetching","uri":"/graphql-java%E4%BA%8Cdatafetcher/#executionstepinfo好玩的地方"},{"categories":null,"content":" DataFetchingFieldSelectionSet有趣的地方想象一下有个query就像这样： query { products { # the fields below represent the selection set name description sellingLocations { state } } } Product的所有子field，对于Product来讲就是selection fields。当我们想要知道哪些子级field正在被请求时非常有用。举例来讲，我们的POJO中可能有很多属性，数据库表中的字段也与之一一对应。但是我们跑个graphql查询时可能不需要返回全部的字段，我们只要我们需要的字段就行了，此时data fetcher去查数据库时也不需要查出所有的列，也是按需获取就行了。那怎么在代码里感知到我们具体请求的哪些字段呢？就是靠这个DataFetchingFieldSelectionSet。 比如上例中我们请求了sellingLocations字段，或者我们使用更高效的查询：同时查出products和sellingLocations。 ","date":"2021-01-23","objectID":"/graphql-java%E4%BA%8Cdatafetcher/:3:2","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(二)DataFetching","uri":"/graphql-java%E4%BA%8Cdatafetcher/#datafetchingfieldselectionset有趣的地方"},{"categories":null,"content":" 引入依赖 dependencies { implementation 'com.graphql-java:graphql-java:14.1' // NEW implementation 'com.graphql-java:graphql-java-spring-boot-starter-webmvc:1.0' // NEW implementation 'com.google.guava:guava:26.0-jre' // NEW implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test' } ","date":"2021-01-23","objectID":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/:1:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(零)从SpringBoot服务端开始","uri":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/#引入依赖"},{"categories":null,"content":" 定义Schema在src/main/resources中创建schema.graphqls如下： type Query { bookById(id: ID): Book } type Book { id: ID name: String pageCount: Int author: Author } type Author { id: ID firstName: String lastName: String } 这里定义了一个顶级字段：bookById，它用来返回特定ID的book； 并且定义了一个Boo类，其中包含id,name,pageCount,author。author是另一个类型。 ","date":"2021-01-23","objectID":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/:2:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(零)从SpringBoot服务端开始","uri":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/#定义schema"},{"categories":null,"content":" 解析Schema在项目中创建一个GraphQLProvider类型的java文件，用来创建GraphQL实例： @Component public class GraphQLProvider { private GraphQL graphQL; @Bean public GraphQL graphQL() { return graphQL; } /** * 用Guava Resources读取资源文件 * * @throws IOException */ @PostConstruct public void init() throws IOException { URL url = Resources.getResource(\"schema.graphqls\"); String sdl = Resources.toString(url, Charsets.UTF_8); GraphQLSchema graphQLSchema = buildSchema(sdl); this.graphQL = GraphQL.newGraphQL(graphQLSchema).build(); } private GraphQLSchema buildSchema(String sdl) { // TODO: we will create the schema here later } } 我们通过google的Guava Resources来读取Schema.graphql文件，并且通过@Bean注解把GraphQL实例暴露出去，GraphQL Java Spring adapter会使用这个GraphQL实例来把schema匹配到`/graphql’路径，以后通过这个路径调用所有接口。 接下来实现buildSchema方法： @Autowired GraphQLDataFetchers graphQLDataFetchers; /** * 构建调用模型 * @param sdl 从资源文件获取到的sdl语言内容 * @return */ private GraphQLSchema buildSchema(String sdl) { TypeDefinitionRegistry typeRegistry = new SchemaParser().parse(sdl); RuntimeWiring runtimeWiring = buildWiring(); SchemaGenerator schemaGenerator = new SchemaGenerator(); return schemaGenerator.makeExecutableSchema(typeRegistry, runtimeWiring); } private RuntimeWiring buildWiring() { return RuntimeWiring.newRuntimeWiring() .type(newTypeWiring(\"Query\") .dataFetcher(\"bookById\", graphQLDataFetchers.getBookByIdDataFetcher())) .type(newTypeWiring(\"Book\") .dataFetcher(\"author\", graphQLDataFetchers.getAuthorDataFetcher())) .build(); } TypeDefinitionRegistry 是SDL转换成的java对象。RuntimeWiring才是真正的重点，主要作用是注册了两个DataFetchers： 一个用来根据ID查book； 一个用来获取特定book的作者。 仔细看代码会发现，在构建RuntimeWiring时用到的字符串参数，全都是我们在SDL中定义好的type，所以这里的作用是告诉GraphQL Adapter怎么去根据SDL拿对应的数据。 ","date":"2021-01-23","objectID":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/:3:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(零)从SpringBoot服务端开始","uri":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/#解析schema"},{"categories":null,"content":" DataFetchersDataFetcher是一个接口，用来根据SDL中的field来获取对应的数据，所以它内部只有一个抽象方法： public interface DataFetcher\u003cT\u003e { T get(DataFetchingEnvironment dataFetchingEnvironment) throws Exception; } 这里要注意，SDL中每一个field都对应一个DataFetcher，如果没有特别指定一个DataFetcher，默认会采用PropertyDataFetcher。所以在上面生成RuntimeWiring的代码中，并没有对author注册dataFetcher，而是让他直接采用了默认的PropertyDataFetcher。 接下来我们就来实现DataFetcher了，创建一个GraphQLDataFetchers类： @Component public class GraphQLDataFetchers { private static List\u003cMap\u003cString, String\u003e\u003e books = Arrays.asList( ImmutableMap.of(\"id\", \"book-1\", \"name\", \"Harry Potter and the Philosopher's Stone\", \"pageCount\", \"223\", \"authorId\", \"author-1\"), ImmutableMap.of(\"id\", \"book-2\", \"name\", \"Moby Dick\", \"pageCount\", \"635\", \"authorId\", \"author-2\"), ImmutableMap.of(\"id\", \"book-3\", \"name\", \"Interview with the vampire\", \"pageCount\", \"371\", \"authorId\", \"author-3\") ); private static List\u003cMap\u003cString, String\u003e\u003e authors = Arrays.asList( ImmutableMap.of(\"id\", \"author-1\", \"firstName\", \"Joanne\", \"lastName\", \"Rowling\"), ImmutableMap.of(\"id\", \"author-2\", \"firstName\", \"Herman\", \"lastName\", \"Melville\"), ImmutableMap.of(\"id\", \"author-3\", \"firstName\", \"Anne\", \"lastName\", \"Rice\") ); public DataFetcher getBookByIdDataFetcher() { return dataFetchingEnvironment -\u003e { String bookId = dataFetchingEnvironment.getArgument(\"id\"); return books .stream() .filter(book -\u003e book.get(\"id\").equals(bookId)) .findFirst() .orElse(null); }; } public DataFetcher getAuthorDataFetcher() { return dataFetchingEnvironment -\u003e { Map\u003cString,String\u003e book = dataFetchingEnvironment.getSource(); String authorId = book.get(\"authorId\"); return authors .stream() .filter(author -\u003e author.get(\"id\").equals(authorId)) .findFirst() .orElse(null); }; } } 全都是mock数据，亮点是采用了java的新特性，通过流式调用来处理集合，并且还有lamda表达式的书写。 上面的代码中，我们可以看到，DataFetcher是DataFetchingEnvironment，三个查询方法也都是返回DataFetchingEnvironment的实例，其中需要关注的是： getArgument(\"id\")用来获取参数。 getSource()用来获取对象。 根据我们在SDL中的定义： type Query { bookById(id: ID): Book } 查询book时需要传递一个id，所以这个id怎么获取呢？通过dataFetchingEnvironment.getArgument(\"id\")就能获取到。 然后根据SDL中定义： type Book { id: ID! name: String pageCount: Int author: Author } 查询特定book的作者，那么需要一个特定的book实例，通过getSource()可以获取到父级的book实例。 在GraphQL中，每一个field的DataFetcher是从上到下，从父到子被调用的，并且父级的结果可以从子级的DataFetcherEnvironment的getSource()方法中取到。 ","date":"2021-01-23","objectID":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/:4:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(零)从SpringBoot服务端开始","uri":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/#datafetchers"},{"categories":null,"content":" Default DataFetchers前面说过，如果不给field指定一个DataFetcher，那么将默认使用PropertyDataFetcher。在这个demo里，意味着Book.id, Book.name, Book.pageCount, Author.id, Author.firstName, Author.lastName都对应着一个PropertyDataFetcher。 PropertyDataFetcher会通过多种方式从Java对象中找到对应的属性，如果是java.util.Map，就通过Key去找。这里要求field的名字与key一致。如果不一致就会返回null。（这里我翻译的不太对味，但是意思还是很明确的）。 ","date":"2021-01-23","objectID":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/:4:1","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(零)从SpringBoot服务端开始","uri":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/#default-datafetchers"},{"categories":null,"content":" Try API直接rest_client了： POST http://localhost:9000/graphql Content-Type: application/json X-REQUEST-TYPE: GraphQL { bookById(id:\"book-1\"){ id name pageCount author { firstName lastName } } } 返回结果： HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Sat, 23 Jan 2021 13:35:24 GMT Connection: close { \"data\": { \"bookById\": { \"id\": \"book-1\", \"name\": \"Harry Potter and the Philosopher's Stone\", \"pageCount\": 223, \"author\": { \"firstName\": \"Joanne\", \"lastName\": \"Rowling\" } } } } ","date":"2021-01-23","objectID":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/:5:0","series":null,"tags":["GraphQL"],"title":"GraphQL-Java(零)从SpringBoot服务端开始","uri":"/graphql-java%E9%9B%B6%E5%85%A5%E9%97%A8/#try-api"},{"categories":null,"content":"本文基于GraphQl-java:v1.6版本官方文档中文翻译。","date":"2021-01-19","objectID":"/graphql-java%E4%B8%89execution/","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(三)Execution","uri":"/graphql-java%E4%B8%89execution/"},{"categories":null,"content":" Queries如果想要在schema里跑个查询，需要用对应的参数创建一个新的GraphQL object，然后执行execute()。该方法会返回一个ExecutionResult，它包含查询结果，或者一个错误列表。 GraphQLSchema schema = GraphQLSchema.newSchema() .query(queryType) .build(); GraphQL graphQL = GraphQL.newGraphQL(schema) .build(); ExecutionInput executionInput = ExecutionInput.newExecutionInput().query(\"query { hero { name } }\") .build(); ExecutionResult executionResult = graphQL.execute(executionInput); Object data = executionResult.getData(); List\u003cGraphQLError\u003e errors = executionResult.getErrors(); 更多的列子在这里 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%89execution/:1:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(三)Execution","uri":"/graphql-java%E4%B8%89execution/#queries"},{"categories":null,"content":" Data Fetchers每一个field都对应着一个graphql.schema.DataFetcher，也被称作resolvers。 你可以用基于graphql.schema.PropertyDataFetcher去测试Java POJO对象提供的field。如果你没有为field指定一个data fetcher，那么默认会使用graphql.schema.PropertyDataFetcher。 然而，你需要通过自定义的data fetcher去获取域的顶层对象，这意味着你可能需要创建一个数据库，或者通过http调用其他服务获取。 graphql-java并不关注如何获取对象，这些逻辑需要你自己去处理。 一个data fetcher可能像这样： DataFetcher userDataFetcher = new DataFetcher() { @Override public Object get(DataFetchingEnvironment environment) { return fetchUserFromDatabase(environment.getArgument(\"userId\")); } }; 每一个DataFetcher实际上都包含在graphql.schema.DataFetchingEnvironment对象中，而graphql.schema.DataFetchingEnvironment对象同时包含了正在获取的字段、已提供给字段的参数、字段的父级对象、查询根对象或者查询上下文。 在上面的示例中，执行将等待数据提取程序返回后再继续。您可以通过向数据返回 CompletionStage 来异步执行 DataFetcher，本页面将对此进行更详细的解释。 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%89execution/:2:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(三)Execution","uri":"/graphql-java%E4%B8%89execution/#data-fetchers"},{"categories":null,"content":" Exceptions while fetching data如果在数据读取器调用期间发生异常，那么默认情况下执行策略将生成 graphql。然后将其添加到结果的错误列表中。记住，graphql 允许带有错误的部分结果。 public class SimpleDataFetcherExceptionHandler implements DataFetcherExceptionHandler { private static final Logger log = LoggerFactory.getLogger(SimpleDataFetcherExceptionHandler.class); @Override public void accept(DataFetcherExceptionHandlerParameters handlerParameters) { Throwable exception = handlerParameters.getException(); SourceLocation sourceLocation = handlerParameters.getField().getSourceLocation(); ExecutionPath path = handlerParameters.getPath(); ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path, exception, sourceLocation); handlerParameters.getExecutionContext().addError(error); log.warn(error.getMessage(), exception); } } 如果您抛出的异常本身是一个 GraphqlError，那么它将把消息和自定义扩展属性从该异常转移到 exceptionwhiledatatfetching 对象中。这允许您将自己的定制属性放置到发送回调用者的 graphql 错误中。 例如，假设您的数据读取器抛出此异常。Foo 和 fizz 属性将包含在结果 graphql 错误中。 class CustomRuntimeException extends RuntimeException implements GraphQLError { @Override public Map\u003cString, Object\u003e getExtensions() { Map\u003cString, Object\u003e customAttributes = new LinkedHashMap\u003c\u003e(); customAttributes.put(\"foo\", \"bar\"); customAttributes.put(\"fizz\", \"whizz\"); return customAttributes; } @Override public List\u003cSourceLocation\u003e getLocations() { return null; } @Override public ErrorType getErrorType() { return ErrorType.DataFetchingException; } } 翻译到这里先停一下吧，单纯的翻译只是浪费时间。前段时间项目紧，没时间吃透这个graphql，所以现在想直接从个人网盘项目里面尝试一下。 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%89execution/:3:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(三)Execution","uri":"/graphql-java%E4%B8%89execution/#exceptions-while-fetching-data"},{"categories":null,"content":"本文基于GraphQl-java:v1.6版本官方文档中文翻译。","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/"},{"categories":null,"content":" 引入依赖版本列表 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:1:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#引入依赖"},{"categories":null,"content":" Gradle repositories { mavenCentral() } dependencies { compile 'com.graphql-java:graphql-java:15.0' } ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:1:1","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#gradle"},{"categories":null,"content":" Maven \u003cdependency\u003e \u003cgroupId\u003ecom.graphql-java\u003c/groupId\u003e \u003cartifactId\u003egraphql-java\u003c/artifactId\u003e \u003cversion\u003e15.0\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:1:2","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#maven"},{"categories":null,"content":" Schema——大纲创建一个Schema有两种方式： 推荐SDL(special graphql dsl): type Foo { bar: String } java code: GraphQLObjectType fooType = newObject() .name(\"Foo\") .field(newFieldDefinition() .name(\"bar\") .type(GraphQLString)) .build(); ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:2:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#schema大纲"},{"categories":null,"content":" DataFetcher and TypeResolverDataFetcher用来向field提供数据，每一个field都包含一个DataFetcher,默认采用PropertyDataFetcher。 PropertyDataFetcher 从Map或者Java Bean中获取数据，所以当field name与map的key，或者类的元素名称的相匹配，就不需要定义DataFetcher了。 TypeResolver帮助graphql-java判断值的类型。 想象一下，你有一个接口MagicUserType，用来解析一系列java类Wizard,Witch和Necromancer。类型检查器负责检查一个运行时对象，并且判断用哪个GraphqlObjectType去响应这个对象，对应的应该用哪个data fetchers和field去运行。 new TypeResolver() { @Override public GraphQLObjectType getType(TypeResolutionEnvironment env) { Object javaObject = env.getObject(); if (javaObject instanceof Wizard) { return env.getSchema().getObjectType(\"WizardType\"); } else if (javaObject instanceof Witch) { return env.getSchema().getObjectType(\"WitchType\"); } else { return env.getSchema().getObjectType(\"NecromancerType\"); } } }; ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:3:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#datafetcher-and-typeresolver"},{"categories":null,"content":" 用SDL创建一个Schema当通过schema创建一个SDL，你应该定义好DataFetcher和TypeResolver。 比如创建一个starWarsSchema.graphqls: 这货是星战迷，日了，好多电影里自创的名词。幸亏前阵子看了《曼达洛人》，要不然都翻译不了这破官文。 schema { query: QueryType } type QueryType { hero(episode: Episode): Character //英雄 human(id : String) : Human //人类 droid(id: ID!): Droid //德鲁伊 } //BGM枚举 enum Episode { NEWHOPE //新希望军 EMPIRE //帝国军 JEDI //绝地武士 } //角色接口 interface Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! //出现的时候播放对应的BGM } type Human implements Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! homePlanet: String //母星 } type Droid implements Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String //超能力 } 这个静态文件starWarsSchema.graphqls包含了field和type的定义，但是你还需要一个runtimeWiring（运行时注入）来把这个静态文件转换为一个可运行的schema。 runtimeWiring必须包含DataFetcher、TypeResolver和自定义的Scalar。 你可以用下面的建造者模式+lambda表达式去创建报文： RuntimeWiring buildRuntimeWiring() { return RuntimeWiring.newRuntimeWiring() .scalar(CustomScalar) // this uses builder function lambda syntax .type(\"QueryType\", typeWiring -\u003e typeWiring .dataFetcher(\"hero\", new StaticDataFetcher(StarWarsData.getArtoo())) .dataFetcher(\"human\", StarWarsData.getHumanDataFetcher()) .dataFetcher(\"droid\", StarWarsData.getDroidDataFetcher()) ) .type(\"Human\", typeWiring -\u003e typeWiring .dataFetcher(\"friends\", StarWarsData.getFriendsDataFetcher()) ) // you can use builder syntax if you don't like the lambda syntax .type(\"Droid\", typeWiring -\u003e typeWiring .dataFetcher(\"friends\", StarWarsData.getFriendsDataFetcher()) ) // or full builder syntax if that takes your fancy .type( newTypeWiring(\"Character\") .typeResolver(StarWarsData.getCharacterTypeResolver()) .build() ) .build(); } 最终，你可以把静态的大纲和注入结合到一起来创建一个可运行的schema： SchemaParser schemaParser = new SchemaParser(); SchemaGenerator schemaGenerator = new SchemaGenerator(); File schemaFile = loadSchema(\"starWarsSchema.graphqls\"); TypeDefinitionRegistry typeRegistry = schemaParser.parse(schemaFile); RuntimeWiring wiring = buildRuntimeWiring(); GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, wiring); 另外在建造者模式的基础上，TypeResolver和DataFetcher可以使用WiringFactory接口来注入。这会允许更多的动态运行时，通过schema的定义去判断应该注入什么东西。你可以通过阅读SDL来判断生成哪种runtime。 RuntimeWiring buildDynamicRuntimeWiring() { WiringFactory dynamicWiringFactory = new WiringFactory() { @Override public boolean providesTypeResolver(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition) { return getDirective(definition,\"specialMarker\") != null; } @Override public boolean providesTypeResolver(TypeDefinitionRegistry registry, UnionTypeDefinition definition) { return getDirective(definition,\"specialMarker\") != null; } @Override public TypeResolver getTypeResolver(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition) { Directive directive = getDirective(definition,\"specialMarker\"); return createTypeResolver(definition,directive); } @Override public TypeResolver getTypeResolver(TypeDefinitionRegistry registry, UnionTypeDefinition definition) { Directive directive = getDirective(definition,\"specialMarker\"); return createTypeResolver(definition,directive); } @Override public boolean providesDataFetcher(TypeDefinitionRegistry registry, FieldDefinition definition) { return getDirective(definition,\"dataFetcher\") != null; } @Override public DataFetcher getDataFetcher(TypeDefinitionRegistry registry, FieldDefinition definition) { Directive directive = getDirective(definition, \"dataFetcher\"); return createDataFetcher(definition,directive); } }; return RuntimeWiring.newRuntimeWiring() .wiringFactory(dynamicWiringFactory).build(); } ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:4:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#用sdl创建一个schema"},{"categories":null,"content":" 创建一个schema定义当schema生成时，DataFetcher和TypeResolver可以在类型创建时提供： DataFetcher\u003cFoo\u003e fooDataFetcher = new DataFetcher\u003cFoo\u003e(){ @Override public Foo get(DataFetchingEnvironment environment) { // environment.getSource() is the value of the surrounding // object. In this case described by objectType Foo value = perhapsFromDatabase(); // Perhaps getting from a DB or whatever return value; } }; GraphQLObjectType objectType = newObject() .name(\"ObjectType\") .field(newFieldDefinition() .name(\"foo\") .type(GraphQLString) ) .build(); GraphQLCodeRegistry codeRegistry = newCodeRegistry() .dataFetcher( coordinates(\"ObjectType\", \"foo\"), fooDataFetcher) .build(); ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:5:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#创建一个schema定义"},{"categories":null,"content":" GraphQl支持的类型 Scalar——标量 Object——对象 Interface——接口 Union——联合 InputObject——输入对象 Enum——枚举 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#graphql支持的类型"},{"categories":null,"content":" Scalargraphql-java支持下面几种标量： 标准标量： GraphQLString GraphQLBoolean GraphQLInt GraphQLFloat GraphQLID 扩展标量： GraphQLLong GraphQLShort GraphQLByte GraphQLFloat(怎么重复了？) GraphQLBigDecimal GraphQLBigInteger **注意：你的客户端可能不能理解扩展标量的语意，比如把Java中的long(最大值26^3-1)匹配给JavaScript的Number类型(最大值2^53 - 1)可能会出问题。 这里用了两个may be，我觉得身为一个官文，这样写是不对的。会就是会，may be什么鬼。 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:1","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#scalar"},{"categories":null,"content":" Scalargraphql-java支持下面几种标量： 标准标量： GraphQLString GraphQLBoolean GraphQLInt GraphQLFloat GraphQLID 扩展标量： GraphQLLong GraphQLShort GraphQLByte GraphQLFloat(怎么重复了？) GraphQLBigDecimal GraphQLBigInteger **注意：你的客户端可能不能理解扩展标量的语意，比如把Java中的long(最大值26^3-1)匹配给JavaScript的Number类型(最大值2^53 - 1)可能会出问题。 这里用了两个may be，我觉得身为一个官文，这样写是不对的。会就是会，may be什么鬼。 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:1","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#标准标量"},{"categories":null,"content":" Scalargraphql-java支持下面几种标量： 标准标量： GraphQLString GraphQLBoolean GraphQLInt GraphQLFloat GraphQLID 扩展标量： GraphQLLong GraphQLShort GraphQLByte GraphQLFloat(怎么重复了？) GraphQLBigDecimal GraphQLBigInteger **注意：你的客户端可能不能理解扩展标量的语意，比如把Java中的long(最大值26^3-1)匹配给JavaScript的Number类型(最大值2^53 - 1)可能会出问题。 这里用了两个may be，我觉得身为一个官文，这样写是不对的。会就是会，may be什么鬼。 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:1","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#扩展标量"},{"categories":null,"content":" ObjectSDL Example: //Simpson应该是卡通片《辛普森一家》中的一类怪物 type SimpsonCharacter { name: String mainCharacter: Boolean //是否是主角 } Java Example: GraphQLObjectType simpsonCharacter = newObject() .name(\"SimpsonCharacter\") .description(\"A Simpson character\") .field(newFieldDefinition() .name(\"name\") .description(\"The name of the character.\") .type(GraphQLString)) .field(newFieldDefinition() .name(\"mainCharacter\") .description(\"One of the main Simpson characters?\") .type(GraphQLBoolean)) .build(); ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:2","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#object"},{"categories":null,"content":" InterfaceInterfaces 是类型的抽象定义，哇塞！ SDL Example: //滑稽角色 interface ComicCharacter { name: String; } Java Example: GraphQLInterfaceType comicCharacter = newInterface() .name(\"ComicCharacter\") .description(\"An abstract comic character.\") .field(newFieldDefinition() .name(\"name\") .description(\"The name of the character.\") .type(GraphQLString)) .build(); ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:3","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#interface"},{"categories":null,"content":" UnionSDL Example: type Cat { name: String; lives: Int; } type Dog { name: String; bonesOwned: int; } union Pet = Cat | Dog 我擦，《猫狗大战》 Java Example: TypeResolver typeResolver = new TypeResolver() { @Override public GraphQLObjectType getType(TypeResolutionEnvironment env) { if (env.getObject() instanceof Cat) { return CatType; } if (env.getObject() instanceof Dog) { return DogType; } return null; } }; GraphQLUnionType PetType = newUnionType() .name(\"Pet\") .possibleType(CatType) .possibleType(DogType) .build(); GraphQLCodeRegistry codeRegistry = newCodeRegistry() .typeResolver(\"Pet\", typeResolver) .build(); ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:4","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#union"},{"categories":null,"content":" EnumSDL Example: enum Color { RED GREEN BLUE } Java Example: GraphQLEnumType colorEnum = newEnum() .name(\"Color\") .description(\"Supported colors.\") .value(\"RED\") .value(\"GREEN\") .value(\"BLUE\") .build(); ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:5","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#enum"},{"categories":null,"content":" ObjectInputTypeSDL Example: input Character { name: String } Java Example: GraphQLInputObjectType inputObjectType = newInputObject() .name(\"inputObjectType\") .field(newInputObjectField() .name(\"field\") .type(GraphQLString)) .build(); ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:6:6","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#objectinputtype"},{"categories":null,"content":" 类型关系和递归GraphQL支持递归（哇塞！）：比如一个Person类内部含有一个List\u003cFriend\u003e，我们可以声明一个类graphql-java并持有一个GraphQLTypeReference类型的属性。当schema创建时，GraphQLTypeReference会被实际的类型替换掉。(答不对题，文彩太差了)。 例如： GraphQLObjectType person = newObject() .name(\"Person\") .field(newFieldDefinition() .name(\"friends\") .type(GraphQLList .list(GraphQLTypeReference.typeRef(\"Person\")) ) ) .build(); 当schema通过SDL创建时，不需要对递归类型做特殊处理，递归已经自动完成了。 所以你就可以不给出个SDL的例子吗，作者？ ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:7:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#类型关系和递归"},{"categories":null,"content":" Schema SDL 的模块化一个巨大的schema文件是不方便浏览的（我想起了操哥写过的300行的函数和嵌套了7层的if）。我们可以通过两种技术使之模块化。 NO.1 在逻辑单元(java代码)中合并多个Schema SDL文件。 SchemaParser schemaParser = new SchemaParser(); SchemaGenerator schemaGenerator = new SchemaGenerator(); File schemaFile1 = loadSchema(\"starWarsSchemaPart1.graphqls\"); File schemaFile2 = loadSchema(\"starWarsSchemaPart2.graphqls\"); File schemaFile3 = loadSchema(\"starWarsSchemaPart3.graphqls\"); TypeDefinitionRegistry typeRegistry = new TypeDefinitionRegistry(); // each registry is merged into the main registry typeRegistry.merge(schemaParser.parse(schemaFile1)); typeRegistry.merge(schemaParser.parse(schemaFile2)); typeRegistry.merge(schemaParser.parse(schemaFile3)); GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, buildRuntimeWiring()); NO.2 Graphql SDL的类型系统针对多模块具备了另一个构造函数，你可以使用type extensions去把额外的field和insterfaces添加到类型中。 想象你开始的时候写了这么个type： type Human { id: ID! name: String! } 在另一部分文件中可以通过extend这个type来添加更多的图形。 extend type Human implements Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! } 你可以添加更多文件，它们最终会被整合到一起（不允许重复定义字段）。 extend type Human { homePlanet: String } 最终当所有type的继承者汇集到一起时，在运行时中type会变成这个样子： type Human implements Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! homePlanet: String } 这在顶级中很有用，你可以使用继承来向顶级的schema「query」中添加新的字段。团队开发中可以采用这种形式来向所有的query默认提供顶级query。 schema { query: CombinedQueryFromMultipleTeams } type CombinedQueryFromMultipleTeams { createdTimestamp: String } # maybe the invoicing system team puts in this set of attributes extend type CombinedQueryFromMultipleTeams { invoicing: Invoicing } # and the billing system team puts in this set of attributes extend type CombinedQueryFromMultipleTeams { billing: Billing } # and so and so forth extend type CombinedQueryFromMultipleTeams { auditing: Auditing } ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:8:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#schema-sdl-的模块化"},{"categories":null,"content":" 订阅支持(哇塞！)订阅允许你跑个query，并且持续监听这个query返回对象的变化。（这个牛逼了，但是有可能是靠长链接维持的，如果是的话开销就有点大了） subscription foo { # normal graphql query } 具体请查看Subscriptions。 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:9:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#订阅支持哇塞"},{"categories":null,"content":" 后记终于翻译完了，作者文彩比较渣，所以翻译的有点累。下一篇准备翻译这个Subscription，看看它的订阅到底是怎么回事。当然在此之前，需要对本篇翻译二次回顾，消化吸收。所以下一篇翻译不知道什么时候能搞出来了。 翻译完之后的第一次校稿，发现单纯阅读这个Schema篇根本理解不了。原因是按照demo跑完入门代码后，并没有好好阅读理解逻辑，然后中间因为来活了，中断了学习和翻译，特么尴尬了。下一篇还是从quick start开始吧。 ","date":"2021-01-19","objectID":"/graphql-java%E4%B8%80schema/:10:0","series":null,"tags":["GraphQL"],"title":"GraphQl-Java(一)Schema","uri":"/graphql-java%E4%B8%80schema/#后记"},{"categories":null,"content":" 版本差异 版本 特点 JDK1.7 数组+单向链 JDK1.8 数组+单向链+红黑树 jdk1.7中，数组是HashMap的主体，而链表是为了解决哈希冲突而存在的。当链表过长，回严重影响性能，所以在1.8中，当链表超过8且数据总量超过64会转成红黑树： 链表超过8，且数据总量超过64会转成红黑树； 如果数组长度小于64，会优先扩容，以减少搜索时间。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:1:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#版本差异"},{"categories":null,"content":" 默认加载因子","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:2:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#默认加载因子"},{"categories":null,"content":" Java中的二进制","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#java中的二进制"},{"categories":null,"content":" int的容量我们一般使用的int是32位整型，占用4字节。在计算机中是以二进制来储存的，共有32位。 假设我们创建一个int i = 10，10的二进制是1010，一共只有4位，在计算机中会用0把前面补齐，满足32位存储，所以实际上计算机中储存的是： 00000000 00000000 00000000 00001010 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:1","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#int的容量"},{"categories":null,"content":" 源码，反码，补码 源码一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位改为1，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。 10000000 00000000 00000000 00000101 是 -5的 原码。 反码正数的反码与源码相同，负数的反码为对该数的原码除符号位外各位取反。 也就是原为1，得0；原为0，得1。（1变0; 0变1）。 5的反码：00000000 00000000 00000000 00000101 -5的反码：11111111 11111111 11111111 11111010 补码正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1。 5的补码：00000000 00000000 00000000 00000101 -5的补码：11111111 11111111 11111111 11111011 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:2","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#源码反码补码"},{"categories":null,"content":" 源码，反码，补码 源码一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位改为1，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。 10000000 00000000 00000000 00000101 是 -5的 原码。 反码正数的反码与源码相同，负数的反码为对该数的原码除符号位外各位取反。 也就是原为1，得0；原为0，得1。（1变0; 0变1）。 5的反码：00000000 00000000 00000000 00000101 -5的反码：11111111 11111111 11111111 11111010 补码正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1。 5的补码：00000000 00000000 00000000 00000101 -5的补码：11111111 11111111 11111111 11111011 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:2","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#源码"},{"categories":null,"content":" 源码，反码，补码 源码一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位改为1，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。 10000000 00000000 00000000 00000101 是 -5的 原码。 反码正数的反码与源码相同，负数的反码为对该数的原码除符号位外各位取反。 也就是原为1，得0；原为0，得1。（1变0; 0变1）。 5的反码：00000000 00000000 00000000 00000101 -5的反码：11111111 11111111 11111111 11111010 补码正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1。 5的补码：00000000 00000000 00000000 00000101 -5的补码：11111111 11111111 11111111 11111011 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:2","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#反码"},{"categories":null,"content":" 源码，反码，补码 源码一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位改为1，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。 10000000 00000000 00000000 00000101 是 -5的 原码。 反码正数的反码与源码相同，负数的反码为对该数的原码除符号位外各位取反。 也就是原为1，得0；原为0，得1。（1变0; 0变1）。 5的反码：00000000 00000000 00000000 00000101 -5的反码：11111111 11111111 11111111 11111010 补码正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1。 5的补码：00000000 00000000 00000000 00000101 -5的补码：11111111 11111111 11111111 11111011 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:2","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#补码"},{"categories":null,"content":" Java中对负数的处理在二进制里，是用0和1来表示正负的，最高位为符号位，最高位为1代表负数，最高位为0代表正数。 计算机以补码的形式存储数据。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:3","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#java中对负数的处理"},{"categories":null,"content":" 计算方式 正数：绝对值的二进制； 负数：绝对值转二进制，高位改为1，得到反码，再把反码+1得到补码。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:3:4","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#计算方式"},{"categories":null,"content":" Java移位操作平时看源码总遇到几个符号，很是阻碍我学习，所以趁这次回顾HashMap的源码的机会，顺便把移位也复习一下吧。 « 左移位，将操作数向左移动指定的位数，并在低位补0； \u003e\u003e 有符号右移位，将操作数向右移动指定的位数，若符号为正，则在高位插入0；若符号为负，则在高位插入1； \u003e» 无符号右移位，无论正负，都在高位插入0。 我们以一个负数举例：int i = -10，分别求i左移位2、有符号右移位2和无符号右移位2后的值。 左移位：先把i=-10换算成二进制后的值为-1010，然后左移两位，低位用0补上，得到值为-101000. 有符号右移位：先把i=-10换算成二进制后的值为111111111111111111111111111 10110，然后开始右移，但由于空间不够，所以末尾的10就会被舍去，所以得到值为-10，因为符号为负，所以高位用1补上。 计算机的移位计算比乘除运算效率更高，所以Java源码中很常见移位操作。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:4:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#java移位操作"},{"categories":null,"content":" Java的\u0026操作符作用：如果相对应位都是1，则结果为1，否则为0。 实例： public static void main(String[] args) throws Exception { int i = 11; int j = 21; System.out.println(Integer.toBinaryString(i)); System.out.println(Integer.toBinaryString(j)); System.out.println(Integer.toBinaryString(i \u0026 j)); } 输出： 1011 10101 1 大概了解一下就行，反正还是不会算。。。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:5:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#java的操作符"},{"categories":null,"content":" 源码解读 一开始看的是JDK1.8的源码，好复杂，所以特意下载了JDK1.7的源码开始学习，以下都是基于1.7的。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#源码解读"},{"categories":null,"content":" 类定义，支持克隆和序列化 public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable { 这里要提以下，HashMap遵循Map、Cloneable、Serializable，所以支持克隆，支持序列化。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:1","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#类定义支持克隆和序列化"},{"categories":null,"content":" 核心静态内部类——单向链 static class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { //自己的key final K key; //自己的值 V value; //下一节点 Entry\u003cK,V\u003e next; //自己的哈希 int hash; /** * 构造方法 */ Entry(int h, K k, V v, Entry\u003cK,V\u003e n) { ... } public final K getKey() { ... } public final V getValue() { ... } public final V setValue(V newValue) { ... } public final boolean equals(Object o) { ... } public final int hashCode() { ... } public final String toString() { ... } } 源码中不重要的地方我都省略了。 从源码来看，Entry\u003ckey,v\u003e类是一个单向链表结构。 再一次看到这个Entry，不禁让我想起了前段时间研究AQS里面的Node。Node是一个双向链表形式的CLH队列，所以类名用Node表示，意思是队列中的一个节点；但是在HashMap中的Entry是一个单向链表，所以一个Entry只能充当入口来用。实在很佩服Java的作者，能把类名起的这么贴切！ ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:2","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#核心静态内部类单向链"},{"categories":null,"content":" 构造方法JDK1.7版本中构造方法共有4个，但是核心的只有两个，我们主要研究第一个： //常量，实际数值为1后面30个0,是个很大的数字，用于表示初始容量的极限 static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30; /** *核心构造方法一 * @param initialCapacity 初始容量 * @param loadFactor 加载因子 **/ public HashMap(int initialCapacity, float loadFactor){ //初始容量不能小于0 if (initialCapacity \u003c 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); //初始容量降为极限 if (initialCapacity \u003e MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //加载因子不允许小于0，必须为数字 if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; //调用钩子方法，用来hook子类，本身没什么作用，需要子类重写才有用，但是我们一般也不重写。 init(); } 构造方法最大的作用就是初始化initialCapacity初始容量和loadFactor加载因子，这两个字段有什么用，下面会介绍到。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:3","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#构造方法"},{"categories":null,"content":" put方法 //节点数组 transient Entry\u003cK,V\u003e[] table = (Entry\u003cK,V\u003e[]) EMPTY_TABLE; public V put(K key, V value) { //初始化table数组 if (table == EMPTY_TABLE) { inflateTable(threshold); } //key为null的处理方式 if (key == null) return putForNullKey(value); //下面是key不为null的处理方式 //计算key的哈希码 int hash = hash(key); //找到hash码在数组中的位置，也就是查询定位 int i = indexFor(hash, table.length); //遍历该位置的单向链，找到对应的key，赋值value for (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //如果一直找不到对应的key，就添加一个节点 addEntry(hash, key, value, i); return null; } /** * key为null时的处理方式,只是没有计算哈希，而是直接从 * table[0]位置开始遍历链表 */ private V putForNullKey(V value) { for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(0, null, value, 0); return null; } /** * 根据hash找到数组中的对应位置 */ static int indexFor(int h, int length) { return h \u0026 (length-1); } /** * 添加新节点 */ void addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) { //如果当前size大于扩容因子，则扩容两倍 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } /** * 创建新节点，并插入队首 */ void createEntry(int hash, K key, V value, int bucketIndex) { Entry\u003cK,V\u003e e = table[bucketIndex]; table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e); size++; } /** * 重新计算容量 */ void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } Put方法总结 先看看流程从Put方法可以看到，HashMap的核心是table数组，数组的元素是Entry这个单向链，这种结构被称之为散列表。 在存放数组时，使用hash \u0026 (length-1)的方式使数组均匀分布，提高查询效率。 为何要均匀分布？因为查询时首先找到数组的对应下标，然后for循环对应的单向链。均匀分布使得链表长度尽可能小，减少了遍历次数，提高了效率。 如果查询没有获取结果，并且当前的size大于扩容因子，HashMap会先调用resize()方法进行扩容翻倍，最后创建一个新节点，插入队首， HashMap允许key、value为null，当key为null时，会默认存在table[0]。 当key不为空时，在put时会依据key的哈希值找到数组中的对应位置，然后for循环遍历该位置的链表找到key，再进行储存。 细说扩容HashMap中table数组初始长度是16（默认状况下），而默认加载因子的值为0.75f，所以默认情况，当table的长度超过16 * 0.75 = 12的时候，再继续put就会翻倍扩容成32，然后再重新计算每个元素在数组中的位置，这是非常耗费性能的。 为了解决以上问题，我们在使用HashMap的时候，应该尽可能避免扩容，所以应该在初始容量上面做文章： 比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 \u003c 1000, 也就是说为了让0.75 * size \u003e 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了\u0026的问题，也避免了resize的问题。 摘自https://blog.csdn.net/sd_csdn_scy/article/details/55510453 但是这样不可避免的出现了内存浪费。 初始容量设置 必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。 尽量在乘以0.75后大于预估元素数量。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:4","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#put方法"},{"categories":null,"content":" put方法 //节点数组 transient Entry[] table = (Entry[]) EMPTY_TABLE; public V put(K key, V value) { //初始化table数组 if (table == EMPTY_TABLE) { inflateTable(threshold); } //key为null的处理方式 if (key == null) return putForNullKey(value); //下面是key不为null的处理方式 //计算key的哈希码 int hash = hash(key); //找到hash码在数组中的位置，也就是查询定位 int i = indexFor(hash, table.length); //遍历该位置的单向链，找到对应的key，赋值value for (Entry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //如果一直找不到对应的key，就添加一个节点 addEntry(hash, key, value, i); return null; } /** * key为null时的处理方式,只是没有计算哈希，而是直接从 * table[0]位置开始遍历链表 */ private V putForNullKey(V value) { for (Entry e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(0, null, value, 0); return null; } /** * 根据hash找到数组中的对应位置 */ static int indexFor(int h, int length) { return h \u0026 (length-1); } /** * 添加新节点 */ void addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) { //如果当前size大于扩容因子，则扩容两倍 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } /** * 创建新节点，并插入队首 */ void createEntry(int hash, K key, V value, int bucketIndex) { Entry e = table[bucketIndex]; table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e); size++; } /** * 重新计算容量 */ void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } Put方法总结 先看看流程从Put方法可以看到，HashMap的核心是table数组，数组的元素是Entry这个单向链，这种结构被称之为散列表。 在存放数组时，使用hash \u0026 (length-1)的方式使数组均匀分布，提高查询效率。 为何要均匀分布？因为查询时首先找到数组的对应下标，然后for循环对应的单向链。均匀分布使得链表长度尽可能小，减少了遍历次数，提高了效率。 如果查询没有获取结果，并且当前的size大于扩容因子，HashMap会先调用resize()方法进行扩容翻倍，最后创建一个新节点，插入队首， HashMap允许key、value为null，当key为null时，会默认存在table[0]。 当key不为空时，在put时会依据key的哈希值找到数组中的对应位置，然后for循环遍历该位置的链表找到key，再进行储存。 细说扩容HashMap中table数组初始长度是16（默认状况下），而默认加载因子的值为0.75f，所以默认情况，当table的长度超过16 * 0.75 = 12的时候，再继续put就会翻倍扩容成32，然后再重新计算每个元素在数组中的位置，这是非常耗费性能的。 为了解决以上问题，我们在使用HashMap的时候，应该尽可能避免扩容，所以应该在初始容量上面做文章： 比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 \u003c 1000, 也就是说为了让0.75 * size \u003e 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了\u0026的问题，也避免了resize的问题。 摘自https://blog.csdn.net/sd_csdn_scy/article/details/55510453 但是这样不可避免的出现了内存浪费。 初始容量设置 必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。 尽量在乘以0.75后大于预估元素数量。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:4","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#put方法总结"},{"categories":null,"content":" put方法 //节点数组 transient Entry[] table = (Entry[]) EMPTY_TABLE; public V put(K key, V value) { //初始化table数组 if (table == EMPTY_TABLE) { inflateTable(threshold); } //key为null的处理方式 if (key == null) return putForNullKey(value); //下面是key不为null的处理方式 //计算key的哈希码 int hash = hash(key); //找到hash码在数组中的位置，也就是查询定位 int i = indexFor(hash, table.length); //遍历该位置的单向链，找到对应的key，赋值value for (Entry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //如果一直找不到对应的key，就添加一个节点 addEntry(hash, key, value, i); return null; } /** * key为null时的处理方式,只是没有计算哈希，而是直接从 * table[0]位置开始遍历链表 */ private V putForNullKey(V value) { for (Entry e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(0, null, value, 0); return null; } /** * 根据hash找到数组中的对应位置 */ static int indexFor(int h, int length) { return h \u0026 (length-1); } /** * 添加新节点 */ void addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) { //如果当前size大于扩容因子，则扩容两倍 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } /** * 创建新节点，并插入队首 */ void createEntry(int hash, K key, V value, int bucketIndex) { Entry e = table[bucketIndex]; table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e); size++; } /** * 重新计算容量 */ void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } Put方法总结 先看看流程从Put方法可以看到，HashMap的核心是table数组，数组的元素是Entry这个单向链，这种结构被称之为散列表。 在存放数组时，使用hash \u0026 (length-1)的方式使数组均匀分布，提高查询效率。 为何要均匀分布？因为查询时首先找到数组的对应下标，然后for循环对应的单向链。均匀分布使得链表长度尽可能小，减少了遍历次数，提高了效率。 如果查询没有获取结果，并且当前的size大于扩容因子，HashMap会先调用resize()方法进行扩容翻倍，最后创建一个新节点，插入队首， HashMap允许key、value为null，当key为null时，会默认存在table[0]。 当key不为空时，在put时会依据key的哈希值找到数组中的对应位置，然后for循环遍历该位置的链表找到key，再进行储存。 细说扩容HashMap中table数组初始长度是16（默认状况下），而默认加载因子的值为0.75f，所以默认情况，当table的长度超过16 * 0.75 = 12的时候，再继续put就会翻倍扩容成32，然后再重新计算每个元素在数组中的位置，这是非常耗费性能的。 为了解决以上问题，我们在使用HashMap的时候，应该尽可能避免扩容，所以应该在初始容量上面做文章： 比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 \u003c 1000, 也就是说为了让0.75 * size \u003e 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了\u0026的问题，也避免了resize的问题。 摘自https://blog.csdn.net/sd_csdn_scy/article/details/55510453 但是这样不可避免的出现了内存浪费。 初始容量设置 必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。 尽量在乘以0.75后大于预估元素数量。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:4","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#先看看流程"},{"categories":null,"content":" put方法 //节点数组 transient Entry[] table = (Entry[]) EMPTY_TABLE; public V put(K key, V value) { //初始化table数组 if (table == EMPTY_TABLE) { inflateTable(threshold); } //key为null的处理方式 if (key == null) return putForNullKey(value); //下面是key不为null的处理方式 //计算key的哈希码 int hash = hash(key); //找到hash码在数组中的位置，也就是查询定位 int i = indexFor(hash, table.length); //遍历该位置的单向链，找到对应的key，赋值value for (Entry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //如果一直找不到对应的key，就添加一个节点 addEntry(hash, key, value, i); return null; } /** * key为null时的处理方式,只是没有计算哈希，而是直接从 * table[0]位置开始遍历链表 */ private V putForNullKey(V value) { for (Entry e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(0, null, value, 0); return null; } /** * 根据hash找到数组中的对应位置 */ static int indexFor(int h, int length) { return h \u0026 (length-1); } /** * 添加新节点 */ void addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) { //如果当前size大于扩容因子，则扩容两倍 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } /** * 创建新节点，并插入队首 */ void createEntry(int hash, K key, V value, int bucketIndex) { Entry e = table[bucketIndex]; table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e); size++; } /** * 重新计算容量 */ void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } Put方法总结 先看看流程从Put方法可以看到，HashMap的核心是table数组，数组的元素是Entry这个单向链，这种结构被称之为散列表。 在存放数组时，使用hash \u0026 (length-1)的方式使数组均匀分布，提高查询效率。 为何要均匀分布？因为查询时首先找到数组的对应下标，然后for循环对应的单向链。均匀分布使得链表长度尽可能小，减少了遍历次数，提高了效率。 如果查询没有获取结果，并且当前的size大于扩容因子，HashMap会先调用resize()方法进行扩容翻倍，最后创建一个新节点，插入队首， HashMap允许key、value为null，当key为null时，会默认存在table[0]。 当key不为空时，在put时会依据key的哈希值找到数组中的对应位置，然后for循环遍历该位置的链表找到key，再进行储存。 细说扩容HashMap中table数组初始长度是16（默认状况下），而默认加载因子的值为0.75f，所以默认情况，当table的长度超过16 * 0.75 = 12的时候，再继续put就会翻倍扩容成32，然后再重新计算每个元素在数组中的位置，这是非常耗费性能的。 为了解决以上问题，我们在使用HashMap的时候，应该尽可能避免扩容，所以应该在初始容量上面做文章： 比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 \u003c 1000, 也就是说为了让0.75 * size \u003e 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了\u0026的问题，也避免了resize的问题。 摘自https://blog.csdn.net/sd_csdn_scy/article/details/55510453 但是这样不可避免的出现了内存浪费。 初始容量设置 必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。 尽量在乘以0.75后大于预估元素数量。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:4","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#细说扩容"},{"categories":null,"content":" put方法 //节点数组 transient Entry[] table = (Entry[]) EMPTY_TABLE; public V put(K key, V value) { //初始化table数组 if (table == EMPTY_TABLE) { inflateTable(threshold); } //key为null的处理方式 if (key == null) return putForNullKey(value); //下面是key不为null的处理方式 //计算key的哈希码 int hash = hash(key); //找到hash码在数组中的位置，也就是查询定位 int i = indexFor(hash, table.length); //遍历该位置的单向链，找到对应的key，赋值value for (Entry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //如果一直找不到对应的key，就添加一个节点 addEntry(hash, key, value, i); return null; } /** * key为null时的处理方式,只是没有计算哈希，而是直接从 * table[0]位置开始遍历链表 */ private V putForNullKey(V value) { for (Entry e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(0, null, value, 0); return null; } /** * 根据hash找到数组中的对应位置 */ static int indexFor(int h, int length) { return h \u0026 (length-1); } /** * 添加新节点 */ void addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) { //如果当前size大于扩容因子，则扩容两倍 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } /** * 创建新节点，并插入队首 */ void createEntry(int hash, K key, V value, int bucketIndex) { Entry e = table[bucketIndex]; table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e); size++; } /** * 重新计算容量 */ void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } Put方法总结 先看看流程从Put方法可以看到，HashMap的核心是table数组，数组的元素是Entry这个单向链，这种结构被称之为散列表。 在存放数组时，使用hash \u0026 (length-1)的方式使数组均匀分布，提高查询效率。 为何要均匀分布？因为查询时首先找到数组的对应下标，然后for循环对应的单向链。均匀分布使得链表长度尽可能小，减少了遍历次数，提高了效率。 如果查询没有获取结果，并且当前的size大于扩容因子，HashMap会先调用resize()方法进行扩容翻倍，最后创建一个新节点，插入队首， HashMap允许key、value为null，当key为null时，会默认存在table[0]。 当key不为空时，在put时会依据key的哈希值找到数组中的对应位置，然后for循环遍历该位置的链表找到key，再进行储存。 细说扩容HashMap中table数组初始长度是16（默认状况下），而默认加载因子的值为0.75f，所以默认情况，当table的长度超过16 * 0.75 = 12的时候，再继续put就会翻倍扩容成32，然后再重新计算每个元素在数组中的位置，这是非常耗费性能的。 为了解决以上问题，我们在使用HashMap的时候，应该尽可能避免扩容，所以应该在初始容量上面做文章： 比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 \u003c 1000, 也就是说为了让0.75 * size \u003e 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了\u0026的问题，也避免了resize的问题。 摘自https://blog.csdn.net/sd_csdn_scy/article/details/55510453 但是这样不可避免的出现了内存浪费。 初始容量设置 必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。 尽量在乘以0.75后大于预估元素数量。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:4","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#初始容量设置"},{"categories":null,"content":" get 方法 public V get(Object key) { if (key == null) return getForNullKey(); Entry\u003cK,V\u003e entry = getEntry(key); return null == entry ? null : entry.getValue(); } /** * key为null时的处理方式 */ private V getForNullKey() { if (size == 0) { return null; } //还是直接去赵table[0]，然后遍历 for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } final Entry\u003cK,V\u003e getEntry(Object key) { if (size == 0) { return null; } //计算哈希值 int hash = (key == null) ? 0 : hash(key); //查找哈希 for (Entry\u003cK,V\u003e e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } return null; } get方法基本就没啥可说的了。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:6:5","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#get-方法"},{"categories":null,"content":" 序列化一开始看到类声明时，知道HashMap是支持序列化的，但是后来看到了： transient Entry\u003cK,V\u003e[] table = (Entry\u003cK,V\u003e[]) EMPTY_TABLE; table是transient的，是不允许序列化的。而且Entry是不支持序列化的，所以我就开始想HashMap是怎么进行序列化的呢？ ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:7:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#序列化"},{"categories":null,"content":" writeObject private void writeObject(java.io.ObjectOutputStream s)throws IOException { // 写入容量、加载因子等信息 s.defaultWriteObject(); // 写入table数组当前的长度 if (table==EMPTY_TABLE) { s.writeInt(roundUpToPowerOf2(threshold)); } else { s.writeInt(table.length); } // 写入当前元素数量 s.writeInt(size); // 遍历写入所有元素的KV if (size \u003e 0) { for(Map.Entry\u003cK,V\u003e e : entrySet0()) { s.writeObject(e.getKey()); s.writeObject(e.getValue()); } } } ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:7:1","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#writeobject"},{"categories":null,"content":" readObject private void readObject(java.io.ObjectInputStream s)throws IOException, ClassNotFoundException{ s.defaultReadObject(); if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) { throw new InvalidObjectException(\"Illegal load factor: \" +loadFactor); } // set other fields that need values table = (Entry\u003cK,V\u003e[]) EMPTY_TABLE; // Read in number of buckets s.readInt(); // ignored. // Read number of mappings int mappings = s.readInt(); if (mappings \u003c 0) throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); // capacity chosen by number of mappings and desired load (if \u003e= 0.25) int capacity = (int) Math.min( mappings * Math.min(1 / loadFactor, 4.0f), // we have limits... HashMap.MAXIMUM_CAPACITY); // allocate the bucket array; if (mappings \u003e 0) { inflateTable(capacity); } else { threshold = capacity; } init(); // Give subclass a chance to do its thing. // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u003c mappings; i++) { K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); } } ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:7:2","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#readobject"},{"categories":null,"content":" 序列化总结HashMap的序列化和反序列化原理就是遍历读写table数组中的各个Entry元素的key和value，采用了ObjectInputStream.readObject()和ObjectInputStream.writeObject()方法。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:7:3","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#序列化总结"},{"categories":null,"content":" 知识点速记 储存结构： JDK版本 结构 特点 1.7 散列表 链表太长影响查询性能 1.8 散列表+红黑树 链表长度超过8并且数据总量超过64转红黑树 核心字段： 字段 作用 transient Entry[] table 主要存储，散列表 transient int size entry的个数 int threshold 阈值，等于table.length*loadFactory，table数组长度超过这个值就会扩容。 loadFactory 加载因子 modCount 修改次数 初始容量： 必须是2的整数幂，可减少哈希冲突，使数据均匀分布，提高查询效率，并且可以避免空间浪费。 尽量在乘以0.75后大于预估元素数量。 put过程： 先计算key的hash值，再根据hash \u0026 (length-1)找到key再table中的位置，遍历该位置上的链表找到对应的key；如果没有找到key，则resize()方法扩容，然后创建新的entry插入队首。 关于扩容： 条件：调用put方法时，size\u003ethreshold*loadFactory； 方式：创建两倍长度的新数组，然后for嵌套while循环一个个的倒腾。 关于序列化： 自己实现了writeObject和readObject方法，通过反射调用；优先处理那几个核心字段，最后遍历entrySet分别读写key和value。 关于EntrySet： EntrySet是HashMap的内部类，所以可以访问HashMap的成员，提供nextEntry方法，遍历的还是HashMap的散列表。 ","date":"2021-01-12","objectID":"/hashmap%E9%80%9F%E8%AE%B0/:8:0","series":null,"tags":["java"],"title":"HashMap速记","uri":"/hashmap%E9%80%9F%E8%AE%B0/#知识点速记"},{"categories":null,"content":" 由于我对GC的理解一直不好，总是记不住，所以本篇博客完全撸了一颗苹果的博客,十分感谢原作者！ ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:0:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#"},{"categories":null,"content":" 什么是垃圾Java进程运行后，如果某个类型(方法区中的类信息，堆中的类对象)，常量，对象，如果不可用，就成了垃圾。 提炼一下，垃圾的分类： 类型 常量 变量 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:1:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#什么是垃圾"},{"categories":null,"content":" 谁负责具体的回收GC线程负责具体回收工作，GC线程是个守护线程。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:2:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#谁负责具体的回收"},{"categories":null,"content":" 回收的时机创建对象时，需要再对应的内存区域分配内存空间，如果该区域的空间不足，就会触发该区域的GC。 System.gc()方法可建议GC，但是不能确保一定GC。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:3:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#回收的时机"},{"categories":null,"content":" 垃圾判定算法","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#垃圾判定算法"},{"categories":null,"content":" 引用计数法给对象增加一个引用计数器，每当增加一个引用时，计数器自加1；当引用失效时，计数器自减1；当计数器为0时被判定为垃圾。 问题：当出现循环引用会无法GC。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:1","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#引用计数法"},{"categories":null,"content":" 可达性分析法以GC Root对象作为起点，向下搜索，搜索的路径佳作“引用链”。当一个对象到GC Roots没有任何引用链相连时（不可达）,说明这个对象是垃圾。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:2","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#可达性分析法"},{"categories":null,"content":" Java的四种引用类型 强引用 Object o = new Object(); 只要是new出来的都是强引用，只要可达，就不能被回收，就算内存不足，JVM也只会抛出OOM异常。 软引用 SoftReference\u003cObject\u003e sr = new SoftReference\u003c\u003e(new Object()); 即使是可达的,但是一旦该区域空间不足(OOM)，就会被GC。 弱引用 WeakReference\u003cObject\u003e sr = new WeakReference\u003c\u003e(new Object()); 即使是可达的，但是一旦该区域发生GC，也会被同时GC掉。 虚引用这货基本不用，随时都有可能被回收，看心情？ 回收优先级虚引用-\u003e弱引用-\u003e软引用-\u003e强引用 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:3","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#java的四种引用类型"},{"categories":null,"content":" Java的四种引用类型 强引用 Object o = new Object(); 只要是new出来的都是强引用，只要可达，就不能被回收，就算内存不足，JVM也只会抛出OOM异常。 软引用 SoftReference sr = new SoftReference\u003c\u003e(new Object()); 即使是可达的,但是一旦该区域空间不足(OOM)，就会被GC。 弱引用 WeakReference sr = new WeakReference\u003c\u003e(new Object()); 即使是可达的，但是一旦该区域发生GC，也会被同时GC掉。 虚引用这货基本不用，随时都有可能被回收，看心情？ 回收优先级虚引用-\u003e弱引用-\u003e软引用-\u003e强引用 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:3","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#强引用"},{"categories":null,"content":" Java的四种引用类型 强引用 Object o = new Object(); 只要是new出来的都是强引用，只要可达，就不能被回收，就算内存不足，JVM也只会抛出OOM异常。 软引用 SoftReference sr = new SoftReference\u003c\u003e(new Object()); 即使是可达的,但是一旦该区域空间不足(OOM)，就会被GC。 弱引用 WeakReference sr = new WeakReference\u003c\u003e(new Object()); 即使是可达的，但是一旦该区域发生GC，也会被同时GC掉。 虚引用这货基本不用，随时都有可能被回收，看心情？ 回收优先级虚引用-\u003e弱引用-\u003e软引用-\u003e强引用 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:3","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#软引用"},{"categories":null,"content":" Java的四种引用类型 强引用 Object o = new Object(); 只要是new出来的都是强引用，只要可达，就不能被回收，就算内存不足，JVM也只会抛出OOM异常。 软引用 SoftReference sr = new SoftReference\u003c\u003e(new Object()); 即使是可达的,但是一旦该区域空间不足(OOM)，就会被GC。 弱引用 WeakReference sr = new WeakReference\u003c\u003e(new Object()); 即使是可达的，但是一旦该区域发生GC，也会被同时GC掉。 虚引用这货基本不用，随时都有可能被回收，看心情？ 回收优先级虚引用-\u003e弱引用-\u003e软引用-\u003e强引用 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:3","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#弱引用"},{"categories":null,"content":" Java的四种引用类型 强引用 Object o = new Object(); 只要是new出来的都是强引用，只要可达，就不能被回收，就算内存不足，JVM也只会抛出OOM异常。 软引用 SoftReference sr = new SoftReference\u003c\u003e(new Object()); 即使是可达的,但是一旦该区域空间不足(OOM)，就会被GC。 弱引用 WeakReference sr = new WeakReference\u003c\u003e(new Object()); 即使是可达的，但是一旦该区域发生GC，也会被同时GC掉。 虚引用这货基本不用，随时都有可能被回收，看心情？ 回收优先级虚引用-\u003e弱引用-\u003e软引用-\u003e强引用 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:3","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#虚引用"},{"categories":null,"content":" Java的四种引用类型 强引用 Object o = new Object(); 只要是new出来的都是强引用，只要可达，就不能被回收，就算内存不足，JVM也只会抛出OOM异常。 软引用 SoftReference sr = new SoftReference\u003c\u003e(new Object()); 即使是可达的,但是一旦该区域空间不足(OOM)，就会被GC。 弱引用 WeakReference sr = new WeakReference\u003c\u003e(new Object()); 即使是可达的，但是一旦该区域发生GC，也会被同时GC掉。 虚引用这货基本不用，随时都有可能被回收，看心情？ 回收优先级虚引用-\u003e弱引用-\u003e软引用-\u003e强引用 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:4:3","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#回收优先级"},{"categories":null,"content":" GC的位置 从上图中可以看到JVMM划分成了两大块三大区和三小区： 年轻代GC非常频繁，回收效率也高。 老年代GC速度比年轻代慢10倍以上。 永生代GC频率非常低，在jdk1.7叫方法区，1.8叫原空间。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:5:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#gc的位置"},{"categories":null,"content":" GC算法","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:6:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#gc算法"},{"categories":null,"content":" 标记清除法先标记不可达对象，再一次性释放所有标记过的对象。 特点： 标记时只要找到一个引用就可证明对象存活着； 不移动对象位置； 由于两个阶段都采用遍历+递归的形式，所以两个阶段效率都不高； 回收后存在内存碎片，造成空间浪费。 内存碎片：当创建非常大的对象时，一块区域不够用，所以JVM会给该对象分配另一块相连的区域；而GC时只会回收其中一块区域，另一块区域不会被回收，就形成了碎片。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:6:1","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#标记清除法"},{"categories":null,"content":" 复制算法（新生代采用）将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存需要进行垃圾回收时，会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。 特点： 效率高 没有碎片问题 从原理上看浪费了一半空间 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:6:2","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#复制算法新生代采用"},{"categories":null,"content":" 标记整理算法（老年代采用）标记出存活的对象，然后移动到另一块区域，再清理剩余内存。 特点： 如果存活对象过多，会产生较多复制操作，导致效率低； 没有碎片。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:6:3","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#标记整理算法老年代采用"},{"categories":null,"content":" 分代收集算法（JVM的整体算法）就是分成若干区域，什么新生代、老年代、永生代，然后进一步细分区域，每个区域采用不同的GC算法： 新生代：对象生存周期短，每次回收会释放大量对象，所以采用复制算法； 老年代：对象存活率较高，没有额外的空间进行分配担保，所以采用标记整理算法。 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:6:4","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#分代收集算法jvm的整体算法"},{"categories":null,"content":" 鸣谢：老莫8 一颗苹果 ","date":"2021-01-12","objectID":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/:7:0","series":null,"tags":["java"],"title":"Java的GC机制","uri":"/java%E7%9A%84gc%E6%9C%BA%E5%88%B6/#鸣谢"},{"categories":null,"content":" java是引用传递还是值传递？ 结论，Java就是值传递，只不过在传递引用类型的时候，会把对象的引用地址当作值来传递。 首先声明一个引用类型： private static class MyObject { private MyObject subObject; private String content; private int num; public MyObject(String content, int num) { this.content = content; this.num = num; } public MyObject(String content, int num, String subContent, int subnum) { this.content = content; this.num = num; this.subObject = new MyObject(subContent, subnum); } @Override public String toString() { StringBuilder sb = new StringBuilder(\"当前的content是:\" + content + \"\\t当前的num是\" + num); if (subObject != null) { sb.append(\"\\n属性的content是:\" + subObject.content + \"\\t属性的num是:\" + subObject.num); } return sb.toString(); } } ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:0","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#java是引用传递还是值传递"},{"categories":null,"content":" 形参为一般类型，对实参无影响 public static void main(String[] args) throws Exception { int num = 0; test(num); System.out.println(\"经test方法之后,num值为：\\n\" + num); } 输出： 经test方法之后,num值为： 0 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:1","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#形参为一般类型对实参无影响"},{"categories":null,"content":" 形参为引用类型，对实参无影响 public static void main(String[] args) throws Exception { MyObject obj = new MyObject(\"我是第一层\", 10, \"我是第二层\", 20); test(obj); System.out.println(\"经test方法之后,obj对象为：\\n\" + String.valueOf(obj)); } /** * 我是方法 * @param myobj */ private static void test(MyObject myobj) { myobj = null; } 输出： 经test方法之后,obj对象为： 当前的content是:我是第一层 当前的num是10 属性的content是:我是第二层 属性的num是:10 可以看到在方法中给形参设置为null，但是依然可以输出。 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:2","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#形参为引用类型对实参无影响"},{"categories":null,"content":" 改变形参的一般类型字段，会改变实参的字段 private static void test(MyObject myobj) { myobj.num++; } 输出： 经test方法之后,obj对象为： 当前的content是:我是第一层 当前的num是11 属性的content是:我是第二层 属性的num是:20 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:3","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#改变形参的一般类型字段会改变实参的字段"},{"categories":null,"content":" 改变形参的引用字段，也会改变实参的字段 private static void test(MyObject myobj) { myobj.content = null; } 输出： 经test方法之后,obj对象为： 当前的content是:null 当前的num是10 属性的content是:我是第二层 属性的num是:20 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:4","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#改变形参的引用字段也会改变实参的字段"},{"categories":null,"content":" 改变形参引用字段内部的一般字段，实参会变 private static void test(MyObject myobj) { myobj.subObject.num++; } 输出： 经test方法之后,obj对象为： 当前的content是:我是第一层 当前的num是10 属性的content是:我是第二层 属性的num是:21 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:5","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#改变形参引用字段内部的一般字段实参会变"},{"categories":null,"content":" 改变形参引用字段内部的引用字段，实参会变 private static void test(MyObject myobj) { myobj.subObject.content=null; } 输出： 当前的content是:我是第一层 当前的num是10 属性的content是:null 属性的num是:20 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:6","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#改变形参引用字段内部的引用字段实参会变"},{"categories":null,"content":" 总结：java是拷贝传递，如果形参是引用类型，则改变形参对实参无任何影响；而改变形参内部的属性，则会对实参产生影响。 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:1:7","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#总结"},{"categories":null,"content":" try里面return，是return先执行还是finally先执行？ public static void main(String[] args) throws Exception { boolean result = test(); System.out.print(\"收到结果为：\" + result); } private static boolean test() { try { System.out.println(\"执行到了return\"); return true; } finally { System.out.println(\"执行到了finally\"); } } 输出： 执行到了return 执行到了finally 收到结果为：true 从输出上看，应该是先return再执行finally，但是… 当我在return处打上断点，在finally内部输出那一行也打上断点，调试时惊喜的发现，先执行try内的输出，然后自动跳过了return语句直接在finally内部的断点停了，当我继续运行，发现它又回到了return语句，最后才离开方法。 ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:2:0","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#try里面return是return先执行还是finally先执行"},{"categories":null,"content":" try和finally都return public static void main(String[] args) throws Exception { boolean result = test(); System.out.println(\"收到结果为：\" + result); } private static boolean test() { try { System.out.println(\"执行到了return\"); return true; } finally { System.out.println(\"执行到了finally\"); return false; } } 当然到了现在，可以不相信输出了，要以断点顺序为准。 当try和finally中都有return时，Java再一次给了我惊喜： 首先执行了try中的return，然后又执行了finally中的return，最后才返回结果，并且是以finally中的return为准！ 结论： finally中没有return，先finally再try的return； finally中有return，先try的return，再finally中的return，结构以后执行的return为准。 所以Java无论如何都是先finally再return！ ","date":"2021-01-12","objectID":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/:2:1","series":null,"tags":["java"],"title":"Java趣味题","uri":"/java%E8%B6%A3%E5%91%B3%E9%A2%98/#try和finally都return"},{"categories":null,"content":"趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。 ","date":"2021-01-12","objectID":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/:0:0","series":null,"tags":["spring","cloud","security","oauth2.0"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/#"},{"categories":null,"content":" OAuth2.0 四种授权模式 模式 refresh_token 用途 authorization_code true 允许用户通过第三方应用登录自身获取资源，前提是用户已登录自身服务。 implicit false 简化模式，跳过了获取授权码过程。 password true 账号密码模式，用于高度授信场景，比如登录微信、QQ自身｜ client_credentials false 客户端模式，用于高度授信的其他服务，如企业自己的其他服务，或高度加密的硬件客户端，登录过程完全不需要用户操作。 ","date":"2021-01-12","objectID":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/:1:0","series":null,"tags":["spring","cloud","security","oauth2.0"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/#oauth20-四种授权模式"},{"categories":null,"content":" Security、ResourceServer、ClientServer各自的作用和关系 SpringSecurity:鉴权方式的配置，比如哪些接口需要鉴权，还要排除调登录注册和登出接口等等。还有用户信息的存放、认证，Token Provider 的配置等等。 ResourceServer:是指需要收到保护的资源。比我的一个服务有大量接口，需要采用Security保护，那这个服务就是个ResourceServer。怎么保护呢？通过集成SpringSecurity来保护。每当有请求要访问我们的接口，ResourceServer都需要向token_provider验证token的有效性。 ClientServer:是用来在服务端获取access_token和refresh_token用的，并且可以自动使用refresh_token去刷新access_token。向谁获取？可以是微信、微博、github等等。 TokenProvider:用来提供token的服务。比如微信、支付宝、github,也可以是自己搭建的Keycloak服务。 ","date":"2021-01-12","objectID":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/:2:0","series":null,"tags":["spring","cloud","security","oauth2.0"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/#securityresourceserverclientserver各自的作用和关系"},{"categories":null,"content":" 网关统一用户认证很简单，说白了就是在Gateway集成Security，这样以来Gateway就成了一个ResourceServer，并且可以为所有路由做用户认证。 但是！具体的鉴权还是需要各个服务自己去做，毕竟网关不知道具体的服务需要具体哪一项权限。 ","date":"2021-01-12","objectID":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/:3:0","series":null,"tags":["spring","cloud","security","oauth2.0"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/#网关统一用户认证"},{"categories":null,"content":" FAQ","date":"2021-01-12","objectID":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/:4:0","series":null,"tags":["spring","cloud","security","oauth2.0"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/#faq"},{"categories":null,"content":" 直接使用微信、支付宝的token来做自己的有效性验证可以码？当然可以！只不过，人家的token验证只有在调用他们的服务时才会生效，如果不调用他们的服务，我们自己不知道人家的token是否有效（超时过期）。 那么该怎么实现？当我们自己的接口被访问时，先去调个人家的服务，最好是无关痛痒的服务，单纯为了验证人家的token是否有效。 但是这样以来就大大降低了接口的请求速度，而且也不优雅，平衡下来还不许自己搭建帐号体系来的实在！ ","date":"2021-01-12","objectID":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/:4:1","series":null,"tags":["spring","cloud","security","oauth2.0"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/#直接使用微信支付宝的token来做自己的有效性验证可以码"},{"categories":null,"content":" 采用授权码方式让自己的客户端访问自己服务？这就叫脱了裤子放屁，为安全而安全！ 用微信的第三方登录举例，假如我们没有登录微信，当使用微信时，依然需要用帐号密码方式先登录微信。因为你在操作授权登录时，是先调起微信的页面或者它SDK的页面，是在人家的页面里面玩的，对于微信来讲，他自己的页面就是高度授信的，所以追本溯源，授权码登录方式还是基于帐号密码之上的。 ","date":"2021-01-12","objectID":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/:4:2","series":null,"tags":["spring","cloud","security","oauth2.0"],"title":"对SpringGateway+Security+OAuth2.0的认识","uri":"/%E5%AF%B9springgateway-security-oauth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/#采用授权码方式让自己的客户端访问自己服务"},{"categories":null,"content":" 死锁死锁是指多个的线程在执行过程中，由于竞争资源或者由于批次通信而造成的一种阻塞现象。若无外力作用，他们都将无法推进下去。 ","date":"2021-01-07","objectID":"/cas/:1:0","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#死锁"},{"categories":null,"content":" 悲观锁与乐观锁 悲观锁: 假定会发生并发冲突，即共享资源会被某个线程更改。所以当某个线程获取共享资源时，会阻止别的线程获取共享资源。也称独占锁或者互斥锁，例如java中的synchronized同步锁。 乐观锁: 假设不会发生并发冲突，只有在最后更新共享资源的时候会判断一下在此期间有没有别的线程修改了这个共享资源。如果发生冲突就重试，直到没有冲突，更新成功。CAS就是一种乐观锁实现方式。 由于乐观锁不会阻塞其他线程，所以相对相率更高。 ","date":"2021-01-07","objectID":"/cas/:2:0","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#悲观锁与乐观锁"},{"categories":null,"content":" CAS","date":"2021-01-07","objectID":"/cas/:3:0","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#cas"},{"categories":null,"content":" 定义 compare and swap 比较并且交换JVM的CAS同时包含了CPU的CAS指令和自选操作。 CPU的CAS指令核心是三个值之间的比较和交换： 当前内存值(O) 预期原来的值(C) 期待更新的值(U) 比较方式： 如果内存位置O的值与预期原值C相匹配，那么处理器会自动将该位置值更新为新值,返回true。否则处理器不做任何操作，返回false。 JVM接收到false后会自旋操作，直到收到true为止。 eg: 假设当前有两个线程t1和t2并发操作O（O处于内存中），当t1拿到锁准备开始变更O时，t1会先把O拷贝出一个它自己的线程副本C(处于CPU缓存中)，然后对副本做对应的操作产生U，之后再用C去跟内存中的O做比较，如果C=O，说明内存中的O没有被其他线程变更，那么就把U刷写进内存替换掉O，并且返回true；如果C!=O，就直接返回false。 JVM接收到false后，就会从头再来一遍，也就是自旋。但是要注意的是，此时内存中的O已经被t2更改为O+了,所以t1会把O+作为当前值创建副本C+,执行操作后产生U+,然后用C+再去跟内存中的值对比。如此循环往复，直到CPU返回true为止。 典型就是JUC并发框架下的atomic原子类型。 注意：CAS本身不循环，循环也就是自旋是由JVM实现的。 ","date":"2021-01-07","objectID":"/cas/:3:1","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#定义-compare-and-swap-比较并且交换"},{"categories":null,"content":" CS的三大问题 ABA问题 开销问题 只能保证一个内存变量的原子操作 ABA问题问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。 问题描述：t1和t2同时操作A，t1要把A改为B再改回A，并且t1比t2速度快的多，导致t2要把A改为C时，比较的结果会认为A没有被改变过，会直接进行替换，导致了数据丢失。 eg有一条单向链A-\u003eB，我们想通过并发把它变为B-\u003eC-\u003eD。 线程t1负责把A移除，让栈顶变为B，但是还没有进行CAS。 此时一个非常快的线程t2，它把链条中的元素全部出栈，然后再依次装入A、C、D 此时单向链变为A-\u003eC-\u003eD 然后t1在进行CAS时，由于栈顶还是A，所以compare就会通过，并且完成替换。 此时单向链变为：B-\u003enull 从结果上来看，C和D丢失掉了。 解决办法 加时间戳或者版本戳 AtomicStampedReference（内部也是版本戳） AtomicStampedReference怎么用暂时还不会，以后再说吧😄 public static void main(String[] args) { AtomicStampedReference\u003cInteger\u003e stampedReference = new AtomicStampedReference\u003c\u003e(100,1); //飞快的t2 new Thread(() -\u003e { stampedReference.compareAndSet(100, 101, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); stampedReference.compareAndSet(101, 100, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); },\"t2\").start(); //龟速的t1 new Thread(() -\u003e { int stamp = stampedReference.getStamp(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); },\"t1\").start(); } 开销问题自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。貌似目前无解，好像也很难遇到。 只能保证一个共享变量的原子操作 用锁 多个变量合并成一个变量 ","date":"2021-01-07","objectID":"/cas/:3:2","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#cs的三大问题"},{"categories":null,"content":" CS的三大问题 ABA问题 开销问题 只能保证一个内存变量的原子操作 ABA问题问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。 问题描述：t1和t2同时操作A，t1要把A改为B再改回A，并且t1比t2速度快的多，导致t2要把A改为C时，比较的结果会认为A没有被改变过，会直接进行替换，导致了数据丢失。 eg有一条单向链A-\u003eB，我们想通过并发把它变为B-\u003eC-\u003eD。 线程t1负责把A移除，让栈顶变为B，但是还没有进行CAS。 此时一个非常快的线程t2，它把链条中的元素全部出栈，然后再依次装入A、C、D 此时单向链变为A-\u003eC-\u003eD 然后t1在进行CAS时，由于栈顶还是A，所以compare就会通过，并且完成替换。 此时单向链变为：B-\u003enull 从结果上来看，C和D丢失掉了。 解决办法 加时间戳或者版本戳 AtomicStampedReference（内部也是版本戳） AtomicStampedReference怎么用暂时还不会，以后再说吧😄 public static void main(String[] args) { AtomicStampedReference stampedReference = new AtomicStampedReference\u003c\u003e(100,1); //飞快的t2 new Thread(() -\u003e { stampedReference.compareAndSet(100, 101, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); stampedReference.compareAndSet(101, 100, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); },\"t2\").start(); //龟速的t1 new Thread(() -\u003e { int stamp = stampedReference.getStamp(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); },\"t1\").start(); } 开销问题自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。貌似目前无解，好像也很难遇到。 只能保证一个共享变量的原子操作 用锁 多个变量合并成一个变量 ","date":"2021-01-07","objectID":"/cas/:3:2","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#aba问题"},{"categories":null,"content":" CS的三大问题 ABA问题 开销问题 只能保证一个内存变量的原子操作 ABA问题问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。 问题描述：t1和t2同时操作A，t1要把A改为B再改回A，并且t1比t2速度快的多，导致t2要把A改为C时，比较的结果会认为A没有被改变过，会直接进行替换，导致了数据丢失。 eg有一条单向链A-\u003eB，我们想通过并发把它变为B-\u003eC-\u003eD。 线程t1负责把A移除，让栈顶变为B，但是还没有进行CAS。 此时一个非常快的线程t2，它把链条中的元素全部出栈，然后再依次装入A、C、D 此时单向链变为A-\u003eC-\u003eD 然后t1在进行CAS时，由于栈顶还是A，所以compare就会通过，并且完成替换。 此时单向链变为：B-\u003enull 从结果上来看，C和D丢失掉了。 解决办法 加时间戳或者版本戳 AtomicStampedReference（内部也是版本戳） AtomicStampedReference怎么用暂时还不会，以后再说吧😄 public static void main(String[] args) { AtomicStampedReference stampedReference = new AtomicStampedReference\u003c\u003e(100,1); //飞快的t2 new Thread(() -\u003e { stampedReference.compareAndSet(100, 101, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); stampedReference.compareAndSet(101, 100, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); },\"t2\").start(); //龟速的t1 new Thread(() -\u003e { int stamp = stampedReference.getStamp(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); },\"t1\").start(); } 开销问题自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。貌似目前无解，好像也很难遇到。 只能保证一个共享变量的原子操作 用锁 多个变量合并成一个变量 ","date":"2021-01-07","objectID":"/cas/:3:2","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#问题描述"},{"categories":null,"content":" CS的三大问题 ABA问题 开销问题 只能保证一个内存变量的原子操作 ABA问题问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。 问题描述：t1和t2同时操作A，t1要把A改为B再改回A，并且t1比t2速度快的多，导致t2要把A改为C时，比较的结果会认为A没有被改变过，会直接进行替换，导致了数据丢失。 eg有一条单向链A-\u003eB，我们想通过并发把它变为B-\u003eC-\u003eD。 线程t1负责把A移除，让栈顶变为B，但是还没有进行CAS。 此时一个非常快的线程t2，它把链条中的元素全部出栈，然后再依次装入A、C、D 此时单向链变为A-\u003eC-\u003eD 然后t1在进行CAS时，由于栈顶还是A，所以compare就会通过，并且完成替换。 此时单向链变为：B-\u003enull 从结果上来看，C和D丢失掉了。 解决办法 加时间戳或者版本戳 AtomicStampedReference（内部也是版本戳） AtomicStampedReference怎么用暂时还不会，以后再说吧😄 public static void main(String[] args) { AtomicStampedReference stampedReference = new AtomicStampedReference\u003c\u003e(100,1); //飞快的t2 new Thread(() -\u003e { stampedReference.compareAndSet(100, 101, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); stampedReference.compareAndSet(101, 100, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); },\"t2\").start(); //龟速的t1 new Thread(() -\u003e { int stamp = stampedReference.getStamp(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); },\"t1\").start(); } 开销问题自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。貌似目前无解，好像也很难遇到。 只能保证一个共享变量的原子操作 用锁 多个变量合并成一个变量 ","date":"2021-01-07","objectID":"/cas/:3:2","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#eg"},{"categories":null,"content":" CS的三大问题 ABA问题 开销问题 只能保证一个内存变量的原子操作 ABA问题问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。 问题描述：t1和t2同时操作A，t1要把A改为B再改回A，并且t1比t2速度快的多，导致t2要把A改为C时，比较的结果会认为A没有被改变过，会直接进行替换，导致了数据丢失。 eg有一条单向链A-\u003eB，我们想通过并发把它变为B-\u003eC-\u003eD。 线程t1负责把A移除，让栈顶变为B，但是还没有进行CAS。 此时一个非常快的线程t2，它把链条中的元素全部出栈，然后再依次装入A、C、D 此时单向链变为A-\u003eC-\u003eD 然后t1在进行CAS时，由于栈顶还是A，所以compare就会通过，并且完成替换。 此时单向链变为：B-\u003enull 从结果上来看，C和D丢失掉了。 解决办法 加时间戳或者版本戳 AtomicStampedReference（内部也是版本戳） AtomicStampedReference怎么用暂时还不会，以后再说吧😄 public static void main(String[] args) { AtomicStampedReference stampedReference = new AtomicStampedReference\u003c\u003e(100,1); //飞快的t2 new Thread(() -\u003e { stampedReference.compareAndSet(100, 101, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); stampedReference.compareAndSet(101, 100, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); },\"t2\").start(); //龟速的t1 new Thread(() -\u003e { int stamp = stampedReference.getStamp(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); },\"t1\").start(); } 开销问题自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。貌似目前无解，好像也很难遇到。 只能保证一个共享变量的原子操作 用锁 多个变量合并成一个变量 ","date":"2021-01-07","objectID":"/cas/:3:2","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#解决办法"},{"categories":null,"content":" CS的三大问题 ABA问题 开销问题 只能保证一个内存变量的原子操作 ABA问题问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。 问题描述：t1和t2同时操作A，t1要把A改为B再改回A，并且t1比t2速度快的多，导致t2要把A改为C时，比较的结果会认为A没有被改变过，会直接进行替换，导致了数据丢失。 eg有一条单向链A-\u003eB，我们想通过并发把它变为B-\u003eC-\u003eD。 线程t1负责把A移除，让栈顶变为B，但是还没有进行CAS。 此时一个非常快的线程t2，它把链条中的元素全部出栈，然后再依次装入A、C、D 此时单向链变为A-\u003eC-\u003eD 然后t1在进行CAS时，由于栈顶还是A，所以compare就会通过，并且完成替换。 此时单向链变为：B-\u003enull 从结果上来看，C和D丢失掉了。 解决办法 加时间戳或者版本戳 AtomicStampedReference（内部也是版本戳） AtomicStampedReference怎么用暂时还不会，以后再说吧😄 public static void main(String[] args) { AtomicStampedReference stampedReference = new AtomicStampedReference\u003c\u003e(100,1); //飞快的t2 new Thread(() -\u003e { stampedReference.compareAndSet(100, 101, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); stampedReference.compareAndSet(101, 100, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); },\"t2\").start(); //龟速的t1 new Thread(() -\u003e { int stamp = stampedReference.getStamp(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); },\"t1\").start(); } 开销问题自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。貌似目前无解，好像也很难遇到。 只能保证一个共享变量的原子操作 用锁 多个变量合并成一个变量 ","date":"2021-01-07","objectID":"/cas/:3:2","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#开销问题"},{"categories":null,"content":" CS的三大问题 ABA问题 开销问题 只能保证一个内存变量的原子操作 ABA问题问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。 问题描述：t1和t2同时操作A，t1要把A改为B再改回A，并且t1比t2速度快的多，导致t2要把A改为C时，比较的结果会认为A没有被改变过，会直接进行替换，导致了数据丢失。 eg有一条单向链A-\u003eB，我们想通过并发把它变为B-\u003eC-\u003eD。 线程t1负责把A移除，让栈顶变为B，但是还没有进行CAS。 此时一个非常快的线程t2，它把链条中的元素全部出栈，然后再依次装入A、C、D 此时单向链变为A-\u003eC-\u003eD 然后t1在进行CAS时，由于栈顶还是A，所以compare就会通过，并且完成替换。 此时单向链变为：B-\u003enull 从结果上来看，C和D丢失掉了。 解决办法 加时间戳或者版本戳 AtomicStampedReference（内部也是版本戳） AtomicStampedReference怎么用暂时还不会，以后再说吧😄 public static void main(String[] args) { AtomicStampedReference stampedReference = new AtomicStampedReference\u003c\u003e(100,1); //飞快的t2 new Thread(() -\u003e { stampedReference.compareAndSet(100, 101, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); stampedReference.compareAndSet(101, 100, stampedReference.getStamp(), stampedReference.getStamp() + 1 ); },\"t2\").start(); //龟速的t1 new Thread(() -\u003e { int stamp = stampedReference.getStamp(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); },\"t1\").start(); } 开销问题自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。貌似目前无解，好像也很难遇到。 只能保证一个共享变量的原子操作 用锁 多个变量合并成一个变量 ","date":"2021-01-07","objectID":"/cas/:3:2","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#只能保证一个共享变量的原子操作"},{"categories":null,"content":" AotomicInteger原理 public final int getAndUpdate(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return prev; } //CAS操作 private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe(); public final boolean compareAndSet(int expect, int update) { return U.compareAndSwapInt(this, VALUE, expect, update); } 可以看到，这里使用do-while对CAS做判断，如果CAS返回false，那么就继续循环。 ","date":"2021-01-07","objectID":"/cas/:4:0","series":null,"tags":["Java"],"title":"CAS原理和问题","uri":"/cas/#aotomicinteger原理"},{"categories":["technology"],"content":" 反编译指令 javap -v XXX.class ","date":"2021-01-06","objectID":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/:1:0","series":null,"tags":["java"],"title":"synchornized关键字","uri":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/#反编译指令"},{"categories":["technology"],"content":" 监视器对象Monitor","date":"2021-01-06","objectID":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/:2:0","series":null,"tags":["java"],"title":"synchornized关键字","uri":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/#监视器对象monitor"},{"categories":["technology"],"content":" 原理当synchronized加载代码块上，JVM会执行两条指令： 加锁：MonitorEnter 解锁：MonitorExit 当synchornized关键字加在方法上，jvm会给该方法加一个flag：ACC_SYNCHRONIZED ","date":"2021-01-06","objectID":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/:3:0","series":null,"tags":["java"],"title":"synchornized关键字","uri":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/#原理"},{"categories":["technology"],"content":" Java对象头当我们在代码中new一个object，每个对象在内存中都会存放相关的数据，除了我们自己定义的属性之外，还存在着一个对象头，对象头存放着GC年龄（MarkWork）， ","date":"2021-01-06","objectID":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/:4:0","series":null,"tags":["java"],"title":"synchornized关键字","uri":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/#java对象头"},{"categories":["technology"],"content":" Synchornized中的锁分类","date":"2021-01-06","objectID":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/:5:0","series":null,"tags":["java"],"title":"synchornized关键字","uri":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/#synchornized中的锁分类"},{"categories":["technology"],"content":" 轻量锁通过CAS操作来加锁和解锁，线程如果拿不到锁，会自旋，而不需要挂起线程，减少了上下文切换，相对性能较高。 ","date":"2021-01-06","objectID":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/:5:1","series":null,"tags":["java"],"title":"synchornized关键字","uri":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/#轻量锁"},{"categories":["technology"],"content":" 自旋锁不挂起线程，bu ","date":"2021-01-06","objectID":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/:5:2","series":null,"tags":["java"],"title":"synchornized关键字","uri":"/synchornized%E5%85%B3%E9%94%AE%E5%AD%97/#自旋锁"},{"categories":null,"content":"序列化：Object =\u003e String 反序列化：String =\u003e Object ","date":"0001-01-01","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96/:0:0","series":null,"tags":["Android"],"title":"序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96/#"},{"categories":null,"content":" 核心原理序列化是把对象转成字符串的过程，那么转换之后的字符串，就保存在文件中，所以Java的序列化是基于文件IO的。 ","date":"0001-01-01","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96/:1:0","series":null,"tags":["Android"],"title":"序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96/#核心原理"},{"categories":null,"content":" Serializable public class Main { public static void main(String[] args) { try { Scanner scanner = new Scanner(System.in); boolean goOn = true; while (goOn) { System.out.println(\"1写入，2读取，0退出\"); int answer = scanner.nextInt(); switch (answer) { case 1: writeObject(); break; case 2: readObject(); break; default: goOn = false; } } } catch (Exception e) { e.printStackTrace(); } } /** * 写入 * @throws IOException */ private static void writeObject() throws IOException { ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(\"test.txt\")); Student student = new Student(); stream.writeObject(student); } /** * 读取 * @throws IOException * @throws ClassNotFoundException */ private static void readObject() throws IOException, ClassNotFoundException { ObjectInputStream stream = new ObjectInputStream(new FileInputStream(\"test.txt\")); Student student = (Student) stream.readObject(); System.out.println(\"读到对象：\" + student.toString()); } /** * 测试序列化类 */ private static class Student implements Serializable { /** * 注意： * 1.必须是static final long serialVersionUID； * 2.在反序列化时，Java根据这个来判定类型是否发生了变化，如果变化会抛出InvalidClassException（类型无效异常）； * 3.并不是必须，Java会默认生成； * 4.如果两个端同时同时操作序列化文件，A端的serialVersionUID变了，比如增加了字段，然后进行了序列化；而B端的serialVersionUID没有变，是可以成功反序列化的，但是会忽略A端新增的字段。 */ private static final long serialVersionUID = 2L; public String name = \"张三\"; public int age = 18; private final Teacher teacher = new Teacher(); @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", teacher=\" + teacher + '}'; } } /** * 序列化类型中的引用类型必须也是可序列化的 */ private static class Teacher implements Serializable { public String name = \"李四\"; public int age = 22; @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } } ","date":"0001-01-01","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96/:2:0","series":null,"tags":["Android"],"title":"序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96/#serializable"},{"categories":null,"content":" Externalizable提供了两个抽象方法： writeExternal(ObjectOutPut out) readExternal(ObjectOutPut out) ","date":"0001-01-01","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96/:3:0","series":null,"tags":["Android"],"title":"序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96/#externalizable"},{"categories":null,"content":" Parcelable","date":"0001-01-01","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96/:4:0","series":null,"tags":["Android"],"title":"序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96/#parcelable"}]