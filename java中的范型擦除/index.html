<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-CN lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Java中的范型 &#183; Vee's space</title><meta name=description content><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/print.css media=print><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/poole.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/syntax.css><link type=text/css rel=stylesheet href=https://vee-zhang.github.iocss/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://vee-zhang.github.io/java%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/index.md rel=alternate type=text/plain title="Vee's space"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vee-zhang.github.io><h1>Vee's space</h1></a><p class=lead>关于 DoIt 主题</p></div><nav><ul class=sidebar-nav><li><a href=https://vee-zhang.github.io>Home</a></li><li><a href=/posts/>所有文章</a></li><li><a href=/tags/>标签</a></li><li><a href=/categories/>分类</a></li><li><a href=/series/>系列</a></li><li><a href=/about/>关于</a></li></ul></nav><p>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</p></div></aside><main class="content container"><div class=post><h1>Java中的范型</h1><time datetime=2022-03-19T15:33:02+0800 class=post-date>Sat, Mar 19, 2022</time><h2 id=伪范型和范型擦除>伪范型和范型擦除</h2><p><strong>在编译期间，所有的范型信息都会被擦除掉。</strong></p><p>Java中的范型是在编译器这个层次来实现的，在生成Java字节码中是不包含范型中的类型信息的，使用范型的时候加上的类型参数，会在编译期间去掉，这个过程就叫范型擦除。</p><p>验证：声明两个不同范型的List，然后比较两个list的类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>list1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>list1</span><span class=o>.</span><span class=na>getClass</span><span class=o>()</span> <span class=o>==</span> <span class=n>list2</span><span class=o>.</span><span class=na>getClass</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出 true
</span></span></span></code></pre></td></tr></table></div></div><h2 id=范型通配符>范型通配符</h2><ul><li><code>&lt;? extends T></code> 子类限定通配符，</li><li><code>&lt;? super T></code> 超类限定通配符，</li><li><code>&lt;?></code> 无限定通配符，</li></ul><h2 id=范型的限制>范型的限制</h2><ol><li>范型不能用来实例化变量；</li><li>静态域或方法不能使用自己类型的范型（因为只有在创建对象后才知道范型的具体类型）；</li><li>范型不支持使用结构体，可以使用引用的包装类型替代，如Double,Integer,Long等；</li><li>范型不允许使用instanceof关键字判断类型；</li><li>类型擦除；</li><li>范型类不能继承/扩展（使用extends关键字）Expection、Throwable；</li><li>不能try-catch捕获范型对象；</li></ol></div></main></body></html>